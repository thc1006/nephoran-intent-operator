# =============================================================================
# Enhanced CI/CD Makefile for Nephoran Intent Operator - 2025
# =============================================================================
# Production-ready build targets supporting the consolidated CI/CD pipeline
# Features: Intelligent parallelization, timeout management, resource optimization
# Target: Large Go codebase with 30+ binaries and complex dependencies
# =============================================================================

SHELL := /bin/bash
.DEFAULT_GOAL := help

# =============================================================================
# Build Environment Configuration
# =============================================================================

# Go build optimization for Linux-only deployment
export CGO_ENABLED := 0
export GOOS := linux
export GOARCH := amd64
export GOMAXPROCS := $(shell echo $${GOMAXPROCS:-8})
export GOMEMLIMIT := $(shell echo $${GOMEMLIMIT:-6GiB})
export GOGC := $(shell echo $${GOGC:-100})
export GOCACHE := $(shell echo $${GOCACHE:-/tmp/go-build-cache})
export GOMODCACHE := $(shell echo $${GOMODCACHE:-/tmp/go-mod-cache})

# Build flags for production-ready binaries
BUILD_FLAGS := -trimpath -ldflags='-s -w -extldflags=-static' -tags='netgo,osusergo,static_build,release'
TEST_FLAGS := -v -timeout=10m -parallel=6
LINT_FLAGS := --timeout=12m --verbose --issues-exit-code=1

# Directory configuration
BIN_DIR := bin
DIST_DIR := dist
COVERAGE_DIR := coverage-reports
TEST_RESULTS_DIR := test-results
SECURITY_DIR := security-reports

# Build metadata
BUILD_DATE := $(shell date -u +'%Y-%m-%dT%H:%M:%SZ')
GIT_COMMIT := $(shell git rev-parse --short HEAD 2>/dev/null || echo 'unknown')
GIT_BRANCH := $(shell git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'unknown')
VERSION := $(shell git describe --tags --always --dirty 2>/dev/null || echo 'dev')

# Enhanced ldflags with build metadata
LDFLAGS := -s -w -extldflags=-static \
	-X 'github.com/thc1006/nephoran-intent-operator/pkg/version.Version=$(VERSION)' \
	-X 'github.com/thc1006/nephoran-intent-operator/pkg/version.GitCommit=$(GIT_COMMIT)' \
	-X 'github.com/thc1006/nephoran-intent-operator/pkg/version.BuildDate=$(BUILD_DATE)' \
	-X 'github.com/thc1006/nephoran-intent-operator/pkg/version.GitBranch=$(GIT_BRANCH)'

ENHANCED_BUILD_FLAGS := -trimpath -ldflags='$(LDFLAGS)' -tags='netgo,osusergo,static_build,release'

# =============================================================================
# Component Classification for Intelligent Building
# =============================================================================

# Critical components (highest priority)
CRITICAL_CMDS := \
	cmd/intent-ingest \
	cmd/conductor-loop \
	cmd/llm-processor \
	cmd/webhook \
	cmd/porch-publisher

# High-priority services
HIGH_PRIORITY_CMDS := \
	cmd/conductor \
	cmd/nephio-bridge \
	cmd/a1-sim \
	cmd/e2-kmp-sim \
	cmd/fcaps-sim

# Standard services
STANDARD_CMDS := \
	cmd/o1-ves-sim \
	cmd/oran-adaptor \
	cmd/porch-direct \
	cmd/porch-structured-patch \
	cmd/fcaps-reducer

# Utility and development tools
UTILITY_CMDS := \
	cmd/conductor-watch \
	cmd/performance-comparison \
	cmd/performance-regression-test \
	cmd/security-validator \
	cmd/technical-debt-monitor \
	cmd/test-context-builder \
	cmd/test-lint

# All command directories (auto-detected + classified)
ALL_CMDS := $(CRITICAL_CMDS) $(HIGH_PRIORITY_CMDS) $(STANDARD_CMDS) $(UTILITY_CMDS)

# Package directories for library builds
PKG_DIRS := \
	./pkg/context \
	./pkg/clients \
	./pkg/nephio \
	./pkg/core \
	./pkg/security \
	./pkg/monitoring \
	./pkg/llm

# Controller directories
CONTROLLER_DIRS := ./controllers

# Test patterns for different test categories
UNIT_TEST_PATTERNS := ./pkg/... ./controllers/... ./api/...
INTEGRATION_TEST_PATTERNS := ./tests/integration/...
E2E_TEST_PATTERNS := ./tests/e2e/...

# =============================================================================
# Help and Information
# =============================================================================

.PHONY: help
help: ## Show comprehensive help with all available targets
	@echo "🚀 Nephoran Intent Operator - Enhanced CI/CD Makefile 2025"
	@echo "==========================================================="
	@echo ""
	@echo "📋 Primary Build Targets:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-25s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(ci-|build-|test-|deps-)"
	@echo ""
	@echo "🔧 Utility Targets:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[33m%-25s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(clean|debug|status|validate)"
	@echo ""
	@echo "🛠️  Advanced Targets:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[35m%-25s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -vE "(ci-|build-|test-|deps-|clean|debug|status|validate)"
	@echo ""
	@echo "📊 Current Configuration:"
	@echo "  Go Version: $(shell go version 2>/dev/null | cut -d' ' -f3 || echo 'not found')"
	@echo "  Build Mode: $(shell echo $${BUILD_MODE:-auto})"
	@echo "  Target: $(GOOS)/$(GOARCH)"
	@echo "  Max Procs: $(GOMAXPROCS)"
	@echo "  Memory Limit: $(GOMEMLIMIT)"
	@echo "  Git Branch: $(GIT_BRANCH)"
	@echo "  Git Commit: $(GIT_COMMIT)"
	@echo "  Version: $(VERSION)"

.PHONY: info
info: ## Show detailed build environment information
	@echo "🔍 Build Environment Information"
	@echo "================================"
	@echo "Go Configuration:"
	@echo "  Version: $(shell go version 2>/dev/null || echo 'Go not found')"
	@echo "  GOCACHE: $(GOCACHE)"
	@echo "  GOMODCACHE: $(GOMODCACHE)"
	@echo "  CGO_ENABLED: $(CGO_ENABLED)"
	@echo "  GOOS: $(GOOS)"
	@echo "  GOARCH: $(GOARCH)"
	@echo "  GOMAXPROCS: $(GOMAXPROCS)"
	@echo "  GOMEMLIMIT: $(GOMEMLIMIT)"
	@echo "  GOGC: $(GOGC)"
	@echo ""
	@echo "Build Configuration:"
	@echo "  Build Date: $(BUILD_DATE)"
	@echo "  Git Commit: $(GIT_COMMIT)"
	@echo "  Git Branch: $(GIT_BRANCH)"
	@echo "  Version: $(VERSION)"
	@echo "  Build Flags: $(BUILD_FLAGS)"
	@echo ""
	@echo "Component Classification:"
	@echo "  Critical Commands: $(words $(CRITICAL_CMDS))"
	@echo "  High Priority Commands: $(words $(HIGH_PRIORITY_CMDS))"
	@echo "  Standard Commands: $(words $(STANDARD_CMDS))"
	@echo "  Utility Commands: $(words $(UTILITY_CMDS))"
	@echo "  Total Commands: $(words $(ALL_CMDS))"
	@echo "  Package Directories: $(words $(PKG_DIRS))"

# =============================================================================
# Dependency Management
# =============================================================================

.PHONY: deps-download
deps-download: ## Download Go modules with intelligent retry and caching
	@echo "📦 Downloading Go modules with intelligent retry..."
	@$(call setup-cache-dirs)
	@$(call retry-command,3,30,"go mod download -x","Module download")
	@echo "🔍 Verifying module integrity..."
	@go mod verify
	@echo "✅ Dependencies downloaded and verified"

.PHONY: deps-tidy
deps-tidy: ## Ensure go.mod and go.sum are properly maintained
	@echo "🧹 Tidying Go modules..."
	@go mod tidy
	@echo "✅ Go modules tidied"

.PHONY: deps-verify
deps-verify: ## Verify dependencies and check for vulnerabilities
	@echo "🔍 Verifying dependencies..."
	@go mod verify
	@if command -v govulncheck >/dev/null 2>&1; then \
		echo "🔒 Checking for vulnerabilities..."; \
		govulncheck ./...; \
	else \
		echo "⚠️  govulncheck not installed - skipping vulnerability check"; \
	fi
	@echo "✅ Dependency verification completed"

# =============================================================================
# Clean and Setup Operations
# =============================================================================

.PHONY: clean
clean: clean-bin clean-dist clean-cache clean-test-results ## Remove all build artifacts and caches
	@echo "🧹 Complete cleanup finished"

.PHONY: clean-bin
clean-bin: ## Remove binary directory
	@echo "🗑️  Cleaning binary directory..."
	@rm -rf $(BIN_DIR)
	@mkdir -p $(BIN_DIR)

.PHONY: clean-dist
clean-dist: ## Remove distribution directory
	@echo "🗑️  Cleaning distribution directory..."
	@rm -rf $(DIST_DIR)
	@mkdir -p $(DIST_DIR)

.PHONY: clean-cache
clean-cache: ## Remove Go build and module caches
	@echo "🗑️  Cleaning Go caches..."
	@go clean -cache -modcache -testcache 2>/dev/null || true
	@rm -rf $(GOCACHE) $(GOMODCACHE) || true

.PHONY: clean-test-results
clean-test-results: ## Remove test results and coverage reports
	@echo "🗑️  Cleaning test results..."
	@rm -rf $(TEST_RESULTS_DIR) $(COVERAGE_DIR) $(SECURITY_DIR)

.PHONY: setup-dirs
setup-dirs: ## Create all necessary build directories
	@echo "📁 Setting up build directories..."
	@mkdir -p $(BIN_DIR) $(DIST_DIR) $(COVERAGE_DIR) $(TEST_RESULTS_DIR) $(SECURITY_DIR)
	@$(call setup-cache-dirs)
	@echo "✅ Build directories ready"

# =============================================================================
# Fast CI/CD Build Targets
# =============================================================================

.PHONY: ci-ultra-fast
ci-ultra-fast: clean-bin setup-dirs deps-download build-critical-parallel ## Ultra-fast CI build (critical components only, parallel)
	@echo "⚡ Ultra-fast CI build completed"
	@$(call build-status-report)

.PHONY: ci-fast
ci-fast: clean-bin setup-dirs deps-download build-critical build-high-priority ## Fast CI build (critical + high priority)
	@echo "🚀 Fast CI build completed"
	@$(call build-status-report)

.PHONY: ci-full
ci-full: clean-bin setup-dirs deps-download build-all-parallel ## Full CI build (all components, parallel)
	@echo "🏗️  Full CI build completed"
	@$(call build-status-report)

.PHONY: ci-debug
ci-debug: clean-bin setup-dirs deps-download build-all-sequential-debug ## Debug CI build (sequential with verbose output)
	@echo "🐛 Debug CI build completed"
	@$(call build-status-report)

# =============================================================================
# Component Building Targets
# =============================================================================

.PHONY: build-critical
build-critical: setup-dirs ## Build critical components sequentially
	@echo "🔨 Building critical components..."
	@$(call build-component-list,$(CRITICAL_CMDS),60)
	@echo "✅ Critical components built"

.PHONY: build-critical-parallel
build-critical-parallel: setup-dirs ## Build critical components in parallel
	@echo "🚀 Building critical components in parallel..."
	@$(call build-component-list-parallel,$(CRITICAL_CMDS),45,4)
	@echo "✅ Critical components built (parallel)"

.PHONY: build-high-priority
build-high-priority: setup-dirs ## Build high-priority components
	@echo "🔨 Building high-priority components..."
	@$(call build-component-list,$(HIGH_PRIORITY_CMDS),60)
	@echo "✅ High-priority components built"

.PHONY: build-standard
build-standard: setup-dirs ## Build standard components
	@echo "🔨 Building standard components..."
	@$(call build-component-list,$(STANDARD_CMDS),60)
	@echo "✅ Standard components built"

.PHONY: build-utilities
build-utilities: setup-dirs ## Build utility components
	@echo "🔧 Building utility components..."
	@$(call build-component-list,$(UTILITY_CMDS),45)
	@echo "✅ Utility components built"

.PHONY: build-all-parallel
build-all-parallel: setup-dirs ## Build all components in parallel batches
	@echo "🚀 Building all components in parallel batches..."
	@$(call build-component-list-parallel,$(CRITICAL_CMDS),60,4)
	@$(call build-component-list-parallel,$(HIGH_PRIORITY_CMDS),60,3)
	@$(call build-component-list-parallel,$(STANDARD_CMDS),60,3)
	@$(call build-component-list-parallel,$(UTILITY_CMDS),45,2)
	@echo "✅ All components built (parallel batches)"

.PHONY: build-all-sequential-debug
build-all-sequential-debug: setup-dirs ## Build all components sequentially with debug output
	@echo "🐛 Building all components sequentially (debug mode)..."
	@$(call build-component-list-debug,$(ALL_CMDS),90)
	@echo "✅ All components built (debug mode)"

.PHONY: build-packages
build-packages: setup-dirs ## Build package libraries
	@echo "📦 Building package libraries..."
	@for pkg in $(PKG_DIRS); do \
		echo "  Building package: $$pkg"; \
		timeout 60s go build $(ENHANCED_BUILD_FLAGS) $$pkg/... 2>/dev/null || { \
			echo "  ⚠️  $$pkg build failed or timed out"; \
		}; \
	done
	@echo "✅ Package libraries built"

.PHONY: build-controllers
build-controllers: setup-dirs ## Build controllers
	@echo "🎮 Building controllers..."
	@timeout 60s go build $(ENHANCED_BUILD_FLAGS) $(CONTROLLER_DIRS)/... 2>/dev/null || { \
		echo "⚠️  Controllers build failed or timed out"; \
	}
	@echo "✅ Controllers built"

.PHONY: build-single
build-single: setup-dirs ## Build a single component (usage: make build-single CMD=cmd/intent-ingest)
	@$(call validate-cmd-param)
	@echo "🔨 Building single component: $(CMD)"
	@$(call build-single-component,$(CMD),90)
	@echo "✅ $(CMD) built successfully"

# =============================================================================
# Testing Targets
# =============================================================================

.PHONY: test-unit
test-unit: setup-dirs ## Run unit tests with coverage
	@echo "🧪 Running unit tests..."
	@mkdir -p $(COVERAGE_DIR) $(TEST_RESULTS_DIR)
	@go test $(TEST_FLAGS) -coverprofile=$(COVERAGE_DIR)/unit-coverage.out $(UNIT_TEST_PATTERNS) 2>&1 | tee $(TEST_RESULTS_DIR)/unit-tests.log
	@echo "📊 Generating coverage report..."
	@go tool cover -html=$(COVERAGE_DIR)/unit-coverage.out -o $(COVERAGE_DIR)/unit-coverage.html 2>/dev/null || echo "Coverage report generation failed"
	@echo "✅ Unit tests completed"

.PHONY: test-integration
test-integration: setup-dirs ## Run integration tests
	@echo "🔗 Running integration tests..."
	@mkdir -p $(TEST_RESULTS_DIR)
	@go test $(TEST_FLAGS) -tags=integration $(INTEGRATION_TEST_PATTERNS) 2>&1 | tee $(TEST_RESULTS_DIR)/integration-tests.log || { \
		echo "⚠️  Some integration tests failed"; \
	}
	@echo "✅ Integration tests completed"

.PHONY: test-e2e
test-e2e: setup-dirs build-critical ## Run end-to-end tests
	@echo "🏁 Running end-to-end tests..."
	@mkdir -p $(TEST_RESULTS_DIR)
	@go test $(TEST_FLAGS) -tags=e2e $(E2E_TEST_PATTERNS) 2>&1 | tee $(TEST_RESULTS_DIR)/e2e-tests.log || { \
		echo "⚠️  Some e2e tests failed"; \
	}
	@echo "✅ End-to-end tests completed"

.PHONY: test-critical
test-critical: setup-dirs ## Test only critical components
	@echo "🧪 Testing critical components..."
	@mkdir -p $(TEST_RESULTS_DIR)
	@for cmd in $(CRITICAL_CMDS); do \
		if [ -d "$$cmd" ]; then \
			echo "  Testing $$cmd..."; \
			timeout 60s go test $(TEST_FLAGS) ./$$cmd/... 2>&1 | tee $(TEST_RESULTS_DIR)/$$(basename $$cmd)-tests.log || { \
				echo "  ⚠️  $$cmd tests failed"; \
			}; \
		fi \
	done
	@echo "✅ Critical component tests completed"

.PHONY: test-race
test-race: setup-dirs ## Run tests with race detection
	@echo "🏃 Running tests with race detection..."
	@mkdir -p $(TEST_RESULTS_DIR)
	@CGO_ENABLED=1 go test $(TEST_FLAGS) -race $(UNIT_TEST_PATTERNS) 2>&1 | tee $(TEST_RESULTS_DIR)/race-tests.log
	@echo "✅ Race detection tests completed"

.PHONY: test-all
test-all: test-unit test-integration test-race ## Run all test suites
	@echo "🎯 All test suites completed"

# =============================================================================
# Quality Assurance Targets  
# =============================================================================

.PHONY: lint
lint: ## Run golangci-lint with comprehensive checks
	@echo "📋 Running comprehensive linting..."
	@if command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run $(LINT_FLAGS) ./...; \
	else \
		echo "⚠️  golangci-lint not installed - please install it"; \
		exit 1; \
	fi
	@echo "✅ Linting completed"

.PHONY: vet
vet: ## Run go vet analysis
	@echo "🔍 Running go vet analysis..."
	@go vet ./...
	@echo "✅ Go vet analysis completed"

.PHONY: staticcheck
staticcheck: ## Run staticcheck analysis
	@echo "🔍 Running staticcheck analysis..."
	@if command -v staticcheck >/dev/null 2>&1; then \
		staticcheck ./...; \
	else \
		echo "⚠️  staticcheck not installed - installing..."; \
		go install honnef.co/go/tools/cmd/staticcheck@latest; \
		staticcheck ./...; \
	fi
	@echo "✅ Staticcheck analysis completed"

.PHONY: security-scan
security-scan: setup-dirs ## Run comprehensive security scanning
	@echo "🔒 Running comprehensive security scanning..."
	@mkdir -p $(SECURITY_DIR)
	@$(call run-security-tool,"govulncheck","./...","vulnerability check")
	@$(call run-security-tool,"gosec -fmt json -out $(SECURITY_DIR)/gosec-report.json","./...","security analysis")
	@$(call run-security-tool,"nancy sleuth --loud","","dependency vulnerability check")
	@echo "✅ Security scanning completed"

.PHONY: quality-all
quality-all: vet staticcheck lint security-scan ## Run all quality assurance checks
	@echo "🏆 All quality checks completed"

# =============================================================================
# Status and Debugging Targets
# =============================================================================

.PHONY: status
status: ## Show comprehensive build status
	@echo "📊 Comprehensive Build Status"
	@echo "============================="
	@$(call build-status-report)
	@$(call test-status-report)
	@$(call dependency-status-report)

.PHONY: debug-env
debug-env: ## Show debug environment information
	@echo "🐛 Debug Environment Information"
	@echo "================================"
	@echo "System Information:"
	@echo "  OS: $$(uname -s 2>/dev/null || echo 'Unknown')"
	@echo "  Arch: $$(uname -m 2>/dev/null || echo 'Unknown')"
	@echo "  Kernel: $$(uname -r 2>/dev/null || echo 'Unknown')"
	@echo "  CPU Cores: $$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 'Unknown')"
	@echo "  Memory: $$(free -h 2>/dev/null | grep Mem | awk '{print $$2}' || echo 'Unknown')"
	@echo ""
	@echo "Go Environment:"
	@go env
	@echo ""
	@echo "Git Information:"
	@echo "  Branch: $(GIT_BRANCH)"
	@echo "  Commit: $(GIT_COMMIT)"
	@echo "  Status: $$(git status --porcelain 2>/dev/null | wc -l || echo 'Unknown') files modified"

.PHONY: validate-syntax
validate-syntax: ## Quick syntax validation without building
	@echo "🔍 Validating Go syntax..."
	@for cmd in $(CRITICAL_CMDS); do \
		if [ -d "$$cmd" ]; then \
			echo "  Checking $$cmd..."; \
			timeout 10s go vet ./$$cmd/... 2>/dev/null && echo "  ✅ $$cmd syntax OK" || echo "  ⚠️  $$cmd syntax issues"; \
		fi \
	done
	@echo "✅ Syntax validation completed"

.PHONY: list-components
list-components: ## List all available components
	@echo "📋 Available Components"
	@echo "======================"
	@echo "Critical Commands ($(words $(CRITICAL_CMDS))):"
	@for cmd in $(CRITICAL_CMDS); do echo "  - $$cmd"; done
	@echo ""
	@echo "High Priority Commands ($(words $(HIGH_PRIORITY_CMDS))):"
	@for cmd in $(HIGH_PRIORITY_CMDS); do echo "  - $$cmd"; done
	@echo ""
	@echo "Standard Commands ($(words $(STANDARD_CMDS))):"
	@for cmd in $(STANDARD_CMDS); do echo "  - $$cmd"; done
	@echo ""
	@echo "Utility Commands ($(words $(UTILITY_CMDS))):"
	@for cmd in $(UTILITY_CMDS); do echo "  - $$cmd"; done
	@echo ""
	@echo "Package Directories ($(words $(PKG_DIRS))):"
	@for pkg in $(PKG_DIRS); do echo "  - $$pkg"; done

# =============================================================================
# Container and Deployment Targets
# =============================================================================

.PHONY: docker-build
docker-build: build-critical ## Build production Docker image
	@echo "🐳 Building production Docker image..."
	@if [ ! -f "Dockerfile" ]; then \
		echo "❌ Dockerfile not found - use 'make docker-generate' to create one"; \
		exit 1; \
	fi
	@docker build \
		--build-arg BUILD_DATE="$(BUILD_DATE)" \
		--build-arg GIT_COMMIT="$(GIT_COMMIT)" \
		--build-arg VERSION="$(VERSION)" \
		--tag nephoran-intent-operator:latest \
		--tag nephoran-intent-operator:$(VERSION) \
		.
	@echo "✅ Docker image built successfully"

.PHONY: docker-generate
docker-generate: ## Generate production Dockerfile
	@echo "🐳 Generating production Dockerfile..."
	@cat > Dockerfile <<EOF
# =============================================================================
# Nephoran Intent Operator - Production Multi-Stage Dockerfile
# Generated by Enhanced CI/CD Makefile - $(BUILD_DATE)
# =============================================================================

# Stage 1: Minimal runtime base with security hardening
FROM gcr.io/distroless/static-debian12:nonroot AS runtime

# Stage 2: Final production image
FROM runtime AS final

# Metadata and labels for container registry
LABEL org.opencontainers.image.title="Nephoran Intent Operator"
LABEL org.opencontainers.image.description="Cloud-native Kubernetes operator for O-RAN/5G network orchestration"
LABEL org.opencontainers.image.url="https://github.com/thc1006/nephoran-intent-operator"
LABEL org.opencontainers.image.source="https://github.com/thc1006/nephoran-intent-operator"
LABEL org.opencontainers.image.version="$(VERSION)"
LABEL org.opencontainers.image.created="$(BUILD_DATE)"
LABEL org.opencontainers.image.revision="$(GIT_COMMIT)"
LABEL org.opencontainers.image.licenses="Apache-2.0"
LABEL org.opencontainers.image.vendor="THC1006"

# Copy statically-linked binaries
COPY $(BIN_DIR)/ /usr/local/bin/

# Security: Use non-root user (65532:65532 from distroless)
USER 65532:65532

# Health check for Kubernetes deployments
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
  CMD ["/usr/local/bin/intent-ingest", "--health-check"] || exit 1

# Default entrypoint and command
ENTRYPOINT ["/usr/local/bin/intent-ingest"]
CMD ["--help"]
EOF
	@echo "✅ Production Dockerfile generated"

# =============================================================================
# Advanced Utility Functions
# =============================================================================

# Function to set up cache directories with proper permissions
define setup-cache-dirs
	@echo "📁 Setting up Go cache directories..."
	@mkdir -p $(GOCACHE) $(GOMODCACHE)
	@chmod 755 $(GOCACHE) $(GOMODCACHE) 2>/dev/null || true
endef

# Function to validate CMD parameter
define validate-cmd-param
	@if [ -z "$(CMD)" ]; then \
		echo "❌ Error: CMD parameter required"; \
		echo "Usage: make build-single CMD=cmd/intent-ingest"; \
		exit 1; \
	fi
	@if [ ! -d "$(CMD)" ]; then \
		echo "❌ Error: Directory $(CMD) does not exist"; \
		exit 1; \
	fi
	@if [ ! -f "$(CMD)/main.go" ]; then \
		echo "❌ Error: $(CMD)/main.go not found"; \
		exit 1; \
	fi
endef

# Function to retry commands with exponential backoff
define retry-command
	@attempt=1; \
	max_attempts=$(1); \
	base_delay=$(2); \
	while [ $$attempt -le $$max_attempts ]; do \
		echo "$(4) attempt $$attempt/$$max_attempts..."; \
		if $(3); then \
			echo "✅ $(4) succeeded on attempt $$attempt"; \
			break; \
		elif [ $$attempt -eq $$max_attempts ]; then \
			echo "❌ $(4) failed after $$max_attempts attempts"; \
			exit 1; \
		else \
			delay=$$((base_delay * attempt)); \
			echo "⚠️  $(4) failed, waiting $${delay}s before retry..."; \
			sleep $$delay; \
		fi; \
		attempt=$$((attempt + 1)); \
	done
endef

# Function to build a list of components sequentially
define build-component-list
	@for cmd in $(1); do \
		if [ -d "$$cmd" ] && [ -f "$$cmd/main.go" ]; then \
			echo "  Building $$cmd..."; \
			start_time=$$(date +%s); \
			timeout $(2)s go build $(ENHANCED_BUILD_FLAGS) -o $(BIN_DIR)/$$(basename $$cmd) ./$$cmd 2>/dev/null && { \
				end_time=$$(date +%s); \
				duration=$$((end_time - start_time)); \
				echo "  ✅ $$cmd completed ($${duration}s)"; \
			} || { \
				echo "  ⚠️  $$cmd build failed or timed out"; \
			}; \
		else \
			echo "  ⚠️  $$cmd: missing directory or main.go"; \
		fi \
	done
endef

# Function to build a list of components in parallel
define build-component-list-parallel
	@echo "$(1)" | tr ' ' '\n' | xargs -I {} -P $(3) -n 1 bash -c ' \
		cmd="{}"; \
		if [ -d "$$cmd" ] && [ -f "$$cmd/main.go" ]; then \
			echo "  Building $$cmd (parallel)..."; \
			start_time=$$(date +%s); \
			timeout $(2)s go build $(ENHANCED_BUILD_FLAGS) -o $(BIN_DIR)/$$(basename $$cmd) ./$$cmd 2>/dev/null && { \
				end_time=$$(date +%s); \
				duration=$$((end_time - start_time)); \
				echo "  ✅ $$cmd completed ($${duration}s)"; \
			} || { \
				echo "  ⚠️  $$cmd build failed/timeout"; \
			}; \
		else \
			echo "  ⚠️  $$cmd: missing directory or main.go"; \
		fi \
	'
endef

# Function to build components with debug output
define build-component-list-debug
	@for cmd in $(1); do \
		if [ -d "$$cmd" ] && [ -f "$$cmd/main.go" ]; then \
			echo "🐛 Building $$cmd (debug mode)..."; \
			echo "  Directory: $$cmd"; \
			echo "  Main file: $$cmd/main.go"; \
			echo "  Binary: $(BIN_DIR)/$$(basename $$cmd)"; \
			start_time=$$(date +%s); \
			timeout $(2)s go build -x -v $(ENHANCED_BUILD_FLAGS) -o $(BIN_DIR)/$$(basename $$cmd) ./$$cmd && { \
				end_time=$$(date +%s); \
				duration=$$((end_time - start_time)); \
				echo "  ✅ $$cmd completed ($${duration}s)"; \
			} || { \
				echo "  ❌ $$cmd build failed or timed out"; \
			}; \
		else \
			echo "  ⚠️  $$cmd: missing directory or main.go"; \
		fi \
	done
endef

# Function to build a single component with error handling
define build-single-component
	@if [ -d "$(1)" ] && [ -f "$(1)/main.go" ]; then \
		echo "🔨 Building: $(1)"; \
		start_time=$$(date +%s); \
		timeout $(2)s go build -x -v $(ENHANCED_BUILD_FLAGS) -o $(BIN_DIR)/$$(basename $(1)) ./$(1) && { \
			end_time=$$(date +%s); \
			duration=$$((end_time - start_time)); \
			echo "✅ $(1) built successfully ($${duration}s)"; \
			if [ -f "$(BIN_DIR)/$$(basename $(1))" ]; then \
				size=$$(ls -lh "$(BIN_DIR)/$$(basename $(1))" | awk '{print $$5}'); \
				echo "📦 Binary size: $$size"; \
			fi; \
		} || { \
			echo "❌ $(1) build failed or timed out"; \
			exit 1; \
		}; \
	else \
		echo "❌ Invalid component: $(1)"; \
		exit 1; \
	fi
endef

# Function to run security tools with error handling
define run-security-tool
	@echo "🔒 Running $(3)..."
	@if command -v $(1) >/dev/null 2>&1; then \
		$(1) $(2) 2>&1 | tee $(SECURITY_DIR)/$(3).log || { \
			echo "⚠️  $(3) found issues (check report)"; \
		}; \
	else \
		echo "⚠️  $(1) not installed - installing..."; \
		go install $(1)@latest 2>/dev/null || { \
			echo "⚠️  Failed to install $(1) - skipping"; \
			return 0; \
		}; \
		$(1) $(2) 2>&1 | tee $(SECURITY_DIR)/$(3).log || { \
			echo "⚠️  $(3) found issues (check report)"; \
		}; \
	fi
endef

# Function to generate build status report
define build-status-report
	@echo "📊 Build Status Report"
	@echo "======================"
	@echo "Build Environment:"
	@echo "  Date: $(BUILD_DATE)"
	@echo "  Commit: $(GIT_COMMIT)"
	@echo "  Branch: $(GIT_BRANCH)"
	@echo "  Version: $(VERSION)"
	@echo ""
	@if [ -d "$(BIN_DIR)" ]; then \
		binary_count=$$(ls -1 $(BIN_DIR) 2>/dev/null | wc -l || echo "0"); \
		echo "Generated Binaries ($$binary_count):"; \
		if [ $$binary_count -gt 0 ]; then \
			ls -lah $(BIN_DIR)/ | head -20; \
			total_size=$$(du -sh $(BIN_DIR) 2>/dev/null | cut -f1 || echo "unknown"); \
			echo "Total size: $$total_size"; \
		else \
			echo "  No binaries found"; \
		fi; \
	else \
		echo "Binary directory not found"; \
	fi
	@echo ""
	@echo "Component Status:"
	@for cmd in $(CRITICAL_CMDS); do \
		binary_name=$$(basename $$cmd); \
		if [ -f "$(BIN_DIR)/$$binary_name" ]; then \
			echo "  ✅ $$cmd"; \
		else \
			echo "  ❌ $$cmd (not built)"; \
		fi \
	done
endef

# Function to generate test status report
define test-status-report
	@echo ""
	@echo "Test Results:"
	@if [ -d "$(TEST_RESULTS_DIR)" ]; then \
		test_files=$$(ls -1 $(TEST_RESULTS_DIR)/*.log 2>/dev/null | wc -l || echo "0"); \
		echo "  Test result files: $$test_files"; \
		if [ -d "$(COVERAGE_DIR)" ]; then \
			coverage_files=$$(ls -1 $(COVERAGE_DIR)/*.html 2>/dev/null | wc -l || echo "0"); \
			echo "  Coverage reports: $$coverage_files"; \
		fi; \
	else \
		echo "  No test results found"; \
	fi
endef

# Function to generate dependency status report  
define dependency-status-report
	@echo ""
	@echo "Dependencies:"
	@if [ -f "go.mod" ]; then \
		mod_count=$$(grep -c "^[[:space:]]*[^[:space:]]" go.mod | head -1 || echo "0"); \
		echo "  Dependencies in go.mod: $$mod_count"; \
		if [ -f "go.sum" ]; then \
			sum_count=$$(wc -l < go.sum 2>/dev/null || echo "0"); \
			echo "  Entries in go.sum: $$sum_count"; \
		fi; \
		echo "  Module path: $$(head -1 go.mod | awk '{print $$2}')"; \
		echo "  Go version: $$(grep '^go ' go.mod | awk '{print $$2}')"; \
	else \
		echo "  No go.mod found"; \
	fi
endef