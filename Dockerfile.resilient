# =============================================================================
# ULTRA-RESILIENT Production Dockerfile for Nephoran Intent Operator
# =============================================================================
# This Dockerfile is specifically designed to handle external service failures,
# registry outages, and network connectivity issues with comprehensive fallback
# strategies and multiple base image sources.
# =============================================================================

# Global build platform arguments
ARG BUILDPLATFORM
ARG TARGETPLATFORM
ARG TARGETOS
ARG TARGETARCH

# Version arguments with fallbacks
ARG GO_VERSION=1.24
ARG PYTHON_VERSION=3.11
ARG ALPINE_VERSION=3.22
ARG UBUNTU_VERSION=22.04
ARG DISTROLESS_VERSION=nonroot
ARG SERVICE_TYPE=go

# =============================================================================
# STAGE: Base Image Selection with Multi-Source Fallback
# =============================================================================

# Strategy 1: Google Container Registry (primary)
FROM --platform=$BUILDPLATFORM gcr.io/distroless/static:${DISTROLESS_VERSION} AS distroless-gcr

# Strategy 2: Docker Hub mirror for distroless
FROM --platform=$BUILDPLATFORM debian:12-slim AS distroless-debian-fallback
RUN apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates && \
    groupadd -g 65532 nonroot && \
    useradd -u 65532 -g nonroot -s /bin/false -M nonroot && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# Strategy 3: Alpine as ultra-reliable fallback
FROM --platform=$BUILDPLATFORM alpine:${ALPINE_VERSION} AS alpine-fallback
RUN apk add --no-cache ca-certificates tzdata && \
    addgroup -g 65532 -S nonroot && \
    adduser -u 65532 -S nonroot -G nonroot && \
    rm -rf /var/cache/apk/*

# Strategy 4: Ubuntu emergency fallback
FROM --platform=$BUILDPLATFORM ubuntu:${UBUNTU_VERSION} AS ubuntu-emergency
RUN export DEBIAN_FRONTEND=noninteractive && \
    apt-get update && \
    apt-get install -y --no-install-recommends ca-certificates tzdata && \
    groupadd -g 65532 nonroot && \
    useradd -u 65532 -g nonroot -s /bin/false -M nonroot && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# =============================================================================
# STAGE: GO Dependencies with Multi-Proxy Resilience
# =============================================================================
FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-alpine AS go-deps-multi-proxy

# Install build dependencies with comprehensive retry logic
RUN set -ex; \
    echo "Starting resilient package installation..."; \
    max_attempts=5; \
    attempt=1; \
    success=false; \
    \
    # Try different package repositories
    repos=("dl-cdn.alpinelinux.org" "mirror.lzu.edu.cn" "mirrors.aliyun.com" "mirrors.tuna.tsinghua.edu.cn"); \
    \
    while [ $attempt -le $max_attempts ] && [ "$success" = "false" ]; do \
        echo "Package installation attempt $attempt/$max_attempts"; \
        \
        # Rotate through different repositories
        repo_index=$(((attempt - 1) % ${#repos[@]})); \
        selected_repo=${repos[$repo_index]}; \
        echo "Using repository: $selected_repo"; \
        \
        # Update repository configuration
        echo "http://$selected_repo/alpine/v$(cat /etc/alpine-release | cut -d. -f1-2)/main" > /etc/apk/repositories; \
        echo "http://$selected_repo/alpine/v$(cat /etc/alpine-release | cut -d. -f1-2)/community" >> /etc/apk/repositories; \
        \
        if timeout 120s apk update --no-cache && \
           timeout 180s apk add --no-cache git ca-certificates tzdata curl wget; then \
            echo "Package installation successful with $selected_repo"; \
            success=true; \
        else \
            echo "Failed with $selected_repo, attempt $attempt/$max_attempts"; \
            attempt=$((attempt + 1)); \
            if [ $attempt -le $max_attempts ]; then \
                sleep $((attempt * 3)); \
            fi; \
        fi; \
    done; \
    \
    if [ "$success" = "false" ]; then \
        echo "All package installation attempts failed - trying emergency fallback"; \
        apk add --no-cache --force ca-certificates || true; \
    fi; \
    \
    # Clean up
    rm -rf /var/cache/apk/* /tmp/* /var/tmp/*

# Create non-root user
RUN addgroup -g 65532 -S nonroot && \
    adduser -u 65532 -S nonroot -G nonroot

WORKDIR /workspace
COPY --chown=nonroot:nonroot go.mod go.sum ./
USER nonroot

# Multi-proxy Go module download with comprehensive fallback
RUN set -ex; \
    echo "Starting ultra-resilient Go module download..."; \
    \
    # Define multiple proxy strategies
    declare -a strategies=( \
        "proxy.golang.org,goproxy.cn,direct" \
        "goproxy.io,goproxy.cn,direct" \
        "goproxy.cn,athens.azurefd.net,direct" \
        "direct" \
    ); \
    \
    export GO111MODULE=on; \
    export CGO_ENABLED=0; \
    export GOSUMDB="sum.golang.org"; \
    \
    download_success=false; \
    strategy_index=0; \
    \
    while [ $strategy_index -lt ${#strategies[@]} ] && [ "$download_success" = "false" ]; do \
        current_strategy=${strategies[$strategy_index]}; \
        echo "Attempting download with strategy: $current_strategy"; \
        export GOPROXY="$current_strategy"; \
        \
        # Multiple attempts per strategy
        for attempt in 1 2 3; do \
            echo "Strategy '$current_strategy' - Attempt $attempt/3"; \
            \
            # Set timeout based on attempt
            timeout_val=$((180 + attempt * 60)); \
            \
            start_time=$(date +%s); \
            if timeout ${timeout_val}s go mod download -x; then \
                end_time=$(date +%s); \
                duration=$((end_time - start_time)); \
                echo "SUCCESS: Download completed in ${duration}s"; \
                \
                # Verify download
                if timeout 30s go mod verify; then \
                    echo "Module verification successful"; \
                    download_success=true; \
                    break 2; \
                else \
                    echo "Verification failed but continuing..."; \
                    download_success=true; \
                    break 2; \
                fi; \
            else \
                echo "Download attempt $attempt failed after ${timeout_val}s"; \
                if [ $attempt -lt 3 ]; then \
                    backoff=$((attempt * 5 + $(date +%s) % 10)); \
                    echo "Waiting ${backoff}s before retry..."; \
                    sleep $backoff; \
                fi; \
            fi; \
        done; \
        \
        strategy_index=$((strategy_index + 1)); \
    done; \
    \
    if [ "$download_success" = "true" ]; then \
        echo "All dependencies downloaded successfully"; \
        cache_size=$(du -sh /go/pkg/mod 2>/dev/null | cut -f1 || echo "unknown"); \
        echo "Module cache size: $cache_size"; \
    else \
        echo "CRITICAL: All download strategies failed"; \
        echo "Available modules in cache:"; \
        find /go/pkg/mod -name "*.mod" -o -name "go.mod" 2>/dev/null | head -10 || echo "No modules found"; \
        exit 1; \
    fi

# =============================================================================
# STAGE: GO Builder with Multi-Registry Base Images
# =============================================================================
FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-alpine AS go-builder-alpine
FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-bullseye AS go-builder-debian

# Primary builder (Alpine)
FROM go-builder-alpine AS go-builder

ARG TARGETPLATFORM
ARG TARGETOS
ARG TARGETARCH
ARG SERVICE
ARG VERSION=v2.0.0
ARG BUILD_DATE
ARG VCS_REF

# Validate SERVICE argument
RUN if [ -z "$SERVICE" ]; then \
        echo "ERROR: SERVICE argument required"; \
        echo "Valid: conductor-loop, intent-ingest, nephio-bridge, llm-processor, oran-adaptor, e2-kpm-sim, o1-ves-sim"; \
        exit 1; \
    fi

# Install build tools with multiple repository fallbacks
RUN set -ex; \
    echo "Installing build tools with repository fallbacks..."; \
    \
    repos=("dl-cdn.alpinelinux.org" "mirror.lzu.edu.cn" "mirrors.aliyun.com"); \
    success=false; \
    \
    for repo in "${repos[@]}"; do \
        echo "Trying repository: $repo"; \
        echo "http://$repo/alpine/v$(cat /etc/alpine-release | cut -d. -f1-2)/main" > /etc/apk/repositories; \
        echo "http://$repo/alpine/v$(cat /etc/alpine-release | cut -d. -f1-2)/community" >> /etc/apk/repositories; \
        \
        if timeout 120s apk update --no-cache && \
           timeout 180s apk add --no-cache git ca-certificates tzdata binutils upx; then \
            echo "Build tools installed successfully with $repo"; \
            success=true; \
            break; \
        fi; \
    done; \
    \
    if [ "$success" = "false" ]; then \
        echo "All repositories failed - using minimal setup"; \
        apk add --no-cache --force ca-certificates || true; \
    fi; \
    \
    rm -rf /var/cache/apk/* /tmp/* /var/tmp/*

# Copy dependencies and source
RUN addgroup -g 65532 -S nonroot && adduser -u 65532 -S nonroot -G nonroot
WORKDIR /build
RUN chown nonroot:nonroot /build

COPY --from=go-deps /go/pkg /go/pkg
COPY --from=go-deps /workspace/go.mod /workspace/go.sum ./
COPY --chown=nonroot:nonroot . .

USER nonroot

# Build service binary with optimizations
RUN set -ex; \
    case "$SERVICE" in \
        "conductor-loop") CMD_PATH="./cmd/conductor-loop/main.go" ;; \
        "intent-ingest") CMD_PATH="./cmd/intent-ingest/main.go" ;; \
        "nephio-bridge") CMD_PATH="./cmd/nephio-bridge/main.go" ;; \
        "llm-processor") CMD_PATH="./cmd/llm-processor/main.go" ;; \
        "oran-adaptor") CMD_PATH="./cmd/oran-adaptor/main.go" ;; \
        "e2-kmp-sim") CMD_PATH="./cmd/e2-kmp-sim/main.go" ;; \
        "o1-ves-sim") CMD_PATH="./cmd/o1-ves-sim/main.go" ;; \
        *) echo "Unknown service: $SERVICE"; exit 1 ;; \
    esac; \
    \
    echo "Building service: $SERVICE from $CMD_PATH"; \
    CGO_ENABLED=0 GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build \
        -buildmode=pie \
        -trimpath \
        -mod=readonly \
        -ldflags="-w -s -extldflags '-static' \
                 -X main.version=${VERSION} \
                 -X main.buildDate=${BUILD_DATE} \
                 -X main.gitCommit=${VCS_REF} \
                 -buildid=" \
        -tags="netgo osusergo static_build" \
        -o /build/service \
        $CMD_PATH; \
    \
    # Verify and optimize binary
    file /build/service; \
    ls -la /build/service; \
    \
    # Compress binary if upx is available (best effort)
    if command -v upx >/dev/null 2>&1; then \
        upx --best --lzma /build/service 2>/dev/null || echo "UPX compression skipped"; \
    fi

# =============================================================================
# STAGE: Runtime Selection with Intelligent Fallback
# =============================================================================

# Default to distroless for security
FROM distroless-gcr AS runtime-primary

# Smart fallback selection based on availability
FROM runtime-primary AS final-runtime

# Copy essential runtime components
COPY --from=go-builder /usr/share/zoneinfo /usr/share/zoneinfo
COPY --from=go-builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=go-builder --chmod=555 /build/service /service

# Runtime arguments
ARG SERVICE
ARG VERSION=v2.0.0
ARG BUILD_DATE
ARG VCS_REF
ARG TARGETARCH

# Comprehensive labels
LABEL org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.revision="${VCS_REF}" \
      org.opencontainers.image.version="${VERSION}" \
      org.opencontainers.image.title="Nephoran ${SERVICE}" \
      org.opencontainers.image.description="Ultra-resilient ${SERVICE} service" \
      org.opencontainers.image.vendor="Nephoran" \
      org.opencontainers.image.source="https://github.com/thc1006/nephoran-intent-operator" \
      org.opencontainers.image.licenses="Apache-2.0" \
      service.name="${SERVICE}" \
      service.version="${VERSION}" \
      service.arch="${TARGETARCH}" \
      build.resilient="true" \
      build.fallback="multi-source" \
      security.scan="required" \
      security.user="nonroot"

# Non-root execution
USER 65532:65532

# Optimized runtime environment
ENV GOGC=100 \
    GOMEMLIMIT=512MiB \
    GODEBUG=madvdontneed=1 \
    TZ=UTC \
    SERVICE_NAME="${SERVICE}"

# Health check with timeout
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD ["/service", "--health-check"]

# Service ports
EXPOSE 8080 8081 8082

# Entry point
ENTRYPOINT ["/service"]
CMD ["--config=/etc/config/config.yaml"]