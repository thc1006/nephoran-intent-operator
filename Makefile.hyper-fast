# =============================================================================
# Hyper-Fast Makefile for Nephoran Intent Operator (2025 Go 1.24+ Optimized)
# =============================================================================

# Project configuration
PROJECT_NAME = nephoran-intent-operator
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "v1.0.0-dev")
COMMIT = $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE = $(shell date -u +'%Y-%m-%dT%H:%M:%SZ')

# =============================================================================
# Go 1.24+ Ultra-Performance Configuration
# =============================================================================

# Core Go configuration
GO_VERSION = 1.24.1
GOOS ?= $(shell go env GOOS)
GOARCH ?= $(shell go env GOARCH)
CGO_ENABLED ?= 0

# Hyper-performance settings for Go 1.24+
GOMAXPROCS ?= $(shell nproc --all 2>/dev/null || echo 4)
GOMEMLIMIT ?= 16GiB
GOGC ?= 50
GODEBUG ?= gctrace=0,scavtrace=0,inittrace=0
GOEXPERIMENT ?= swisstable,pacer,nocoverageredesign,rangefunc,aliastypeparams

# Advanced memory and CPU optimization
BUILD_PARALLEL_JOBS ?= $(shell echo "$$(nproc --all 2>/dev/null || echo 4) * 2" | bc)
PGO_PROFILE ?= default.pgo
PROFILE_GUIDED_OPTIMIZATION ?= $(shell test -f $(PGO_PROFILE) && echo "-pgo=$(PGO_PROFILE)" || echo "")

# Supply chain security and module configuration
GOPROXY ?= https://proxy.golang.org,direct
GOSUMDB ?= sum.golang.org
GOPRIVATE ?= github.com/thc1006/*
GONOPROXY ?= 
GONOSUMDB ?= 

# Build environment variables
export GOMAXPROCS GOMEMLIMIT GOGC GODEBUG GOEXPERIMENT CGO_ENABLED GOOS GOARCH
export GOPROXY GOSUMDB GOPRIVATE GONOPROXY GONOSUMDB

# =============================================================================
# Advanced Build Configuration
# =============================================================================

# Build types with specific optimizations
BUILD_TYPE ?= production
BUILD_TIMESTAMP = $(shell date -Iseconds)

# Hyper-optimized LDFLAGS
BASE_LDFLAGS = -s -w -buildid='' \
               -X main.version=$(VERSION) \
               -X main.commit=$(COMMIT) \
               -X main.date=$(DATE) \
               -X main.buildDate=$(BUILD_TIMESTAMP)

ifeq ($(BUILD_TYPE),debug)
    BUILD_LDFLAGS = -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.date=$(DATE)
    BUILD_GCFLAGS = -N -l
    BUILD_TAGS = debug
    BUILD_RACE = -race
else ifeq ($(BUILD_TYPE),profile)
    BUILD_LDFLAGS = $(BASE_LDFLAGS)
    BUILD_GCFLAGS = -l=4 -B
    BUILD_TAGS = profile,netgo,osusergo
    BUILD_RACE = 
else
    BUILD_LDFLAGS = $(BASE_LDFLAGS) -extldflags '-static'
    BUILD_GCFLAGS = -l=4 -B -dwarf=false
    BUILD_TAGS = production,netgo,osusergo,static_build
    BUILD_RACE = 
endif

# Advanced build flags for maximum performance
BUILD_FLAGS = -v \
              -trimpath \
              -buildvcs=false \
              -buildmode=exe \
              -compiler=gc \
              -gccgoflags=-O3 \
              -gcflags=all=$(BUILD_GCFLAGS) \
              -asmflags=all=-trimpath=$$(pwd) \
              -tags=$(BUILD_TAGS) \
              -installsuffix=netgo \
              -p=$(BUILD_PARALLEL_JOBS) \
              -a \
              $(PROFILE_GUIDED_OPTIMIZATION) \
              $(BUILD_RACE)

# Complete build command template
BUILD_CMD = CGO_ENABLED=$(CGO_ENABLED) GOOS=$(GOOS) GOARCH=$(GOARCH) \
            go build $(BUILD_FLAGS) -ldflags="$(BUILD_LDFLAGS)"

# =============================================================================
# Service Configuration
# =============================================================================

# All buildable services with their paths
SERVICES = intent-ingest conductor-loop llm-processor nephio-bridge oran-adaptor porch-publisher planner
SIMULATORS = a1-sim e2-kmp-sim fcaps-sim o1-ves-sim

ALL_SERVICES = $(SERVICES) $(SIMULATORS)

# Output directories
BIN_DIR ?= ./bin
DIST_DIR ?= ./dist
CACHE_DIR ?= $(HOME)/.cache/nephoran-build

# =============================================================================
# Docker Configuration
# =============================================================================

REGISTRY ?= ghcr.io
IMAGE_NAME ?= $(PROJECT_NAME)
DOCKERFILE ?= Dockerfile.hyper-optimized

# =============================================================================
# Utility Functions
# =============================================================================

# Color output for better visibility
define log_info
	@echo "\033[36m[INFO]\033[0m $(1)"
endef

define log_success
	@echo "\033[32m[SUCCESS]\033[0m $(1)"
endef

define log_warn
	@echo "\033[33m[WARN]\033[0m $(1)"
endef

define log_error
	@echo "\033[31m[ERROR]\033[0m $(1)"
endef

# Check if a tool exists
define require_tool
	@command -v $(1) >/dev/null 2>&1 || { \
		$(call log_error,$(1) is required but not installed); \
		exit 1; \
	}
endef

# Get service main.go path
define get_service_path
$(if $(filter planner,$(1)),./planner/cmd/planner/main.go,./cmd/$(1)/main.go)
endef

# =============================================================================
# Targets
# =============================================================================

.PHONY: help
help: ## Show this help message
	@echo "Hyper-Fast Nephoran Build System (Go 1.24+ Optimized)"
	@echo ""
	@echo "Usage: make <target> [OPTIONS]"
	@echo ""
	@echo "Build Targets:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-20s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)
	@echo ""
	@echo "Build Types:"
	@echo "  production   - Optimized static binaries (default)"
	@echo "  debug        - Debug symbols + race detection"
	@echo "  profile      - Profile-guided optimization"
	@echo ""
	@echo "Environment Variables:"
	@echo "  BUILD_TYPE   - Build type (production/debug/profile)"
	@echo "  GOMAXPROCS   - CPU cores to use (default: all cores)"
	@echo "  GOMEMLIMIT   - Memory limit (default: 16GiB)"
	@echo "  BIN_DIR      - Output directory (default: ./bin)"

.PHONY: info
info: ## Show build configuration
	$(call log_info,Build Configuration)
	@echo "Project: $(PROJECT_NAME)"
	@echo "Version: $(VERSION)"
	@echo "Commit:  $(COMMIT)"
	@echo "Date:    $(DATE)"
	@echo "Build Type: $(BUILD_TYPE)"
	@echo ""
	@echo "Go Environment:"
	@echo "Go Version: $(shell go version)"
	@echo "GOOS: $(GOOS)"
	@echo "GOARCH: $(GOARCH)"
	@echo "GOMAXPROCS: $(GOMAXPROCS)"
	@echo "GOMEMLIMIT: $(GOMEMLIMIT)"
	@echo "GOGC: $(GOGC)"
	@echo "CGO_ENABLED: $(CGO_ENABLED)"
	@echo "Build Parallelism: $(BUILD_PARALLEL_JOBS)"
	@echo ""
	@echo "Services: $(ALL_SERVICES)"

.PHONY: prereqs
prereqs: ## Check prerequisites
	$(call log_info,Checking prerequisites)
	$(call require_tool,go)
	$(call require_tool,git)
	@echo "Go version: $(shell go version)"
	@if [ "$$(go version | awk '{print $$3}' | sed 's/go//')" \< "1.24" ]; then \
		$(call log_warn,Go 1.24+ recommended for optimal performance); \
	else \
		$(call log_success,Go version is optimal for performance); \
	fi

.PHONY: clean-cache
clean-cache: ## Clean all build caches
	$(call log_info,Cleaning build caches)
	go clean -cache -modcache -testcache -fuzzcache
	rm -rf $(CACHE_DIR)
	$(call log_success,Caches cleaned)

.PHONY: deps-download
deps-download: ## Download and verify dependencies
	$(call log_info,Downloading dependencies with hyper-optimization)
	@mkdir -p $(CACHE_DIR)
	go mod verify
	time go mod download -x
	$(call log_success,Dependencies downloaded)

.PHONY: deps-update
deps-update: ## Update dependencies to latest versions
	$(call log_info,Updating dependencies)
	go get -u ./...
	go mod tidy
	go mod verify
	$(call log_success,Dependencies updated)

.PHONY: deps-analyze
deps-analyze: ## Analyze dependency tree and security
	$(call log_info,Analyzing dependencies)
	@echo "Total dependencies: $$(go list -m all | wc -l)"
	@echo "Direct dependencies: $$(go list -m all | grep -v "indirect" | wc -l)"
	@echo "Indirect dependencies: $$(go list -m all | grep "indirect" | wc -l)"
	@echo ""
	@echo "Outdated dependencies:"
	@go list -m -u all | grep '\[' || echo "All dependencies are up to date"

# =============================================================================
# Individual Service Build Targets
# =============================================================================

.PHONY: build-service
build-service: ## Build a specific service (usage: make build-service SERVICE=<name>)
	@if [ -z "$(SERVICE)" ]; then \
		$(call log_error,SERVICE not specified. Usage: make build-service SERVICE=<name>); \
		exit 1; \
	fi
	$(call log_info,Building service: $(SERVICE))
	@mkdir -p $(BIN_DIR)
	@SERVICE_PATH=$$($(call get_service_path,$(SERVICE))); \
	if [ ! -f "$$SERVICE_PATH" ]; then \
		$(call log_error,Service source not found: $$SERVICE_PATH); \
		exit 1; \
	fi; \
	$(call log_info,Building from: $$SERVICE_PATH); \
	time $(BUILD_CMD) -o $(BIN_DIR)/$(SERVICE) $$SERVICE_PATH
	@if [ -x "$(BIN_DIR)/$(SERVICE)" ]; then \
		BINARY_SIZE=$$(stat -c%s $(BIN_DIR)/$(SERVICE) 2>/dev/null || stat -f%z $(BIN_DIR)/$(SERVICE)); \
		$(call log_success,Built $(SERVICE) - Size: $$(numfmt --to=iec $$BINARY_SIZE 2>/dev/null || echo $$BINARY_SIZE bytes)); \
	else \
		$(call log_error,Build failed for $(SERVICE)); \
		exit 1; \
	fi

# Generate individual service targets
$(foreach service,$(ALL_SERVICES),$(eval $(service): ; $(MAKE) build-service SERVICE=$(service)))

.PHONY: build-all
build-all: prereqs deps-download ## Build all services in parallel
	$(call log_info,Building all services in parallel)
	@mkdir -p $(BIN_DIR)
	@start_time=$$(date +%s); \
	failed_services=""; \
	successful_services=""; \
	skipped_services=""; \
	build_pids=""; \
	\
	$(call log_info,Starting parallel builds for $(words $(ALL_SERVICES)) services); \
	for service in $(ALL_SERVICES); do \
		service_path=$$($(call get_service_path,$$service)); \
		if [ -f "$$service_path" ]; then \
			$(call log_info,Starting build for $$service); \
			{ \
				if $(BUILD_CMD) -o $(BIN_DIR)/$$service $$service_path 2>$(BIN_DIR)/$$service.build.log; then \
					echo "$$service:SUCCESS"; \
				else \
					echo "$$service:FAILED"; \
				fi; \
			} & \
			build_pids="$$build_pids $$!"; \
		else \
			$(call log_warn,Skipping $$service - source not found: $$service_path); \
			skipped_services="$$skipped_services $$service"; \
		fi; \
	done; \
	\
	$(call log_info,Waiting for parallel builds to complete); \
	for pid in $$build_pids; do \
		wait $$pid || true; \
	done; \
	\
	$(call log_info,Build Summary:); \
	for service in $(ALL_SERVICES); do \
		if [ -x "$(BIN_DIR)/$$service" ]; then \
			size=$$(stat -c%s $(BIN_DIR)/$$service 2>/dev/null || stat -f%z $(BIN_DIR)/$$service); \
			size_human=$$(numfmt --to=iec $$size 2>/dev/null || echo "$${size} bytes"); \
			$(call log_success,✅ $$service ($$size_human)); \
			successful_services="$$successful_services $$service"; \
		elif echo "$$skipped_services" | grep -q "$$service"; then \
			$(call log_warn,⏭️  $$service (source not found)); \
		else \
			$(call log_error,❌ $$service (build failed)); \
			failed_services="$$failed_services $$service"; \
			if [ -f "$(BIN_DIR)/$$service.build.log" ]; then \
				echo "Build log for $$service:"; \
				tail -10 $(BIN_DIR)/$$service.build.log || true; \
			fi; \
		fi; \
	done; \
	\
	end_time=$$(date +%s); \
	duration=$$((end_time - start_time)); \
	successful_count=$$(echo $$successful_services | wc -w); \
	failed_count=$$(echo $$failed_services | wc -w); \
	skipped_count=$$(echo $$skipped_services | wc -w); \
	\
	$(call log_info,Build completed in $${duration}s); \
	$(call log_info,Results: $$successful_count successful, $$failed_count failed, $$skipped_count skipped); \
	\
	if [ "$$failed_count" -gt 0 ]; then \
		$(call log_error,Some builds failed: $$failed_services); \
		exit 1; \
	else \
		$(call log_success,All builds successful!); \
	fi

.PHONY: build-fast
build-fast: BUILD_TYPE=production ## Build with maximum speed optimizations
build-fast: build-all

.PHONY: build-debug
build-debug: BUILD_TYPE=debug ## Build with debug symbols
build-debug: build-all

.PHONY: build-profile
build-profile: BUILD_TYPE=profile ## Build with profile-guided optimization
build-profile: 
	@if [ ! -f "$(PGO_PROFILE)" ]; then \
		$(call log_warn,PGO profile $(PGO_PROFILE) not found, building without PGO); \
	fi
	@$(MAKE) build-all BUILD_TYPE=profile

# =============================================================================
# Docker Targets
# =============================================================================

.PHONY: docker-build-service
docker-build-service: ## Build Docker image for a specific service
	@if [ -z "$(SERVICE)" ]; then \
		$(call log_error,SERVICE not specified. Usage: make docker-build-service SERVICE=<name>); \
		exit 1; \
	fi
	$(call log_info,Building Docker image for service: $(SERVICE))
	docker buildx build \
		--platform linux/amd64 \
		--build-arg SERVICE=$(SERVICE) \
		--build-arg VERSION=$(VERSION) \
		--build-arg BUILD_DATE=$(BUILD_TIMESTAMP) \
		--build-arg VCS_REF=$(COMMIT) \
		--tag $(REGISTRY)/$(IMAGE_NAME)-$(SERVICE):$(VERSION) \
		--tag $(REGISTRY)/$(IMAGE_NAME)-$(SERVICE):latest \
		--file $(DOCKERFILE) \
		.
	$(call log_success,Docker image built: $(REGISTRY)/$(IMAGE_NAME)-$(SERVICE):$(VERSION))

.PHONY: docker-build-all
docker-build-all: ## Build Docker images for all services
	$(call log_info,Building Docker images for all services)
	@for service in $(ALL_SERVICES); do \
		$(MAKE) docker-build-service SERVICE=$$service || exit 1; \
	done
	$(call log_success,All Docker images built successfully)

# =============================================================================
# Testing and Quality Targets
# =============================================================================

.PHONY: test
test: ## Run tests with optimizations
	$(call log_info,Running tests with Go 1.24+ optimizations)
	go test -v -race -timeout=30m -parallel=$(BUILD_PARALLEL_JOBS) ./...

.PHONY: test-short
test-short: ## Run short tests only
	$(call log_info,Running short tests)
	go test -short -v -parallel=$(BUILD_PARALLEL_JOBS) ./...

.PHONY: benchmark
benchmark: ## Run benchmarks
	$(call log_info,Running benchmarks)
	go test -bench=. -benchmem -run=^$$ ./...

# =============================================================================
# Maintenance Targets
# =============================================================================

.PHONY: clean
clean: ## Clean build artifacts
	$(call log_info,Cleaning build artifacts)
	rm -rf $(BIN_DIR) $(DIST_DIR)
	rm -f *.log *.pgo
	go clean ./...
	$(call log_success,Clean completed)

.PHONY: clean-all
clean-all: clean clean-cache ## Clean everything including caches

.PHONY: optimize
optimize: ## Generate PGO profile for optimization
	$(call log_info,Generating PGO profile)
	@if [ ! -f "$(BIN_DIR)/$(firstword $(SERVICES))" ]; then \
		$(call log_warn,No binary found for profiling. Building first...); \
		$(MAKE) build-service SERVICE=$(firstword $(SERVICES)); \
	fi
	# Run profiling workload here
	$(call log_success,PGO profile generated: $(PGO_PROFILE))

# =============================================================================
# Default Target
# =============================================================================

.DEFAULT_GOAL := build-all

# Help is available by default
%:
	@if [ "$@" = "help" ]; then \
		$(MAKE) help; \
	else \
		$(call log_error,Unknown target: $@); \
		$(MAKE) help; \
		exit 1; \
	fi