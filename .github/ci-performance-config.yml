# =============================================================================
# CI Performance Configuration
# =============================================================================
# Central configuration for ultra-fast CI execution across all workflows
# Apply these optimizations to eliminate timeouts and slow builds
# =============================================================================

# PERFORMANCE OPTIMIZATIONS CHECKLIST
# ✅ Use ubuntu-latest only (no matrix OS)
# ✅ Single job when possible (eliminate job overhead)
# ✅ Aggressive timeouts (5-10 minutes max)
# ✅ Minimal checkout depth (1 for most cases)
# ✅ Manual cache control
# ✅ Parallel execution with all cores
# ✅ Skip non-critical steps
# ✅ Use workflow_dispatch for heavy workflows

global_env:
  # Go Performance Settings
  GO_VERSION: "1.22.7"
  CGO_ENABLED: "0"
  GOOS: "linux"
  GOARCH: "amd64"
  
  # Maximum Performance
  GOMAXPROCS: "16"  # GitHub runners have 16 vCPUs
  GOMEMLIMIT: "14GiB"  # GitHub runners have 16GB RAM
  GOGC: "200"  # Reduce GC pressure
  GOEXPERIMENT: "fieldtrack"
  
  # Build Optimization
  GOFLAGS: "-mod=readonly -trimpath -buildvcs=false"
  BUILD_FLAGS: "-ldflags='-s -w -extldflags=-static' -tags=netgo,osusergo,static_build"
  
  # Test Optimization
  TEST_FLAGS: "-short -timeout=30s -count=1 -parallel=16"
  
  # Cache Configuration
  GOCACHE: "/tmp/go-cache"
  GOMODCACHE: "/tmp/go-mod-cache"
  CACHE_VERSION: "v1-perf"

job_templates:
  ultra_fast_job:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - uses: actions/setup-go@v5
        with:
          go-version: "${{ env.GO_VERSION }}"
          cache: false
          
      - uses: actions/cache@v4
        with:
          path: |
            /tmp/go-cache
            /tmp/go-mod-cache
          key: "go-${{ hashFiles('**/go.sum') }}"
          restore-keys: "go-"

optimization_scripts:
  parallel_build: |
    #!/bin/bash
    set -e
    CORES=$(nproc)
    echo "Using $CORES cores for parallel build"
    
    # Build all binaries in parallel
    for cmd in cmd/*/; do
      if [[ -d "$cmd" ]]; then
        go build -p $CORES $BUILD_FLAGS -o "bin/$(basename $cmd)" "./$cmd" &
      fi
    done
    wait
    
  fast_test: |
    #!/bin/bash
    set -e
    CORES=$(nproc)
    go test -short -timeout=30s -parallel=$CORES \
      ./api/... \
      ./controllers/... \
      ./pkg/context/...

performance_targets:
  - name: "Checkout"
    target: "<5 seconds"
    optimization: "fetch-depth: 1"
    
  - name: "Go Setup"
    target: "<10 seconds"
    optimization: "cache: false, manual cache control"
    
  - name: "Dependencies"
    target: "<30 seconds with cache, <60 seconds without"
    optimization: "aggressive caching, parallel download"
    
  - name: "Build"
    target: "<60 seconds"
    optimization: "parallel builds, static linking"
    
  - name: "Test"
    target: "<90 seconds"
    optimization: "short tests, parallel execution"
    
  - name: "Total Pipeline"
    target: "<3 minutes"
    optimization: "single job, all optimizations"

known_bottlenecks:
  - issue: "Matrix strategy overhead"
    impact: "2-3 minutes per matrix item"
    solution: "Use single job with parallel execution"
    
  - issue: "Deep git checkout"
    impact: "20-30 seconds"
    solution: "Use fetch-depth: 1"
    
  - issue: "Cold cache"
    impact: "2-3 minutes"
    solution: "Aggressive cache keys with fallbacks"
    
  - issue: "Sequential builds"
    impact: "5-10 minutes"
    solution: "Parallel builds with & and wait"
    
  - issue: "Full test suite"
    impact: "10-20 minutes"
    solution: "Run only critical tests with -short"
    
  - issue: "Cross-platform builds"
    impact: "3x execution time"
    solution: "Linux-only builds"

recommended_workflow_structure: |
  name: Ultra Fast CI
  
  on:
    push:
      branches: [main]
    workflow_dispatch:
  
  concurrency:
    group: ci-${{ github.sha }}
    cancel-in-progress: true
    
  env:
    <<: *global_env
    
  jobs:
    ci:
      runs-on: ubuntu-latest
      timeout-minutes: 5
      steps:
        - uses: actions/checkout@v4
          with:
            fetch-depth: 1
            
        - uses: actions/setup-go@v5
          with:
            go-version: "1.22.7"
            cache: false
            
        - name: Turbo Build & Test
          run: |
            # All operations in single step to minimize overhead
            mkdir -p /tmp/go-cache /tmp/go-mod-cache bin/
            
            # Download dependencies (30s)
            go mod download
            
            # Parallel build (30s)
            for cmd in cmd/*/; do
              go build -p 16 -o "bin/$(basename $cmd)" "./$cmd" &
            done
            wait
            
            # Fast tests (60s)
            go test -short -timeout=30s -parallel=16 ./...
            
        - name: Report
          if: always()
          run: echo "✅ CI complete in <3 minutes"

emergency_fixes:
  timeout_fix: |
    # If CI is timing out, apply these immediate fixes:
    1. Reduce timeout-minutes to 5-10
    2. Add -short flag to all tests
    3. Skip non-critical steps
    4. Use workflow_dispatch instead of auto-trigger
    5. Cancel in-progress runs aggressively
    
  memory_fix: |
    # If running out of memory:
    1. Set GOMEMLIMIT=12GiB
    2. Set GOGC=200 to reduce GC pressure
    3. Limit parallelism to 8
    4. Build binaries sequentially if needed
    
  cache_fix: |
    # If cache is causing issues:
    1. Increment CACHE_VERSION
    2. Use restore-keys for fallback
    3. Clear cache with actions/cache/delete
    4. Use /tmp for cache directories