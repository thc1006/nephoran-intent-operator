# =============================================================================
# TIMEOUT MANAGEMENT SYSTEM - NEPHORAN INTENT OPERATOR  
# =============================================================================
# Purpose: Comprehensive timeout handling and workflow orchestration
# Features: Adaptive timeouts, graceful cancellation, resource cleanup
# Last Updated: 2025-09-03
# =============================================================================

name: Timeout Management System

on:
  workflow_call:
    inputs:
      operation_type:
        description: 'Type of operation (build, test, scan, deploy)'
        type: string
        required: true
      complexity_level:
        description: 'Complexity level (simple, standard, complex)'
        type: string
        default: 'standard'
        required: false
      resource_tier:
        description: 'Resource tier (small, medium, large)'
        type: string
        default: 'medium'
        required: false
    outputs:
      timeout_minutes:
        description: 'Calculated timeout in minutes'
        value: ${{ jobs.timeout-calculator.outputs.timeout-minutes }}
      cleanup_required:
        description: 'Whether cleanup is required'
        value: ${{ jobs.timeout-calculator.outputs.cleanup-required }}
        
  workflow_dispatch:
    inputs:
      operation_type:
        description: 'Type of operation'
        type: choice
        options: ['build', 'test', 'scan', 'deploy', 'custom']
        default: 'scan'
      complexity_level:
        description: 'Complexity level'
        type: choice
        options: ['simple', 'standard', 'complex', 'enterprise']
        default: 'standard'
      resource_tier:
        description: 'Resource tier'
        type: choice
        options: ['small', 'medium', 'large', 'xlarge']
        default: 'medium'

env:
  # Base timeout configurations (in minutes)
  BASE_TIMEOUT_BUILD: "20"
  BASE_TIMEOUT_TEST: "30"
  BASE_TIMEOUT_SCAN: "25"
  BASE_TIMEOUT_DEPLOY: "15"
  BASE_TIMEOUT_CUSTOM: "10"
  
  # Complexity multipliers
  MULTIPLIER_SIMPLE: "0.7"
  MULTIPLIER_STANDARD: "1.0"
  MULTIPLIER_COMPLEX: "1.5"
  MULTIPLIER_ENTERPRISE: "2.0"
  
  # Resource tier multipliers
  MULTIPLIER_SMALL: "0.8"
  MULTIPLIER_MEDIUM: "1.0"
  MULTIPLIER_LARGE: "1.2"
  MULTIPLIER_XLARGE: "1.5"

jobs:
  timeout-calculator:
    name: ??Timeout Calculator
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      timeout-minutes: ${{ steps.calculate.outputs.timeout-minutes }}
      cleanup-required: ${{ steps.calculate.outputs.cleanup-required }}
      timeout-strategy: ${{ steps.calculate.outputs.timeout-strategy }}
      
    steps:
      - name: ?”§ Calculate adaptive timeout
        id: calculate
        run: |
          echo "??Calculating adaptive timeout for operation..."
          
          operation_type="${{ inputs.operation_type }}"
          complexity_level="${{ inputs.complexity_level || 'standard' }}"
          resource_tier="${{ inputs.resource_tier || 'medium' }}"
          
          echo "?? Input Parameters:"
          echo "  - Operation: $operation_type"
          echo "  - Complexity: $complexity_level"
          echo "  - Resources: $resource_tier"
          
          # Get base timeout
          case "$operation_type" in
            "build")
              base_timeout=${{ env.BASE_TIMEOUT_BUILD }}
              ;;
            "test")
              base_timeout=${{ env.BASE_TIMEOUT_TEST }}
              ;;
            "scan")
              base_timeout=${{ env.BASE_TIMEOUT_SCAN }}
              ;;
            "deploy")
              base_timeout=${{ env.BASE_TIMEOUT_DEPLOY }}
              ;;
            "custom"|*)
              base_timeout=${{ env.BASE_TIMEOUT_CUSTOM }}
              ;;
          esac
          
          # Get complexity multiplier
          case "$complexity_level" in
            "simple")
              complexity_mult="${{ env.MULTIPLIER_SIMPLE }}"
              ;;
            "standard")
              complexity_mult="${{ env.MULTIPLIER_STANDARD }}"
              ;;
            "complex")
              complexity_mult="${{ env.MULTIPLIER_COMPLEX }}"
              ;;
            "enterprise")
              complexity_mult="${{ env.MULTIPLIER_ENTERPRISE }}"
              ;;
            *)
              complexity_mult="${{ env.MULTIPLIER_STANDARD }}"
              ;;
          esac
          
          # Get resource multiplier
          case "$resource_tier" in
            "small")
              resource_mult="${{ env.MULTIPLIER_SMALL }}"
              ;;
            "medium")
              resource_mult="${{ env.MULTIPLIER_MEDIUM }}"
              ;;
            "large")
              resource_mult="${{ env.MULTIPLIER_LARGE }}"
              ;;
            "xlarge")
              resource_mult="${{ env.MULTIPLIER_XLARGE }}"
              ;;
            *)
              resource_mult="${{ env.MULTIPLIER_MEDIUM }}"
              ;;
          esac
          
          # Calculate final timeout (using bc for floating point math)
          calculated_timeout=$(echo "$base_timeout * $complexity_mult * $resource_mult" | bc -l)
          
          # Round to nearest integer and ensure minimum/maximum bounds
          final_timeout=$(printf "%.0f" "$calculated_timeout")
          
          # Apply bounds (min: 5 minutes, max: 60 minutes)
          if [[ $final_timeout -lt 5 ]]; then
            final_timeout=5
          elif [[ $final_timeout -gt 60 ]]; then
            final_timeout=60
          fi
          
          # Determine cleanup strategy
          cleanup_required="false"
          timeout_strategy="standard"
          
          if [[ $final_timeout -gt 30 ]]; then
            cleanup_required="true"
            timeout_strategy="extended"
          elif [[ $final_timeout -lt 10 ]]; then
            timeout_strategy="quick"
          fi
          
          echo "timeout-minutes=$final_timeout" >> $GITHUB_OUTPUT
          echo "cleanup-required=$cleanup_required" >> $GITHUB_OUTPUT
          echo "timeout-strategy=$timeout_strategy" >> $GITHUB_OUTPUT
          
          echo "?? Calculated Timeout:"
          echo "  - Base timeout: ${base_timeout} minutes"
          echo "  - Complexity multiplier: ${complexity_mult}x"
          echo "  - Resource multiplier: ${resource_mult}x"
          echo "  - Final timeout: ${final_timeout} minutes"
          echo "  - Strategy: $timeout_strategy"
          echo "  - Cleanup required: $cleanup_required"
          
      - name: ?? Generate timeout configuration
        run: |
          echo "?? Generating timeout configuration file..."
          
          cat > timeout-config.json <<EOF
          {
            "operation_type": "${{ inputs.operation_type }}",
            "complexity_level": "${{ inputs.complexity_level }}",
            "resource_tier": "${{ inputs.resource_tier }}",
            "timeout_minutes": ${{ steps.calculate.outputs.timeout-minutes }},
            "timeout_seconds": $(( ${{ steps.calculate.outputs.timeout-minutes }} * 60 )),
            "timeout_strategy": "${{ steps.calculate.outputs.timeout-strategy }}",
            "cleanup_required": ${{ steps.calculate.outputs.cleanup-required }},
            "calculated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "recommendations": {
              "pre_timeout_warning_seconds": $(( ${{ steps.calculate.outputs.timeout-minutes }} * 60 - 120 )),
              "graceful_shutdown_seconds": 60,
              "cleanup_timeout_seconds": 180
            }
          }
          EOF
          
          echo "??Timeout configuration generated:"
          cat timeout-config.json | jq '.'
          
      - name: ?“¤ Upload timeout configuration
        uses: actions/upload-artifact@v4
        with:
          name: timeout-configuration
          path: timeout-config.json
          retention-days: 1

  timeout-demonstration:
    name: ?§ª Timeout Demonstration
    runs-on: ubuntu-latest
    needs: timeout-calculator
    timeout-minutes: ${{ fromJSON(needs.timeout-calculator.outputs.timeout-minutes) }}
    if: github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ?? Display calculated timeout
        run: |
          echo "?§ª Timeout Demonstration"
          echo "========================"
          echo "Calculated timeout: ${{ needs.timeout-calculator.outputs.timeout-minutes }} minutes"
          echo "Timeout strategy: ${{ needs.timeout-calculator.outputs.timeout-strategy }}"
          echo "Cleanup required: ${{ needs.timeout-calculator.outputs.cleanup-required }}"
          
      - name: ??Simulate operation with timeout handling
        id: simulate
        continue-on-error: true
        run: |
          echo "??Simulating operation with timeout handling..."
          
          timeout_seconds=$(( ${{ needs.timeout-calculator.outputs.timeout-minutes }} * 60 ))
          warning_time=$(( timeout_seconds - 120 ))  # 2 minutes before timeout
          
          echo "?Ž¯ Operation will timeout in ${timeout_seconds} seconds"
          echo "? ï? Warning will be shown at ${warning_time} seconds"
          
          # Simulate work with periodic status updates
          start_time=$(date +%s)
          
          simulate_work() {
            local duration=$1
            local work_type="$2"
            
            echo "?? Starting $work_type (duration: ${duration}s)..."
            
            for i in $(seq 1 $duration); do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              
              # Show warning near timeout
              if [[ $elapsed -eq $warning_time ]]; then
                echo "? ï? WARNING: Approaching timeout in 2 minutes!"
                echo "? ï? Current operation: $work_type"
                echo "? ï? Elapsed time: ${elapsed}s / ${timeout_seconds}s"
              fi
              
              # Show periodic progress
              if [[ $((i % 10)) -eq 0 ]]; then
                echo "?? Progress: ${i}/${duration}s (total elapsed: ${elapsed}s)"
              fi
              
              sleep 1
            done
            
            echo "??$work_type completed successfully"
          }
          
          # Simulate different types of work based on operation type
          case "${{ inputs.operation_type }}" in
            "build")
              simulate_work 15 "Dependency resolution"
              simulate_work 20 "Code compilation"
              simulate_work 10 "Asset bundling"
              ;;
            "test")
              simulate_work 10 "Test discovery"
              simulate_work 25 "Unit tests"
              simulate_work 15 "Integration tests"
              ;;
            "scan")
              simulate_work 8 "Code analysis setup"
              simulate_work 30 "Security scanning"
              simulate_work 12 "Report generation"
              ;;
            "deploy")
              simulate_work 5 "Environment validation"
              simulate_work 20 "Deployment execution"
              simulate_work 8 "Health checks"
              ;;
            *)
              simulate_work 30 "Custom operation"
              ;;
          esac
          
          echo "??All simulation tasks completed successfully"
          
      - name: ?§¹ Cleanup on timeout
        if: steps.simulate.outcome == 'cancelled' && needs.timeout-calculator.outputs.cleanup-required == 'true'
        run: |
          echo "?§¹ Performing cleanup after timeout..."
          echo "? ï? Operation was cancelled due to timeout"
          
          # Simulate cleanup operations
          echo "?? Cleaning up temporary files..."
          sleep 2
          
          echo "?? Releasing resources..."
          sleep 2
          
          echo "?? Notifying monitoring systems..."
          sleep 1
          
          echo "??Cleanup completed"
          
      - name: ?? Generate timeout report
        if: always()
        run: |
          echo "?? Generating timeout management report..."
          
          outcome="${{ steps.simulate.outcome }}"
          cleanup_performed="false"
          
          if [[ "$outcome" == "cancelled" && "${{ needs.timeout-calculator.outputs.cleanup-required }}" == "true" ]]; then
            cleanup_performed="true"
          fi
          
          cat > timeout-report.md <<EOF
          # Timeout Management Report
          
          **Date:** $(date -u +%Y-%m-%dT%H:%M:%SZ)  
          **Operation:** ${{ inputs.operation_type }}  
          **Complexity:** ${{ inputs.complexity_level }}  
          **Resources:** ${{ inputs.resource_tier }}  
          
          ## Timeout Configuration
          
          | Setting | Value |
          |---------|-------|
          | Timeout | ${{ needs.timeout-calculator.outputs.timeout-minutes }} minutes |
          | Strategy | ${{ needs.timeout-calculator.outputs.timeout-strategy }} |
          | Cleanup Required | ${{ needs.timeout-calculator.outputs.cleanup-required }} |
          
          ## Execution Results
          
          | Component | Status |
          |-----------|--------|
          | Simulation | $outcome |
          | Cleanup Performed | $cleanup_performed |
          
          ## Summary
          
          EOF
          
          case "$outcome" in
            "success")
              echo "??**Operation completed successfully within timeout limits.**" >> timeout-report.md
              ;;
            "cancelled")
              echo "??**Operation was cancelled due to timeout.**" >> timeout-report.md
              echo "" >> timeout-report.md
              echo "**Recommendations:**" >> timeout-report.md
              echo "- Consider reducing complexity level" >> timeout-report.md
              echo "- Use higher resource tier" >> timeout-report.md
              echo "- Split operation into smaller chunks" >> timeout-report.md
              ;;
            "failure")
              echo "??**Operation failed before timeout.**" >> timeout-report.md
              ;;
            *)
              echo "??**Operation completed with unknown status.**" >> timeout-report.md
              ;;
          esac
          
      - name: ?“¤ Upload timeout report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: timeout-management-report
          path: timeout-report.md
          retention-days: 7