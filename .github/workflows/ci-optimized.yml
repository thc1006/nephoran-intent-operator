name: CI Status Check
# Provides "CI Status" check required by branch protection rules
# Runs in parallel with ci-production.yml for comprehensive validation

# Re-enabled to provide CI Status check for branch protection
on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - integrate/**
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/ci-optimized.yml'
      - 'Makefile*'
      - 'scripts/**'
  workflow_dispatch: {}

concurrency:
  group: ci-status-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: "1.24.6"  # Project-aligned Go version (matches go.mod)
  GOPROXY: "https://proxy.golang.org,direct"
  GOSUMDB: "sum.golang.org"
  CGO_ENABLED: "0"
  GOMAXPROCS: "4"
  GOMEMLIMIT: "4GiB"
  GOGC: "100"

jobs:
  # Stage 1: Quick validation (2-3 minutes)
  quick-check:
    name: Quick Validation
    runs-on: ubuntu-latest
    timeout-minutes: 8  # Increased for reliability
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: Setup Go with cache
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'  # Use env variable for consistency
          cache: true
          cache-dependency-path: go.sum
          
      - name: Verify Go installation
        run: |
          set -e  # Bash strict mode - fail on any error
          go version
          go env
          
      - name: Install controller-gen
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Installing controller-gen for code generation..."
          go install sigs.k8s.io/controller-tools/cmd/controller-gen@latest
          
      - name: Generate required code
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Generating deepcopy, CRDs, RBAC, and webhook manifests..."
          controller-gen object:headerFile="hack/boilerplate.go.txt" paths="./..." || echo "Warning: object generation failed"
          controller-gen crd:allowDangerousTypes=true paths=./api/v1 paths=./api/v1alpha1 paths=./api/intent/v1alpha1 output:crd:dir=config/crd/bases || echo "Warning: CRD generation failed"
          controller-gen rbac:roleName=nephoran-manager paths="./controllers/..." output:rbac:dir=config/rbac || echo "Warning: RBAC generation failed"
          controller-gen webhook paths="./..." output:webhook:dir=config/webhook || echo "Warning: webhook generation failed"
          echo "Code generation completed"
          
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
          
      - name: Fail-fast syntax check
        timeout-minutes: 8
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Running fail-fast syntax check..."
          # Build core components first (most critical)
          echo "Building core operator components..."
          timeout 120s go build ./cmd/main.go || { echo "Failed to build main operator"; exit 1; }
          timeout 120s go build ./api/... || { echo "Failed to build API packages"; exit 1; }
          timeout 120s go build ./controllers/... || { echo "Failed to build controllers"; exit 1; }
          timeout 120s go build ./pkg/... || { echo "Failed to build pkg packages"; exit 1; }
          
          # Build additional cmd components (optional)
          echo "Building additional cmd components..."
          find ./cmd -name "main.go" -not -path "./cmd/main.go" | while read -r cmd_main; do
            cmd_dir=$(dirname "$cmd_main")
            cmd_name=$(basename "$cmd_dir")
            echo "Building $cmd_name..."
            timeout 60s go build "$cmd_main" || echo "Warning: Failed to build $cmd_name (continuing...)"
          done
          
          echo "Core build validation completed successfully"
          
      - name: Code quality check (non-blocking)
        continue-on-error: true
        run: |
          echo "Running go vet (warnings only, will not fail build)..."
          timeout 180s go vet ./... || echo "Warning: go vet found issues that should be addressed"
          
      - name: Quick dependency check
        timeout-minutes: 5
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Downloading dependencies..."
          # Retry download with backoff
          for attempt in 1 2 3; do
            echo "Download attempt $attempt/3"
            if timeout 120s go mod download -x; then
              echo "Dependencies downloaded successfully"
              break
            elif [ $attempt -eq 3 ]; then
              echo "Failed to download dependencies after 3 attempts"
              exit 1
            else
              echo "Download failed, retrying in 10s..."
              sleep 10
            fi
          done
          echo "Verifying module integrity..."
          timeout 90s go mod verify || { 
            echo "Warning: Module verification failed or timed out"; 
            echo "This may indicate network issues or corrupted cache";
            echo "Continuing with build validation..."; 
          }

  # Stage 2: Parallel builds with chunking
  build:
    name: Build Components
    needs: quick-check
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Increased for reliability
    strategy:
      fail-fast: false
      matrix:
        component:
          - cmd
          - controllers
          - pkg
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go with cache
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'  # Use env variable for consistency
          cache: true
          cache-dependency-path: go.sum
          
      - name: Setup build cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ matrix.component }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-${{ matrix.component }}-
            ${{ runner.os }}-go-
            
      - name: Build ${{ matrix.component }}
        timeout-minutes: 10  # Increased timeout
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Building ${{ matrix.component }}..."
          
          # Use optimized CI build script for core components
          if [ "${{ matrix.component }}" == "cmd" ]; then
            if [ -f "scripts/ci-build.sh" ]; then
              chmod +x scripts/ci-build.sh
              ./scripts/ci-build.sh
            else
              echo "Building cmd components..."
              go build -p=4 -mod=readonly -trimpath \
                -ldflags="-s -w" -gcflags="-l=4" \
                -tags="fast_build" \
                ./cmd/...
            fi
          else
            case "${{ matrix.component }}" in
              controllers)
                # Build controllers with timeout and better error handling
                echo "Building controllers..."
                timeout 300 go build -p=4 -mod=readonly -trimpath \
                  -ldflags="-s -w" -gcflags="-l=4" \
                  -tags="fast_build" \
                  ./controllers/...
                ;;
              pkg)
                # Build only critical pkg directories to avoid timeout
                for pkg_dir in pkg/context pkg/clients pkg/nephio; do
                  if [ -d "$pkg_dir" ]; then
                    echo "Building $pkg_dir..."
                    timeout 120 go build -p=4 -mod=readonly -trimpath \
                      -ldflags="-s -w" -gcflags="-l=4" \
                      -tags="fast_build" \
                      ./$pkg_dir/...
                  fi
                done
                ;;
            esac
          fi
          
      - name: Upload artifacts
        if: matrix.component == 'cmd'
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.component }}
          path: bin/
          retention-days: 1

  # Stage 3: Parallel testing with timeout protection
  test:
    name: Test Suite
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Increased for reliability
    strategy:
      fail-fast: false
      matrix:
        package:
          - pkg
          - internal
          - controllers
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go with cache
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'  # Use env variable for consistency
          cache: true
          cache-dependency-path: go.sum
          
      - name: Setup test cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-gotest-${{ matrix.package }}-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-gotest-${{ matrix.package }}-
            ${{ runner.os }}-gotest-
            
      - name: Run tests for ${{ matrix.package }}
        timeout-minutes: 10  # Increased timeout
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Testing ${{ matrix.package }}..."
          if [ -d "${{ matrix.package }}" ]; then
            go test -p=8 -short -timeout=5m \
              -tags="fast_build" \
              -coverprofile=coverage-${{ matrix.package }}.out \
              ./${{ matrix.package }}/...
          else
            echo "Package ${{ matrix.package }} not found, skipping tests"
            # Create empty coverage file to avoid upload errors
            touch coverage-${{ matrix.package }}.out
          fi
          
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.package }}
          path: coverage-${{ matrix.package }}.out
          retention-days: 1

  # Stage 4: Quick integration test
  integration:
    name: Integration Check
    needs: [build, test]
    runs-on: ubuntu-latest
    timeout-minutes: 8  # Increased timeout
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'  # Use env variable for consistency
          cache: true
          
      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: binaries-cmd
          path: bin/
        continue-on-error: true  # Don't fail if no artifacts exist
          
      - name: Quick integration test
        timeout-minutes: 5
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Running quick integration check..."
          
          if [ -d "bin" ] && [ "$(ls -A bin 2>/dev/null)" ]; then
            echo "Found binaries in bin/ directory"
            chmod +x bin/* || echo "No executables found in bin/"
            
            # Just verify binaries exist and can show version/help
            for binary in bin/*; do
              if [ -x "$binary" ]; then
                name=$(basename $binary)
                echo "Checking $name..."
                # Remove silent failure - let timeout handle errors properly
                if timeout 15 $binary --help >/dev/null 2>&1; then
                  echo "$name supports --help"
                elif timeout 15 $binary version >/dev/null 2>&1; then
                  echo "$name supports version"
                else
                  echo "$name does not support --help or version (this is OK)"
                fi
              fi
            done
          else
            echo "No binaries found to test - this may be expected for this component structure"
          fi

  # Final status check
  ci-status:
    name: CI Status
    needs: [quick-check, build, test, integration]
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: always()
    
    steps:
      - name: Check CI Status
        run: |
          set -e  # Bash strict mode - fail on any error
          echo "Checking individual job results..."
          echo "Quick check: ${{ needs.quick-check.result }}"
          echo "Build: ${{ needs.build.result }}"
          echo "Test: ${{ needs.test.result }}"
          echo "Integration: ${{ needs.integration.result }}"
          
          if [ "${{ needs.quick-check.result }}" == "failure" ] || \
             [ "${{ needs.build.result }}" == "failure" ] || \
             [ "${{ needs.test.result }}" == "failure" ] || \
             [ "${{ needs.integration.result }}" == "failure" ]; then
            echo "CI pipeline failed - one or more jobs failed"
            exit 1
          fi
          echo "CI pipeline passed successfully!"