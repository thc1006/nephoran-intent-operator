name: Kubernetes Operator CI 2025

on:
  push:
    branches: 
      - main
      - integrate/**
      - feat/**
      - fix/**
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - 'config/**'
      - 'controllers/**'
      - 'api/**'
      - 'PROJECT'
      - 'Makefile*'
      - '.github/workflows/k8s-operator-ci-2025.yml'
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
      - main
      - integrate/**
  workflow_dispatch:
    inputs:
      security_scan:
        description: 'Enable enhanced security scanning'
        required: false
        default: 'true'
        type: boolean
      integration_test:
        description: 'Run full integration tests'
        required: false
        default: 'false'
        type: boolean

# 2025 CI/CD best practice - branch-specific concurrency
concurrency:
  group: k8s-operator-ci-${{ github.ref }}
  cancel-in-progress: true

env:
  # 2025 Kubernetes and Go versions  
  GO_VERSION: "1.23.3"
  ACTIONS_STEP_DEBUG: true  # Enable verbose step logging for troubleshooting
  KUBERNETES_VERSION: "1.31.1"
  CONTROLLER_RUNTIME_VERSION: "v0.19.1"
  KUBEBUILDER_VERSION: "4.4.1"
  ENVTEST_KUBERNETES_VERSION: "1.31.1"
  
  # Build optimizations for 2025
  CGO_ENABLED: "0"
  GOOS: "linux"
  GOARCH: "amd64"
  GOMAXPROCS: "4"
  GOMEMLIMIT: "4GiB"
  GOTOOLCHAIN: "go1.23.3"
  
  # Cache configuration
  GOCACHE: "/tmp/go-cache"
  GOMODCACHE: "/tmp/go-mod"
  
  # Security scanning tools versions
  TRIVY_VERSION: "0.58.1"
  COSIGN_VERSION: "2.4.1"
  GOVULNCHECK_VERSION: "latest"

jobs:
  # =============================================================================
  # STAGE 1: Pre-flight Validation & Setup
  # =============================================================================
  preflight:
    name: "üöÄ Pre-flight Setup"
    runs-on: ubuntu-24.04  # 2025 Ubuntu LTS
    timeout-minutes: 10
    outputs:
      go-cache-key: ${{ steps.cache-setup.outputs.cache-key }}
      should-build: ${{ steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true' }}
      should-test-integration: ${{ steps.integration-check.outputs.should-run }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for security scanning
          
      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            go:
              - '**.go'
              - 'go.mod'
              - 'go.sum'
            k8s:
              - 'config/**'
              - 'controllers/**'
              - 'api/**'
              - 'PROJECT'
            security:
              - 'config/rbac/**'
              - 'config/crd/**'
              - 'config/webhook/**'
              - 'controllers/**'
              
      - name: Setup Go ${{ env.GO_VERSION }}
        if: steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false  # Manual cache control
          
      - name: Setup advanced Go cache
        if: steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true'
        id: cache-setup
        run: |
          # Generate cache key with version suffix to force refresh
          CACHE_VERSION="v2" # bump this to force new cache
          GO_SUM_HASH="${{ hashFiles('**/go.sum') }}"
          GO_MOD_HASH="${{ hashFiles('go.mod') }}"
          CONFIG_HASH="${{ hashFiles('config/**/*.yaml', 'PROJECT') }}"
          
          # Fallback for empty hashes
          if [[ -z "$GO_SUM_HASH" ]]; then GO_SUM_HASH="${{ github.sha }}"; fi
          if [[ -z "$GO_MOD_HASH" ]]; then GO_MOD_HASH="${{ github.sha }}"; fi
          if [[ -z "$CONFIG_HASH" ]]; then CONFIG_HASH="${{ github.sha }}"; fi
          
          CACHE_KEY="nephoran-k8s-op-v3-${CACHE_VERSION}-${{ runner.os }}-go${{ env.GO_VERSION }}-k8s${{ env.KUBERNETES_VERSION }}-${GO_SUM_HASH}-${GO_MOD_HASH}-${CONFIG_HASH}"
          echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "Generated cache key: $CACHE_KEY"
          
      - name: Clean Go cache directories
        if: steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true'
        run: |
          sudo rm -rf ${{ env.GOMODCACHE }}/* || echo "Cache cleanup failed, continuing..."
          sudo rm -rf ${{ env.GOCACHE }}/* || echo "Cache cleanup failed, continuing..."
            
      - name: Restore Go cache
        if: steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ steps.cache-setup.outputs.cache-key }}
          restore-keys: |
            nephoran-k8s-op-v3-v2-${{ runner.os }}-go${{ env.GO_VERSION }}-k8s${{ env.KUBERNETES_VERSION }}-
            nephoran-k8s-op-v3-v2-${{ runner.os }}-go${{ env.GO_VERSION }}-
          fail-on-cache-miss: false
            
      - name: Smoke test Go cache
        if: steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true'
        run: |
          echo "Smoke test: checking cache directories"
          mkdir -p ${{ env.GOCACHE }}
          mkdir -p ${{ env.GOMODCACHE }}
          ls -la ${{ env.GOCACHE }} || echo "Cache directory is empty"
          ls -la ${{ env.GOMODCACHE }} || echo "Module cache directory is empty"
            
      - name: Download dependencies
        if: steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true'
        run: |
          echo "üì¶ Downloading Go modules..."
          go mod download
          go mod verify
          echo "‚úÖ Dependencies verified"
          
      - name: Save Go cache
        if: always() && (steps.changes.outputs.go == 'true' || steps.changes.outputs.k8s == 'true')
        uses: actions/cache/save@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ steps.cache-setup.outputs.cache-key }}
          
      - name: Integration test check
        id: integration-check
        run: |
          # Determine if integration tests should run
          SHOULD_RUN="false"
          if [[ "${{ github.event.inputs.integration_test }}" == "true" ]] || \
             [[ "${{ github.ref }}" == "refs/heads/main" ]] || \
             [[ "${{ github.ref }}" =~ refs/heads/integrate/ ]]; then
            SHOULD_RUN="true"
          fi
          echo "should-run=${SHOULD_RUN}" >> $GITHUB_OUTPUT
          echo "Integration tests will run: ${SHOULD_RUN}"

  # =============================================================================
  # STAGE 2: Kubernetes-specific Validation
  # =============================================================================
  k8s-validation:
    name: "‚ò∏Ô∏è Kubernetes Validation"
    needs: preflight
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    if: needs.preflight.outputs.should-build == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
          
      - name: Restore Go cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ needs.preflight.outputs.go-cache-key }}
          restore-keys: |
            nephoran-k8s-op-v3-${{ runner.os }}-go${{ env.GO_VERSION }}-k8s${{ env.KUBERNETES_VERSION }}-
            
      - name: Install Kubebuilder
        run: |
          echo "üîß Installing Kubebuilder ${{ env.KUBEBUILDER_VERSION }}..."
          curl -L https://github.com/kubernetes-sigs/kubebuilder/releases/download/v${{ env.KUBEBUILDER_VERSION }}/kubebuilder_${{ env.KUBEBUILDER_VERSION }}_linux_amd64.tar.gz | tar -xz
          sudo mv kubebuilder_${{ env.KUBEBUILDER_VERSION }}_linux_amd64/bin/kubebuilder /usr/local/bin/
          kubebuilder version
          
      - name: Smoke test Kubebuilder
        run: |
          which kubebuilder
          kubebuilder version
          
      - name: Install additional K8s tools
        run: |
          # Install controller-gen for 2025
          echo "üîß Installing controller-gen..."
          go install sigs.k8s.io/controller-tools/cmd/controller-gen@v0.19.0
          
          # Install kustomize
          echo "üîß Installing kustomize..."
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          # Install CRD validation tools
          echo "üîß Installing kubeval..."
          curl -L https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz | tar xz
          sudo mv kubeval /usr/local/bin/
          
          # Verify installations
          controller-gen --version
          kustomize version
          kubeval --version
          
      - name: Validate CRD generation
        timeout-minutes: 3
        run: |
          echo "üéØ Generating and validating CRDs..."
          make manifests
          
          # Validate generated CRDs
          echo "üîç Validating CRD schemas..."
          find config/crd/bases -name "*.yaml" -exec kubeval --strict {} \;
          
          # Check for CRD changes (should be committed)
          if ! git diff --quiet config/crd/bases/; then
            echo "‚ùå CRD changes detected but not committed!"
            echo "Please run 'make manifests' and commit the changes"
            git diff config/crd/bases/
            exit 1
          fi
          echo "‚úÖ CRDs are up-to-date"
          
      - name: Validate RBAC generation
        timeout-minutes: 2
        run: |
          echo "üîê Generating and validating RBAC..."
          make generate
          
          # Check RBAC files
          echo "üîç Validating RBAC configurations..."
          find config/rbac -name "*.yaml" -exec kubeval --strict {} \;
          
          # Check for uncommitted changes
          if ! git diff --quiet config/rbac/; then
            echo "‚ùå RBAC changes detected but not committed!"
            echo "Please run 'make generate' and commit the changes"
            git diff config/rbac/
            exit 1
          fi
          echo "‚úÖ RBAC is up-to-date"
          
      - name: Validate webhook configurations
        if: hashFiles('config/webhook/**') != ''
        timeout-minutes: 2
        run: |
          echo "ü™ù Validating webhook configurations..."
          find config/webhook -name "*.yaml" -exec kubeval --strict {} \;
          echo "‚úÖ Webhook configurations are valid"
          
      - name: Kustomize validation
        timeout-minutes: 2
        run: |
          echo "üìã Validating kustomize configurations..."
          
          # Validate default overlay
          echo "üîç Testing default kustomization..."
          kustomize build config/default > /tmp/default-manifest.yaml
          kubeval --strict /tmp/default-manifest.yaml
          
          # Validate samples if they exist
          if [[ -d config/samples ]]; then
            echo "üîç Validating sample configurations..."
            find config/samples -name "*.yaml" -exec kubeval --strict {} \;
          fi
          
          echo "‚úÖ All kustomize configurations are valid"

  # =============================================================================
  # STAGE 3: Enhanced Security Scanning (2025 Standards)
  # =============================================================================
  security-scan:
    name: "üîí Security Scan"
    needs: preflight
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    if: needs.preflight.outputs.should-build == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better vulnerability detection
          
      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
          
      - name: Restore Go cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ needs.preflight.outputs.go-cache-key }}
          
      - name: Install security tools
        run: |
          # Install Trivy for comprehensive scanning
          echo "üîß Installing Trivy ${{ env.TRIVY_VERSION }}..."
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${{ env.TRIVY_VERSION }}
          
          # Install govulncheck for Go-specific vulnerability scanning
          echo "üîß Installing govulncheck..."
          go install golang.org/x/vuln/cmd/govulncheck@${{ env.GOVULNCHECK_VERSION }}
          
          # Install cosign for supply chain security
          echo "üîß Installing cosign ${{ env.COSIGN_VERSION }}..."
          curl -O -L "https://github.com/sigstore/cosign/releases/download/v${{ env.COSIGN_VERSION }}/cosign-linux-amd64"
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign
          
          # Verify installations
          trivy --version
          govulncheck -version
          cosign version
          
      - name: Run Go vulnerability scan
        timeout-minutes: 5
        run: |
          echo "üîç Scanning Go modules for vulnerabilities..."
          govulncheck ./...
          echo "‚úÖ Go vulnerability scan completed"
          
      - name: Run filesystem security scan
        timeout-minutes: 5
        run: |
          echo "üîç Scanning filesystem for security issues..."
          trivy fs . \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            --scanners vuln,secret,config \
            --format sarif \
            --output trivy-fs-results.sarif
          echo "‚úÖ Filesystem security scan completed"
          
      - name: Scan Kubernetes configurations
        timeout-minutes: 3
        run: |
          echo "üîç Scanning Kubernetes configurations..."
          trivy config config/ \
            --severity HIGH,CRITICAL \
            --format sarif \
            --output trivy-k8s-results.sarif
          echo "‚úÖ Kubernetes configuration scan completed"
          
      - name: RBAC security analysis
        timeout-minutes: 2
        run: |
          echo "üîê Analyzing RBAC configurations for security issues..."
          
          # Check for overprivileged roles
          echo "üîç Checking for dangerous RBAC permissions..."
          if grep -r "apiGroups.*\*" config/rbac/ 2>/dev/null; then
            echo "‚ö†Ô∏è Warning: Found wildcard API groups in RBAC"
          fi
          
          if grep -r "resources.*\*" config/rbac/ 2>/dev/null; then
            echo "‚ö†Ô∏è Warning: Found wildcard resources in RBAC"
          fi
          
          if grep -r "verbs.*\*" config/rbac/ 2>/dev/null; then
            echo "‚ùå Error: Found wildcard verbs in RBAC - this is dangerous!"
            exit 1
          fi
          
          echo "‚úÖ RBAC security analysis completed"
          
      - name: Container image security scan
        if: hashFiles('**/Dockerfile') != ''
        timeout-minutes: 5
        run: |
          echo "üê≥ Building and scanning container images..."
          
          # Build operator image
          make docker-build IMG=nephoran-operator:security-scan
          
          # Scan the built image
          trivy image \
            --severity HIGH,CRITICAL \
            --ignore-unfixed \
            --format sarif \
            --output trivy-image-results.sarif \
            nephoran-operator:security-scan
            
          echo "‚úÖ Container image security scan completed"
          
      - name: Upload security scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: '.'
          
      - name: Security scan summary
        if: always()
        run: |
          echo "# üîí Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Scans Completed:**" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Go vulnerability scanning" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Filesystem security scanning" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Kubernetes configuration scanning" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ RBAC security analysis" >> $GITHUB_STEP_SUMMARY
          if [[ -f "trivy-image-results.sarif" ]]; then
            echo "- ‚úÖ Container image scanning" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Security Tools Used:**" >> $GITHUB_STEP_SUMMARY
          echo "- Trivy v${{ env.TRIVY_VERSION }} (comprehensive security scanner)" >> $GITHUB_STEP_SUMMARY
          echo "- govulncheck (Go-specific vulnerability detection)" >> $GITHUB_STEP_SUMMARY
          echo "- Custom RBAC analysis" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # STAGE 4: Controller Testing with envtest
  # =============================================================================
  controller-tests:
    name: "üéÆ Controller Tests"
    needs: [preflight, k8s-validation]
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    if: needs.preflight.outputs.should-build == 'true'
    
    strategy:
      fail-fast: false
      matrix:
        test-suite:
          - controllers
          - webhooks
          - api
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
          
      - name: Restore Go cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ needs.preflight.outputs.go-cache-key }}
          
      - name: Setup envtest environment
        run: |
          echo "üß™ Setting up envtest for Kubernetes ${{ env.ENVTEST_KUBERNETES_VERSION }}..."
          
          # Install setup-envtest
          go install sigs.k8s.io/controller-runtime/tools/setup-envtest@latest
          
          # Setup test environment
          export KUBEBUILDER_ASSETS=$(setup-envtest use ${{ env.ENVTEST_KUBERNETES_VERSION }} --bin-dir /tmp/envtest-bins -p path)
          echo "KUBEBUILDER_ASSETS=${KUBEBUILDER_ASSETS}" >> $GITHUB_ENV
          
          # Verify setup
          echo "üìç KUBEBUILDER_ASSETS: ${KUBEBUILDER_ASSETS}"
          ls -la ${KUBEBUILDER_ASSETS}
          
          # Test basic functionality
          ${KUBEBUILDER_ASSETS}/kube-apiserver --version
          ${KUBEBUILDER_ASSETS}/etcd --version
          ${KUBEBUILDER_ASSETS}/kubectl version --client
          
      - name: Run ${{ matrix.test-suite }} tests
        timeout-minutes: 10
        run: |
          echo "üß™ Running ${{ matrix.test-suite }} tests with envtest..."
          
          # Set test environment variables
          export USE_EXISTING_CLUSTER=false
          export KUBEBUILDER_CONTROLPLANE_START_TIMEOUT=60s
          export KUBEBUILDER_CONTROLPLANE_STOP_TIMEOUT=60s
          
          case "${{ matrix.test-suite }}" in
            controllers)
              echo "Testing controller logic..."
              go test -v -timeout=10m -p=1 ./controllers/... -coverprofile=controller-coverage.out
              ;;
            webhooks)
              if [[ -d "webhooks" ]]; then
                echo "Testing webhook logic..."
                go test -v -timeout=10m -p=1 ./webhooks/... -coverprofile=webhook-coverage.out
              else
                echo "No webhook tests found, checking for webhook code in controllers..."
                go test -v -timeout=10m -p=1 ./controllers/... -run=".*Webhook.*" -coverprofile=webhook-coverage.out || echo "No webhook tests in controllers"
              fi
              ;;
            api)
              echo "Testing API validation logic..."
              go test -v -timeout=10m -p=1 ./api/... -coverprofile=api-coverage.out
              ;;
          esac
          
      - name: Generate coverage report
        if: always()
        run: |
          COVERAGE_FILE=""
          case "${{ matrix.test-suite }}" in
            controllers) COVERAGE_FILE="controller-coverage.out" ;;
            webhooks) COVERAGE_FILE="webhook-coverage.out" ;;
            api) COVERAGE_FILE="api-coverage.out" ;;
          esac
          
          if [[ -f "$COVERAGE_FILE" ]]; then
            echo "üìä Generating coverage report for ${{ matrix.test-suite }}..."
            go tool cover -html=$COVERAGE_FILE -o coverage-${{ matrix.test-suite }}.html
            go tool cover -func=$COVERAGE_FILE | tail -1 | awk '{print "Coverage: " $3}' > coverage-${{ matrix.test-suite }}.txt
          else
            echo "No coverage file found for ${{ matrix.test-suite }}"
          fi
          
      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-suite }}
          path: |
            coverage-*.html
            coverage-*.txt
            *-coverage.out
          retention-days: 7

  # =============================================================================
  # STAGE 5: Integration Testing (Optional)
  # =============================================================================
  integration-tests:
    name: "üîó Integration Tests"
    needs: [preflight, controller-tests]
    runs-on: ubuntu-24.04
    timeout-minutes: 20
    if: needs.preflight.outputs.should-test-integration == 'true'
    
    services:
      registry:
        image: registry:2
        ports:
          - 5000:5000
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
          
      - name: Restore Go cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ needs.preflight.outputs.go-cache-key }}
          
      - name: Setup KIND cluster
        uses: helm/kind-action@v1.10.0
        with:
          version: v0.26.0
          kubernetes_version: v1.31.0
          cluster_name: nephoran-test
          config: |
            kind: Cluster
            apiVersion: kind.x-k8s.io/v1alpha4
            containerdConfigPatches:
            - |-
              [plugins."io.containerd.grpc.v1.cri".registry.mirrors."localhost:5000"]
                endpoint = ["http://registry:5000"]
            nodes:
            - role: control-plane
              kubeadmConfigPatches:
              - |
                kind: InitConfiguration
                nodeRegistration:
                  kubeletExtraArgs:
                    node-labels: "ingress-ready=true"
              extraPortMappings:
              - containerPort: 80
                hostPort: 80
                protocol: TCP
              - containerPort: 443
                hostPort: 443
                protocol: TCP
          
      - name: Build and load operator image
        run: |
          echo "üê≥ Building operator image for integration tests..."
          make docker-build IMG=localhost:5000/nephoran-operator:integration-test
          
          echo "üì§ Pushing to local registry..."
          docker push localhost:5000/nephoran-operator:integration-test
          
          echo "üì• Loading image to KIND..."
          kind load docker-image localhost:5000/nephoran-operator:integration-test --name nephoran-test
          
      - name: Deploy operator to cluster
        timeout-minutes: 5
        run: |
          echo "‚ò∏Ô∏è Deploying operator to KIND cluster..."
          
          # Install CRDs
          make install
          
          # Deploy operator
          cd config/manager && kustomize edit set image controller=localhost:5000/nephoran-operator:integration-test
          make deploy IMG=localhost:5000/nephoran-operator:integration-test
          
          # Wait for operator to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/nephoran-controller-manager -n nephoran-system
          
          echo "‚úÖ Operator deployed successfully"
          
      - name: Run integration tests
        timeout-minutes: 10
        run: |
          echo "üîó Running integration tests..."
          
          # Test CRD installation
          kubectl get crd | grep nephio.org
          
          # Test operator functionality with sample resources
          if [[ -d "config/samples" ]]; then
            echo "üìã Testing with sample resources..."
            kubectl apply -f config/samples/
            
            # Wait and verify resources are processed
            sleep 30
            kubectl get all -A
            
            # Check operator logs
            kubectl logs -n nephoran-system deployment/nephoran-controller-manager --tail=50
            
            # Cleanup samples
            kubectl delete -f config/samples/ --ignore-not-found=true
          fi
          
          echo "‚úÖ Integration tests completed"
          
      - name: Collect cluster information
        if: always()
        run: |
          echo "üìä Collecting cluster information..."
          
          echo "## Cluster Information" >> $GITHUB_STEP_SUMMARY
          echo "- Kubernetes Version: $(kubectl version --short)" >> $GITHUB_STEP_SUMMARY
          echo "- Node Information:" >> $GITHUB_STEP_SUMMARY
          kubectl get nodes -o wide >> $GITHUB_STEP_SUMMARY
          
          # Save operator logs
          kubectl logs -n nephoran-system deployment/nephoran-controller-manager > operator-logs.txt
          
      - name: Upload integration test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            operator-logs.txt
          retention-days: 7

  # =============================================================================
  # STAGE 6: Build & Package
  # =============================================================================
  build-package:
    name: "üì¶ Build & Package"
    needs: [preflight, k8s-validation, security-scan, controller-tests]
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    if: needs.preflight.outputs.should-build == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
          
      - name: Restore Go cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
          key: ${{ needs.preflight.outputs.go-cache-key }}
          
      - name: Build operator binary
        timeout-minutes: 5
        run: |
          echo "üî® Building operator binary..."
          make build
          
          # Verify binary
          ./bin/manager --version 2>/dev/null || echo "Manager binary built (no version flag)"
          ls -la bin/
          
      - name: Build container image
        timeout-minutes: 8
        run: |
          echo "üê≥ Building container image..."
          make docker-build IMG=nephoran-operator:latest
          
          # Image security check
          docker images nephoran-operator:latest
          
          # Basic image inspection
          echo "üîç Image inspection:"
          docker inspect nephoran-operator:latest | jq '.[0].Config.Labels'
          
      - name: Package Helm chart (if exists)
        if: hashFiles('charts/**') != ''
        timeout-minutes: 3
        run: |
          echo "üìã Packaging Helm chart..."
          helm package charts/nephoran-operator
          ls -la *.tgz
          
      - name: Generate deployment manifests
        timeout-minutes: 2
        run: |
          echo "üìÑ Generating deployment manifests..."
          mkdir -p dist/
          
          # Generate complete deployment manifest
          kustomize build config/default > dist/nephoran-operator.yaml
          
          # Generate CRD-only manifest
          kustomize build config/crd > dist/nephoran-crds.yaml
          
          # Generate RBAC-only manifest
          kustomize build config/rbac > dist/nephoran-rbac.yaml
          
          echo "Generated manifests:"
          ls -la dist/
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            bin/
            dist/
            *.tgz
          retention-days: 30

  # =============================================================================
  # STAGE 7: Enhanced Final Status Report with Error Diagnostics
  # =============================================================================
  ci-status:
    name: "üìä CI Status Report"
    needs: [preflight, k8s-validation, security-scan, controller-tests, integration-tests, build-package]
    runs-on: ubuntu-24.04
    if: always()
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository (for log analysis)
        uses: actions/checkout@v4
        if: always()
        
      - name: Enable debug logging
        if: always()
        run: |
          echo "ACTIONS_STEP_DEBUG=true" >> $GITHUB_ENV
          echo "RUNNER_DEBUG=1" >> $GITHUB_ENV
          
      - name: Download all workflow artifacts
        if: always()
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          merge-multiple: true
        continue-on-error: true
        
      - name: Analyze job failures and collect diagnostics
        if: always()
        run: |
          echo "üîç Analyzing job failures and collecting diagnostics..."
          
          # Create detailed analysis files
          mkdir -p failure-analysis
          
          # Function to analyze job status
          analyze_job() {
            local job_name="$1"
            local job_result="$2"
            local job_outputs="$3"
            
            echo "=== Analysis for job: $job_name ===" >> failure-analysis/detailed-report.md
            echo "Status: $job_result" >> failure-analysis/detailed-report.md
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> failure-analysis/detailed-report.md
            
            if [[ "$job_result" == "failure" ]]; then
              echo "‚ùå FAILED: $job_name" >> failure-analysis/failed-jobs.txt
              echo "" >> failure-analysis/detailed-report.md
              echo "**Failure Analysis:**" >> failure-analysis/detailed-report.md
              
              # Look for common failure patterns
              case "$job_name" in
                "preflight")
                  echo "- Check: Go version compatibility" >> failure-analysis/detailed-report.md
                  echo "- Check: Dependency downloads" >> failure-analysis/detailed-report.md
                  echo "- Check: Cache setup" >> failure-analysis/detailed-report.md
                  ;;
                "k8s-validation")
                  echo "- Check: CRD generation issues" >> failure-analysis/detailed-report.md
                  echo "- Check: RBAC validation errors" >> failure-analysis/detailed-report.md
                  echo "- Check: Kustomize build failures" >> failure-analysis/detailed-report.md
                  ;;
                "security-scan")
                  echo "- Check: Vulnerability scan results" >> failure-analysis/detailed-report.md
                  echo "- Check: RBAC security violations" >> failure-analysis/detailed-report.md
                  echo "- Check: Container image security issues" >> failure-analysis/detailed-report.md
                  ;;
                "controller-tests")
                  echo "- Check: Test failures in controllers" >> failure-analysis/detailed-report.md
                  echo "- Check: Envtest setup issues" >> failure-analysis/detailed-report.md
                  echo "- Check: Race conditions or timeouts" >> failure-analysis/detailed-report.md
                  ;;
                "build-package")
                  echo "- Check: Binary compilation errors" >> failure-analysis/detailed-report.md
                  echo "- Check: Container image build failures" >> failure-analysis/detailed-report.md
                  echo "- Check: Manifest generation issues" >> failure-analysis/detailed-report.md
                  ;;
              esac
            elif [[ "$job_result" == "success" ]]; then
              echo "‚úÖ PASSED: $job_name" >> failure-analysis/passed-jobs.txt
            elif [[ "$job_result" == "skipped" ]]; then
              echo "‚è≠Ô∏è SKIPPED: $job_name (conditional execution)" >> failure-analysis/skipped-jobs.txt
            elif [[ "$job_result" == "cancelled" ]]; then
              echo "üö´ CANCELLED: $job_name" >> failure-analysis/cancelled-jobs.txt
            fi
            
            echo "" >> failure-analysis/detailed-report.md
          }
          
          # Analyze each job
          analyze_job "preflight" "${{ needs.preflight.result }}" "${{ toJSON(needs.preflight.outputs) }}"
          analyze_job "k8s-validation" "${{ needs.k8s-validation.result }}" ""
          analyze_job "security-scan" "${{ needs.security-scan.result }}" ""
          analyze_job "controller-tests" "${{ needs.controller-tests.result }}" ""
          analyze_job "integration-tests" "${{ needs.integration-tests.result }}" ""
          analyze_job "build-package" "${{ needs.build-package.result }}" ""
          
          echo "üìä Job analysis completed"
          
      - name: Generate GitHub Actions API logs (if failures detected)
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if we have any failures
          if [[ -f "failure-analysis/failed-jobs.txt" ]] && [[ -s "failure-analysis/failed-jobs.txt" ]]; then
            echo "üîç Failures detected, attempting to fetch detailed logs..."
            
            # Try to get workflow run logs via API (requires additional permissions)
            # This is a best-effort attempt
            curl -H "Authorization: token $GITHUB_TOKEN" \
                 -H "Accept: application/vnd.github.v3+json" \
                 "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" \
                 -o workflow-jobs.json 2>/dev/null || echo "Failed to fetch job details via API"
            
            if [[ -f "workflow-jobs.json" ]]; then
              echo "üìã Retrieved workflow job information"
              jq -r '.jobs[] | select(.conclusion == "failure") | "Job: \(.name), Conclusion: \(.conclusion), Started: \(.started_at), Completed: \(.completed_at)"' workflow-jobs.json > failure-analysis/failed-job-details.txt 2>/dev/null || echo "Failed to parse job details"
            fi
          fi
          
      - name: Create comprehensive error summary
        if: always()
        run: |
          echo "üìù Creating comprehensive error summary..."
          
          # Initialize counters
          PASSED_COUNT=0
          FAILED_COUNT=0
          SKIPPED_COUNT=0
          CANCELLED_COUNT=0
          
          # Count results
          [[ -f "failure-analysis/passed-jobs.txt" ]] && PASSED_COUNT=$(wc -l < failure-analysis/passed-jobs.txt)
          [[ -f "failure-analysis/failed-jobs.txt" ]] && FAILED_COUNT=$(wc -l < failure-analysis/failed-jobs.txt)
          [[ -f "failure-analysis/skipped-jobs.txt" ]] && SKIPPED_COUNT=$(wc -l < failure-analysis/skipped-jobs.txt)
          [[ -f "failure-analysis/cancelled-jobs.txt" ]] && CANCELLED_COUNT=$(wc -l < failure-analysis/cancelled-jobs.txt)
          
          # Create error summary file
          cat > failure-analysis/error-summary.md << EOF
          # üéØ Nephoran Kubernetes Operator CI Report
          **Generated:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Run ID:** ${{ github.run_id }}
          **Workflow:** ${{ github.workflow }}
          **Trigger:** ${{ github.event_name }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          
          ## üìä Job Summary
          - ‚úÖ **Passed:** $PASSED_COUNT
          - ‚ùå **Failed:** $FAILED_COUNT  
          - ‚è≠Ô∏è **Skipped:** $SKIPPED_COUNT
          - üö´ **Cancelled:** $CANCELLED_COUNT
          
          ## üîß Environment Information
          - **Go Version:** ${{ env.GO_VERSION }}
          - **Kubernetes Version:** ${{ env.KUBERNETES_VERSION }}
          - **Controller-Runtime:** ${{ env.CONTROLLER_RUNTIME_VERSION }}
          - **Runner OS:** ubuntu-24.04
          - **Debug Mode:** Enabled ($ACTIONS_STEP_DEBUG)
          
          EOF
          
          # Add detailed job results
          echo "## üìã Detailed Job Results" >> failure-analysis/error-summary.md
          
          if [[ -f "failure-analysis/failed-jobs.txt" ]] && [[ -s "failure-analysis/failed-jobs.txt" ]]; then
            echo "" >> failure-analysis/error-summary.md
            echo "### ‚ùå Failed Jobs" >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
            cat failure-analysis/failed-jobs.txt >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
          fi
          
          if [[ -f "failure-analysis/passed-jobs.txt" ]] && [[ -s "failure-analysis/passed-jobs.txt" ]]; then
            echo "" >> failure-analysis/error-summary.md
            echo "### ‚úÖ Passed Jobs" >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
            cat failure-analysis/passed-jobs.txt >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
          fi
          
          if [[ -f "failure-analysis/skipped-jobs.txt" ]] && [[ -s "failure-analysis/skipped-jobs.txt" ]]; then
            echo "" >> failure-analysis/error-summary.md
            echo "### ‚è≠Ô∏è Skipped Jobs" >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
            cat failure-analysis/skipped-jobs.txt >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
          fi
          
      - name: Analyze artifact contents for errors
        if: always()
        run: |
          echo "üîç Analyzing artifact contents for error patterns..."
          
          if [[ -d "./artifacts" ]]; then
            echo "Found artifacts directory, analyzing contents..."
            
            # Look for test results and coverage files
            find ./artifacts -name "*.out" -o -name "*.txt" -o -name "*.html" | while read -r file; do
              echo "Analyzing: $file" >> failure-analysis/artifact-analysis.txt
              
              # Check for common error patterns in files
              if [[ "$file" =~ \.txt$ ]] || [[ "$file" =~ \.out$ ]]; then
                if grep -i "error\|fail\|panic\|fatal" "$file" 2>/dev/null; then
                  echo "  ‚ùå Error patterns found in $file" >> failure-analysis/artifact-analysis.txt
                  echo "  Last 10 lines:" >> failure-analysis/artifact-analysis.txt
                  tail -10 "$file" | sed 's/^/    /' >> failure-analysis/artifact-analysis.txt
                else
                  echo "  ‚úÖ No error patterns found in $file" >> failure-analysis/artifact-analysis.txt
                fi
              fi
              echo "" >> failure-analysis/artifact-analysis.txt
            done
            
            # Create artifact inventory
            echo "## üì¶ Artifact Inventory" >> failure-analysis/error-summary.md
            echo "" >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
            find ./artifacts -type f | sort >> failure-analysis/error-summary.md
            echo "\`\`\`" >> failure-analysis/error-summary.md
          else
            echo "No artifacts directory found" >> failure-analysis/artifact-analysis.txt
          fi
          
      - name: Generate final status report
        if: always()
        run: |
          echo "üìä Generating final status report..."
          
          # Add the error summary to GitHub Step Summary
          if [[ -f "failure-analysis/error-summary.md" ]]; then
            cat failure-analysis/error-summary.md >> $GITHUB_STEP_SUMMARY
          fi
          
          # Add troubleshooting section if there are failures
          if [[ -f "failure-analysis/failed-jobs.txt" ]] && [[ -s "failure-analysis/failed-jobs.txt" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üõ†Ô∏è Troubleshooting Guide" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**For failed jobs, check:**" >> $GITHUB_STEP_SUMMARY
            echo "1. üìã Job logs in the GitHub Actions UI" >> $GITHUB_STEP_SUMMARY
            echo "2. üì¶ Downloaded artifacts (uploaded below)" >> $GITHUB_STEP_SUMMARY
            echo "3. üîç Detailed analysis in failure-analysis artifacts" >> $GITHUB_STEP_SUMMARY
            echo "4. üêõ Enable ACTIONS_STEP_DEBUG=true for verbose logging" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Common Issues:**" >> $GITHUB_STEP_SUMMARY
            echo "- **Cache issues:** Clear GitHub Actions cache" >> $GITHUB_STEP_SUMMARY
            echo "- **Dependency problems:** Check go.mod/go.sum" >> $GITHUB_STEP_SUMMARY
            echo "- **Test failures:** Review test logs and coverage reports" >> $GITHUB_STEP_SUMMARY
            echo "- **Security scan failures:** Check SARIF files in artifacts" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Add artifact information
          if [[ -f "failure-analysis/artifact-analysis.txt" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üìã Artifact Analysis" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            cat failure-analysis/artifact-analysis.txt | head -50 >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Upload comprehensive failure analysis
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ci-failure-analysis
          path: |
            failure-analysis/
            workflow-jobs.json
          retention-days: 30
          
      - name: Upload workflow artifacts for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-workflow-artifacts
          path: ./artifacts/
          retention-days: 7
        continue-on-error: true
        
      - name: Determine final status with enhanced reporting
        if: always()
        run: |
          echo "üéØ Determining final CI status..."
          
          # Check critical job results with detailed reporting
          FAILED_JOBS=""
          CRITICAL_FAILURES=""
          
          # Define critical jobs that must pass
          CRITICAL_JOBS="preflight k8s-validation security-scan controller-tests build-package"
          
          if [[ "${{ needs.preflight.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS preflight"
            CRITICAL_FAILURES="$CRITICAL_FAILURES preflight"
          fi
          if [[ "${{ needs.k8s-validation.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS k8s-validation"
            CRITICAL_FAILURES="$CRITICAL_FAILURES k8s-validation"
          fi
          if [[ "${{ needs.security-scan.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS security-scan"
            CRITICAL_FAILURES="$CRITICAL_FAILURES security-scan"
          fi
          if [[ "${{ needs.controller-tests.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS controller-tests"
            CRITICAL_FAILURES="$CRITICAL_FAILURES controller-tests"
          fi
          if [[ "${{ needs.build-package.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS build-package"
            CRITICAL_FAILURES="$CRITICAL_FAILURES build-package"
          fi
          
          # Integration tests are optional, so they don't cause critical failure
          if [[ "${{ needs.integration-tests.result }}" == "failure" ]]; then
            FAILED_JOBS="$FAILED_JOBS integration-tests"
          fi
          
          # Generate final status
          if [[ -n "$CRITICAL_FAILURES" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ‚ùå **CI STATUS: CRITICAL FAILURE**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Critical Failed Jobs:** $CRITICAL_FAILURES" >> $GITHUB_STEP_SUMMARY
            if [[ -n "$FAILED_JOBS" ]]; then
              echo "**All Failed Jobs:** $FAILED_JOBS" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üö® **Action Required:** Review the failure analysis artifacts and job logs above." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Download the 'ci-failure-analysis' artifact for detailed diagnostics" >> $GITHUB_STEP_SUMMARY
            echo "2. Review individual job logs in the GitHub Actions UI" >> $GITHUB_STEP_SUMMARY  
            echo "3. Check the troubleshooting guide above" >> $GITHUB_STEP_SUMMARY
            echo "4. Fix the identified issues and re-run the workflow" >> $GITHUB_STEP_SUMMARY
            
            # Exit with failure
            exit 1
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ‚úÖ **CI STATUS: PASSED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ needs.integration-tests.result }}" == "failure" ]]; then
              echo "‚ö†Ô∏è **Note:** Integration tests failed but are not blocking" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "üéâ **2025 K8s Operator CI Achievements:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Modern Kubernetes ${{ env.KUBERNETES_VERSION }} compatibility verified" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Controller-runtime ${{ env.CONTROLLER_RUNTIME_VERSION }} integration tested" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ CRD and RBAC configurations validated" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Enhanced security scanning completed" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ envtest-based controller testing passed" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ needs.integration-tests.result }}" == "success" ]]; then
              echo "- ‚úÖ Full integration testing with KIND cluster completed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "- ‚úÖ Production-ready build artifacts generated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üöÄ **Ready for deployment!**" >> $GITHUB_STEP_SUMMARY
          fi