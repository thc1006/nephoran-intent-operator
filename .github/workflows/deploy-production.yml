# Nephoran Intent Operator - Production Deployment Workflow
# Comprehensive CI/CD pipeline for production-grade deployments

name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - dev
        - staging
        - prod
      cloud_provider:
        description: 'Cloud provider'
        required: true
        default: 'aws'
        type: choice
        options:
        - aws
        - azure
        - gcp
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'standard'
        type: choice
        options:
        - standard
        - enterprise
        - telecom
        - edge
      config_type:
        description: 'Configuration type'
        required: true
        default: 'standard'
        type: choice
        options:
        - standard
        - enterprise
        - telecom-operator
        - edge-computing
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
        - rolling
        - blue-green
        - canary
      region:
        description: 'Target region'
        required: true
        default: 'us-central1'
        type: string
      dry_run:
        description: 'Dry run (plan only)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment without approval'
        required: false
        default: false
        type: boolean
  
  push:
    branches:
      - main
    paths:
      - 'deployments/**'
      - 'infrastructure/**'
      - '.github/workflows/deploy-production.yml'

env:
  # Global environment variables
  DEPLOYMENT_TIMEOUT: 3600  # 1 hour
  HEALTH_CHECK_TIMEOUT: 600  # 10 minutes
  ROLLBACK_TIMEOUT: 1800     # 30 minutes
  
  # Artifact retention
  LOG_RETENTION_DAYS: 30
  ARTIFACT_RETENTION_DAYS: 90
  
  # Security settings
  ENABLE_SECURITY_SCANNING: true
  ENABLE_COMPLIANCE_CHECKS: true
  
  # Feature flags
  ENABLE_MONITORING: true
  ENABLE_BACKUP: true
  ENABLE_NOTIFICATIONS: true

jobs:
  # Pre-deployment validation and security checks
  pre-deployment-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.validation.outputs.should-deploy }}
      environment: ${{ steps.validation.outputs.environment }}
      cloud-provider: ${{ steps.validation.outputs.cloud-provider }}
      deployment-type: ${{ steps.validation.outputs.deployment-type }}
      config-type: ${{ steps.validation.outputs.config-type }}
      deployment-strategy: ${{ steps.validation.outputs.deployment-strategy }}
      region: ${{ steps.validation.outputs.region }}
      dry-run: ${{ steps.validation.outputs.dry-run }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Go
      uses: actions/setup-go@v5
        id: setup-go
      with:
        go-version-file: go.mod
        cache: true
    

    - name: Print Go version
      run: |
            echo "Go version: $(go version)"
            echo "Go env:"
            go env

    - name: Cache Dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Install Tools
      run: |
        # Install deployment tools
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh
        ./get_helm.sh
        
        # Install Terraform
        wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt update && sudo apt install terraform
        
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        
        # Install cloud CLIs based on provider
        if [[ "${{ github.event.inputs.cloud_provider || 'aws' }}" == "aws" ]]; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip && sudo ./aws/install
        elif [[ "${{ github.event.inputs.cloud_provider || 'aws' }}" == "azure" ]]; then
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        elif [[ "${{ github.event.inputs.cloud_provider || 'aws' }}" == "gcp" ]]; then
          curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz | tar xz
          ./google-cloud-sdk/install.sh --quiet
          echo "$HOME/google-cloud-sdk/bin" >> $GITHUB_PATH
        fi
    
    - name: Security Scanning
      if: env.ENABLE_SECURITY_SCANNING == 'true'
      run: |
        echo "🔒 Running security scans..."
        
        # Go security check
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...
        
        # License scanning
        go install github.com/google/go-licenses@latest
        go-licenses check ./...
        
        # Secret scanning
        if command -v gitleaks &> /dev/null; then
          gitleaks detect --source . --verbose
        fi
    
    - name: Compliance Checks
      if: env.ENABLE_COMPLIANCE_CHECKS == 'true'
      run: |
        echo "📋 Running compliance checks..."
        
        # Check for required security configurations
        if [[ "${{ github.event.inputs.deployment_type || 'standard' }}" == "telecom" ]]; then
          echo "Validating carrier-grade compliance requirements..."
          
          # Check for O-RAN compliance configurations
          if [[ ! -f "deployments/helm/nephoran-operator/environments/values-telecom-operator.yaml" ]]; then
            echo "❌ Missing telecom operator configuration file"
            exit 1
          fi
          
          # Validate security contexts
          if ! grep -q "seccompProfile" deployments/helm/nephoran-operator/environments/values-telecom-operator.yaml; then
            echo "❌ Missing seccomp profiles for carrier-grade deployment"
            exit 1
          fi
        fi
        
        # Check for required RBAC configurations
        if ! ls deployments/helm/nephoran-operator/templates/*rbac* 1> /dev/null 2>&1; then
          echo "❌ Missing RBAC templates"
          exit 1
        fi
        
        echo "✅ Compliance checks passed"
    
    - name: Validate Deployment Parameters
      id: validation
      run: |
        echo "🔍 Validating deployment parameters..."
        
        # Set parameters from inputs or defaults
        ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
        CLOUD_PROVIDER="${{ github.event.inputs.cloud_provider || 'aws' }}"
        DEPLOYMENT_TYPE="${{ github.event.inputs.deployment_type || 'standard' }}"
        CONFIG_TYPE="${{ github.event.inputs.config_type || 'standard' }}"
        DEPLOYMENT_STRATEGY="${{ github.event.inputs.deployment_strategy || 'rolling' }}"
        REGION="${{ github.event.inputs.region || 'us-central1' }}"
        DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
        
        # Validate environment
        case "$ENVIRONMENT" in
          dev|staging|prod) ;;
          *) echo "❌ Invalid environment: $ENVIRONMENT"; exit 1 ;;
        esac
        
        # Validate cloud provider
        case "$CLOUD_PROVIDER" in
          aws|azure|gcp) ;;
          *) echo "❌ Invalid cloud provider: $CLOUD_PROVIDER"; exit 1 ;;
        esac
        
        # Check if configuration file exists
        CONFIG_FILE="deployments/helm/nephoran-operator/environments/values-${CONFIG_TYPE}.yaml"
        if [[ ! -f "$CONFIG_FILE" ]]; then
          echo "❌ Configuration file not found: $CONFIG_FILE"
          exit 1
        fi
        
        # Production environment additional checks
        if [[ "$ENVIRONMENT" == "prod" ]]; then
          echo "🚨 Production deployment detected - additional validations required"
          
          # Check for production-specific configurations
          if [[ "$DEPLOYMENT_STRATEGY" == "rolling" ]] && [[ "$DEPLOYMENT_TYPE" == "telecom" ]]; then
            echo "⚠️ Warning: Rolling deployment for telecom in production - consider blue-green or canary"
          fi
          
          # Require explicit approval for production
          if [[ "${{ github.event.inputs.force_deploy }}" != "true" ]] && [[ "$DRY_RUN" != "true" ]]; then
            echo "🛑 Production deployment requires explicit approval or dry-run mode"
            echo "Set force_deploy=true to proceed with production deployment"
            exit 1
          fi
        fi
        
        # Set outputs
        echo "should-deploy=true" >> $GITHUB_OUTPUT
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "cloud-provider=$CLOUD_PROVIDER" >> $GITHUB_OUTPUT
        echo "deployment-type=$DEPLOYMENT_TYPE" >> $GITHUB_OUTPUT
        echo "config-type=$CONFIG_TYPE" >> $GITHUB_OUTPUT
        echo "deployment-strategy=$DEPLOYMENT_STRATEGY" >> $GITHUB_OUTPUT
        echo "region=$REGION" >> $GITHUB_OUTPUT
        echo "dry-run=$DRY_RUN" >> $GITHUB_OUTPUT
        
        echo "✅ Deployment parameters validated successfully"
    
    - name: Generate Deployment Summary
      run: |
        echo "📊 Deployment Summary:"
        echo "Environment: ${{ steps.validation.outputs.environment }}"
        echo "Cloud Provider: ${{ steps.validation.outputs.cloud-provider }}"
        echo "Deployment Type: ${{ steps.validation.outputs.deployment-type }}"
        echo "Config Type: ${{ steps.validation.outputs.config-type }}"
        echo "Strategy: ${{ steps.validation.outputs.deployment-strategy }}"
        echo "Region: ${{ steps.validation.outputs.region }}"
        echo "Dry Run: ${{ steps.validation.outputs.dry-run }}"

  # Build and test artifacts
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Go
      uses: actions/setup-go@v5
        id: setup-go
      with:
        go-version-file: go.mod
        cache: true
    

    - name: Print Go version
      run: |
            echo "Go version: $(go version)"
            echo "Go env:"
            go env

    - name: Cache Dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Download Dependencies
      run: go mod download
    
    - name: Run Tests
      run: |
        echo "🧪 Running comprehensive test suite..."
        
        # Unit tests with coverage
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        
        # Generate coverage report
        go tool cover -html=coverage.out -o coverage.html
        
        # Performance tests
        if [[ -f "scripts/performance-comparison.go" ]]; then
          echo "🚀 Running performance tests..."
          cd scripts && go run performance-comparison.go
        fi
        
        # Integration tests (if available)
        if [[ -d "tests/integration" ]]; then
          echo "🔗 Running integration tests..."
          go test -v ./tests/integration/...
        fi
    
    - name: Build Container Images
      run: |
        echo "🐳 Building container images..."
        
        # Build multi-architecture images
        docker buildx create --use --platform=linux/amd64,linux/arm64 --name multi-arch-builder
        docker buildx inspect --bootstrap
        
        # Build main operator image
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --tag "nephoran/intent-operator:${{ github.sha }}" \
          --tag "nephoran/intent-operator:latest" \
          --file Dockerfile \
          --build-arg SERVICE=manager \
          --build-arg VERSION=${{ github.sha }} \
          --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
          --build-arg VCS_REF=${{ github.sha }} \
          --push .
        
        # Build component images using main Dockerfile with SERVICE argument
        for component in llm-processor nephio-bridge oran-adaptor; do
          echo "Building $component..."
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag "nephoran/${component}:${{ github.sha }}" \
            --tag "nephoran/${component}:latest" \
            --file Dockerfile \
            --build-arg SERVICE=$component \
            --build-arg VERSION=${{ github.sha }} \
            --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --build-arg VCS_REF=${{ github.sha }} \
            --push .
        done
        
        # Build RAG API separately if it has its own Dockerfile
        if [[ -f "rag-python/Dockerfile" ]]; then
          echo "Building rag-api..."
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag "nephoran/rag-api:${{ github.sha }}" \
            --tag "nephoran/rag-api:latest" \
            --file "rag-python/Dockerfile" \
            --push ./rag-python
        fi
    
    - name: Security Scan Images
      run: |
        set -euo pipefail
        
        echo "🔍 Scanning container images for vulnerabilities..."
        
        # Function to get latest release version from GitHub
        get_latest_version() {
          local repo=$1
          curl -sL "https://api.github.com/repos/${repo}/releases/latest" | grep '"tag_name":' | cut -d '"' -f 4 | sed 's/^v//'
        }
        
        # Function to check if a version exists on GitHub releases
        check_github_version() {
          local repo=$1
          local version=$2
          local url="https://api.github.com/repos/${repo}/releases/tags/v${version}"
          if curl -sL "$url" | grep -q '"tag_name"'; then
            echo "Version v${version} exists for ${repo}"
            return 0
          else
            echo "Version v${version} not found for ${repo}, will use latest"
            return 1
          fi
        }
        
        # Install Trivy with robust version checking
        echo "📦 Installing Trivy..."
        TRIVY_TARGET_VERSION="0.57.1"
        if check_github_version "aquasecurity/trivy" "${TRIVY_TARGET_VERSION}"; then
          TRIVY_INSTALL_VERSION="${TRIVY_TARGET_VERSION}"
        else
          TRIVY_INSTALL_VERSION=$(get_latest_version "aquasecurity/trivy")
          echo "Using Trivy version: ${TRIVY_INSTALL_VERSION}"
        fi
        
        # Try repository installation first (with modern GPG key management)
        if ! wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo gpg --dearmor -o /usr/share/keyrings/trivy-keyring.gpg; then
          echo "⚠️ Failed to add Trivy GPG key, falling back to binary installation"
          TRIVY_FALLBACK=true
        else
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          echo "deb [signed-by=/usr/share/keyrings/trivy-keyring.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          
          if ! sudo apt-get install -y trivy 2>/dev/null; then
            echo "⚠️ Repository installation failed, falling back to binary"
            TRIVY_FALLBACK=true
          fi
        fi
        
        # Fallback to binary installation
        if [ "${TRIVY_FALLBACK:-false}" = "true" ]; then
          echo "📥 Installing Trivy from GitHub releases..."
          wget -q "https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_INSTALL_VERSION}/trivy_${TRIVY_INSTALL_VERSION}_Linux-64bit.tar.gz"
          tar -xzf "trivy_${TRIVY_INSTALL_VERSION}_Linux-64bit.tar.gz"
          sudo mv trivy /usr/local/bin/
          sudo chmod +x /usr/local/bin/trivy
          rm -f "trivy_${TRIVY_INSTALL_VERSION}_Linux-64bit.tar.gz"
          echo "✅ Trivy ${TRIVY_INSTALL_VERSION} installed from binary"
        else
          echo "✅ Trivy installed from repository"
        fi
        
        # Scan main image
        trivy image --format sarif --output trivy-results.sarif "nephoran/intent-operator:${{ github.sha }}"
        
        # Scan for critical vulnerabilities only for CI
        trivy image --exit-code 1 --severity CRITICAL "nephoran/intent-operator:${{ github.sha }}"
    
    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.run_id }}
        path: |
          coverage.out
          coverage.html
          trivy-results.sarif
        retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}

  # Infrastructure deployment
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-and-test]
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    environment: 
      name: ${{ needs.pre-deployment-validation.outputs.environment }}
      url: https://console.${{ needs.pre-deployment-validation.outputs.cloud-provider }}.com
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Cloud Authentication
      run: |
        echo "🔐 Setting up cloud authentication for ${{ needs.pre-deployment-validation.outputs.cloud-provider }}..."
        
        case "${{ needs.pre-deployment-validation.outputs.cloud-provider }}" in
          aws)
            # AWS authentication handled by aws-actions/configure-aws-credentials
            echo "AWS authentication will be handled by dedicated action"
            ;;
          azure)
            echo "Installing Azure CLI..."
            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
            ;;
          gcp)
            echo "Installing Google Cloud SDK..."
            curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz | tar xz
            ./google-cloud-sdk/install.sh --quiet
            echo "$HOME/google-cloud-sdk/bin" >> $GITHUB_PATH
            ;;
        esac
    
    - name: Configure AWS Credentials
      if: needs.pre-deployment-validation.outputs.cloud-provider == 'aws'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ needs.pre-deployment-validation.outputs.region }}
        role-duration-seconds: 3600
        role-session-name: NephoranDeployment
    
    - name: Configure Azure Credentials
      if: needs.pre-deployment-validation.outputs.cloud-provider == 'azure'
      run: |
        az login --service-principal \
          --username "${{ secrets.AZURE_CLIENT_ID }}" \
          --password "${{ secrets.AZURE_CLIENT_SECRET }}" \
          --tenant "${{ secrets.AZURE_TENANT_ID }}"
        
        az account set --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
    
    - name: Configure GCP Credentials
      if: needs.pre-deployment-validation.outputs.cloud-provider == 'gcp'
      run: |
        echo "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}" | base64 -d > gcp-key.json
        gcloud auth activate-service-account --key-file=gcp-key.json
        gcloud config set project "${{ secrets.GCP_PROJECT_ID }}"
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ~1.6.0
        terraform_wrapper: false
    
    - name: Deploy Infrastructure
      run: |
        echo "🏗️ Deploying infrastructure..."
        
        chmod +x ./scripts/deployment/deploy-nephoran.sh
        
        export ENVIRONMENT="${{ needs.pre-deployment-validation.outputs.environment }}"
        export CLOUD_PROVIDER="${{ needs.pre-deployment-validation.outputs.cloud-provider }}"
        export DEPLOYMENT_TYPE="${{ needs.pre-deployment-validation.outputs.deployment-type }}"
        export STRATEGY="${{ needs.pre-deployment-validation.outputs.deployment-strategy }}"
        export REGION="${{ needs.pre-deployment-validation.outputs.region }}"
        export CONFIG_TYPE="${{ needs.pre-deployment-validation.outputs.config-type }}"
        export DRY_RUN="${{ needs.pre-deployment-validation.outputs.dry-run }}"
        export SKIP_HELM="true"  # Only deploy infrastructure in this job
        export VERBOSE="true"
        
        ./scripts/deployment/deploy-nephoran.sh
      timeout-minutes: 60
    
    - name: Upload Infrastructure Logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: infrastructure-logs-${{ github.run_id }}
        path: /tmp/nephoran-deployment-*.log
        retention-days: ${{ env.LOG_RETENTION_DAYS }}

  # Application deployment
  deploy-applications:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, build-and-test, deploy-infrastructure]
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true'
    environment: 
      name: ${{ needs.pre-deployment-validation.outputs.environment }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Kubernetes Tools
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        
        # Install Helm
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh && ./get_helm.sh
    
    - name: Configure Cloud Authentication
      run: |
        case "${{ needs.pre-deployment-validation.outputs.cloud-provider }}" in
          aws)
            aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
            aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            aws configure set region "${{ needs.pre-deployment-validation.outputs.region }}"
            ;;
          azure)
            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
            az login --service-principal \
              --username "${{ secrets.AZURE_CLIENT_ID }}" \
              --password "${{ secrets.AZURE_CLIENT_SECRET }}" \
              --tenant "${{ secrets.AZURE_TENANT_ID }}"
            ;;
          gcp)
            curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz | tar xz
            ./google-cloud-sdk/install.sh --quiet
            echo "$HOME/google-cloud-sdk/bin" >> $GITHUB_PATH
            echo "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}" | base64 -d > gcp-key.json
            gcloud auth activate-service-account --key-file=gcp-key.json
            ;;
        esac
    
    - name: Get Kubernetes Credentials
      run: |
        echo "🔑 Getting Kubernetes credentials..."
        
        cluster_name="nephoran-intent-operator-${{ needs.pre-deployment-validation.outputs.environment }}"
        
        case "${{ needs.pre-deployment-validation.outputs.cloud-provider }}" in
          aws)
            aws eks update-kubeconfig \
              --region "${{ needs.pre-deployment-validation.outputs.region }}" \
              --name "${cluster_name}-eks"
            ;;
          azure)
            az aks get-credentials \
              --resource-group "${cluster_name}-rg" \
              --name "${cluster_name}-aks" \
              --overwrite-existing
            ;;
          gcp)
            gcloud container clusters get-credentials \
              "${cluster_name}-gke" \
              --region "${{ needs.pre-deployment-validation.outputs.region }}"
            ;;
        esac
        
        # Verify connection
        kubectl cluster-info
    
    - name: Deploy Applications
      run: |
        echo "🚀 Deploying applications..."
        
        chmod +x ./scripts/deployment/deploy-nephoran.sh
        
        export ENVIRONMENT="${{ needs.pre-deployment-validation.outputs.environment }}"
        export CLOUD_PROVIDER="${{ needs.pre-deployment-validation.outputs.cloud-provider }}"
        export DEPLOYMENT_TYPE="${{ needs.pre-deployment-validation.outputs.deployment-type }}"
        export STRATEGY="${{ needs.pre-deployment-validation.outputs.deployment-strategy }}"
        export REGION="${{ needs.pre-deployment-validation.outputs.region }}"
        export CONFIG_TYPE="${{ needs.pre-deployment-validation.outputs.config-type }}"
        export DRY_RUN="${{ needs.pre-deployment-validation.outputs.dry-run }}"
        export SKIP_TERRAFORM="true"  # Only deploy applications in this job
        export VERBOSE="true"
        
        ./scripts/deployment/deploy-nephoran.sh
      timeout-minutes: 45
    
    - name: Verify Deployment
      if: needs.pre-deployment-validation.outputs.dry-run == 'false'
      run: |
        echo "✅ Verifying deployment..."
        
        # Check deployment status
        kubectl get deployments -n nephoran-system
        kubectl get pods -n nephoran-system
        
        # Wait for deployments to be ready
        kubectl wait --for=condition=available --timeout=600s deployment --all -n nephoran-system
        
        # Check service endpoints
        kubectl get services -n nephoran-system
    
    - name: Run Health Checks
      if: needs.pre-deployment-validation.outputs.dry-run == 'false'
      run: |
        echo "🏥 Running health checks..."
        
        # Wait for services to be ready
        sleep 60
        
        # Health check script
        namespace="nephoran-system"
        services=("nephoran-operator:8080" "llm-processor:8080" "rag-api:5001" "weaviate:8080")
        
        for service in "${services[@]}"; do
          service_name="${service%:*}"
          port="${service#*:}"
          
          echo "Checking health of $service_name..."
          
          # Port forward and check
          kubectl port-forward svc/"$service_name" "$port:$port" -n "$namespace" &
          port_forward_pid=$!
          
          sleep 5
          
          if curl -f "http://localhost:$port/health" --max-time 10; then
            echo "✅ $service_name health check passed"
          else
            echo "❌ $service_name health check failed"
          fi
          
          kill $port_forward_pid 2>/dev/null || true
          sleep 2
        done
    
    - name: Upload Application Logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: application-logs-${{ github.run_id }}
        path: /tmp/nephoran-deployment-*.log
        retention-days: ${{ env.LOG_RETENTION_DAYS }}

  # Post-deployment testing and monitoring
  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-applications]
    if: needs.pre-deployment-validation.outputs.should-deploy == 'true' && needs.pre-deployment-validation.outputs.dry-run == 'false'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Tools
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        
        # Configure cloud access (simplified)
        case "${{ needs.pre-deployment-validation.outputs.cloud-provider }}" in
          aws)
            aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
            aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            aws configure set region "${{ needs.pre-deployment-validation.outputs.region }}"
            
            cluster_name="nephoran-intent-operator-${{ needs.pre-deployment-validation.outputs.environment }}-eks"
            aws eks update-kubeconfig --region "${{ needs.pre-deployment-validation.outputs.region }}" --name "$cluster_name"
            ;;
        esac
    
    - name: Run Integration Tests
      run: |
        echo "🧪 Running integration tests..."
        
        # Create test NetworkIntent
        cat << 'EOF' | kubectl apply -f -
        apiVersion: nephoran.com/v1alpha1
        kind: NetworkIntent
        metadata:
          name: integration-test-intent
          namespace: nephoran-system
        spec:
          intent: "Deploy a test 5G AMF instance for CI/CD validation"
          priority: medium
          metadata:
            test: "integration-test"
            ci_run: "${{ github.run_id }}"
        EOF
        
        # Wait for processing
        sleep 120
        
        # Check processing status
        status=$(kubectl get networkintent integration-test-intent -n nephoran-system -o jsonpath='{.status.phase}' 2>/dev/null || echo "NotFound")
        
        if [[ "$status" == "Processed" ]] || [[ "$status" == "Processing" ]]; then
          echo "✅ Integration test passed - NetworkIntent is being processed"
        else
          echo "❌ Integration test failed - NetworkIntent status: $status"
          kubectl describe networkintent integration-test-intent -n nephoran-system
          exit 1
        fi
        
        # Cleanup
        kubectl delete networkintent integration-test-intent -n nephoran-system --ignore-not-found=true
    
    - name: Performance Testing
      run: |
        echo "⚡ Running performance tests..."
        
        # Simple load test with curl
        endpoint=$(kubectl get service nephoran-operator -n nephoran-system -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "localhost")
        
        if [[ "$endpoint" != "localhost" ]]; then
          echo "Testing endpoint: $endpoint"
          
          # Basic availability test
          for i in {1..10}; do
            if curl -f "http://$endpoint:8080/health" --max-time 5; then
              echo "Health check $i passed"
            else
              echo "Health check $i failed"
            fi
            sleep 2
          done
        else
          echo "Load balancer endpoint not available, skipping external performance test"
        fi
    
    - name: Generate Deployment Report
      run: |
        echo "📊 Generating deployment report..."
        
        cat > deployment-report.md << EOF
        # Nephoran Intent Operator Deployment Report
        
        **Deployment ID**: ${{ github.run_id }}
        **Environment**: ${{ needs.pre-deployment-validation.outputs.environment }}
        **Cloud Provider**: ${{ needs.pre-deployment-validation.outputs.cloud-provider }}
        **Deployment Type**: ${{ needs.pre-deployment-validation.outputs.deployment-type }}
        **Strategy**: ${{ needs.pre-deployment-validation.outputs.deployment-strategy }}
        **Region**: ${{ needs.pre-deployment-validation.outputs.region }}
        **Timestamp**: $(date -u)
        
        ## Deployment Status
        ✅ Infrastructure Deployed
        ✅ Applications Deployed
        ✅ Health Checks Passed
        ✅ Integration Tests Passed
        
        ## Resource Summary
        \`\`\`
        $(kubectl get all -n nephoran-system)
        \`\`\`
        
        ## Service Endpoints
        \`\`\`
        $(kubectl get services -n nephoran-system -o wide)
        \`\`\`
        
        ## Pod Status
        \`\`\`
        $(kubectl get pods -n nephoran-system -o wide)
        \`\`\`
        EOF
        
        echo "Deployment report generated"
    
    - name: Setup Monitoring
      if: env.ENABLE_MONITORING == 'true'
      run: |
        echo "📈 Setting up monitoring..."
        
        # Check if Prometheus is deployed
        if ! kubectl get namespace monitoring &> /dev/null; then
          echo "Deploying monitoring stack..."
          
          # Add Prometheus Helm repo
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          
          # Install Prometheus stack
          helm upgrade --install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
            --namespace monitoring \
            --create-namespace \
            --set prometheusOperator.createCustomResource=false \
            --wait --timeout=10m
        fi
    
    - name: Notify Deployment Success
      if: env.ENABLE_NOTIFICATIONS == 'true' && success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: |
          🎉 Nephoran Intent Operator deployed successfully!
          Environment: ${{ needs.pre-deployment-validation.outputs.environment }}
          Cloud: ${{ needs.pre-deployment-validation.outputs.cloud-provider }}
          Type: ${{ needs.pre-deployment-validation.outputs.deployment-type }}
          Strategy: ${{ needs.pre-deployment-validation.outputs.deployment-strategy }}
          Region: ${{ needs.pre-deployment-validation.outputs.region }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    
    - name: Upload Deployment Report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: deployment-report-${{ github.run_id }}
        path: deployment-report.md
        retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}

  # Rollback job (manual trigger)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && needs.pre-deployment-validation.outputs.dry-run == 'false'
    needs: [pre-deployment-validation, deploy-applications]
    environment: 
      name: ${{ needs.pre-deployment-validation.outputs.environment }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Setup Tools and Authentication
      run: |
        echo "🔄 Setting up rollback environment..."
        
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        
        # Install Helm
        curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        chmod 700 get_helm.sh && ./get_helm.sh
    
    - name: Get Kubernetes Access
      run: |
        # Configure cloud access and get k8s credentials
        case "${{ needs.pre-deployment-validation.outputs.cloud-provider }}" in
          aws)
            aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
            aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            aws configure set region "${{ needs.pre-deployment-validation.outputs.region }}"
            
            cluster_name="nephoran-intent-operator-${{ needs.pre-deployment-validation.outputs.environment }}-eks"
            aws eks update-kubeconfig --region "${{ needs.pre-deployment-validation.outputs.region }}" --name "$cluster_name"
            ;;
        esac
    
    - name: Rollback Applications
      run: |
        echo "⏪ Rolling back applications..."
        
        # Rollback Helm releases
        namespace="nephoran-system"
        releases=("nephoran-operator")
        
        for release in "${releases[@]}"; do
          if helm list -n "$namespace" | grep -q "$release"; then
            echo "Rolling back $release..."
            helm rollback "$release" 0 -n "$namespace" --wait --timeout=10m
          fi
        done
        
        # Verify rollback
        kubectl get deployments -n "$namespace"
        kubectl wait --for=condition=available --timeout=600s deployment --all -n "$namespace"
    
    - name: Notify Rollback
      if: env.ENABLE_NOTIFICATIONS == 'true'
      uses: 8398a7/action-slack@v3
      with:
        status: warning
        channel: '#deployments'
        text: |
          ⚠️ Nephoran Intent Operator deployment rolled back
          Environment: ${{ needs.pre-deployment-validation.outputs.environment }}
          Reason: Deployment failure detected
          Action: Applications rolled back to previous version
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
