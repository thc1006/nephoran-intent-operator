# =============================================================================
# Container Build & Publish Pipeline - 2025 Edition
# =============================================================================
# Multi-arch container builds for Nephoran Intent Operator
# Optimized for 30+ binaries with intelligent layering and caching
# =============================================================================

name: Container Build - 2025

on:
  push:
    branches: [ main, integrate/mvp ]
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - 'cmd/**'
      - 'api/**'
      - 'controllers/**'
      - 'Dockerfile*'
      - '.github/workflows/container-build-2025.yml'
  pull_request:
    branches: [ main, integrate/mvp ]
    types: [ opened, synchronize, reopened, ready_for_review ]
  release:
    types: [ published ]
  workflow_dispatch:
    inputs:
      build_mode:
        description: 'Container build mode'
        type: choice
        options: ['fast', 'full', 'release']
        default: 'fast'
      push_images:
        description: 'Push images to registry'
        type: boolean
        default: true
      build_platforms:
        description: 'Target platforms'
        type: choice
        options: ['linux/amd64', 'linux/amd64,linux/arm64', 'all-platforms']
        default: 'linux/amd64'

concurrency:
  group: container-build-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write
  security-events: write
  attestations: write
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}/nephoran
  GO_VERSION: "1.25"
  BUILD_MODE: ${{ github.event.inputs.build_mode || 'fast' }}
  PUSH_IMAGES: ${{ github.event.inputs.push_images != 'false' }}
  
  # Platform configuration
  DEFAULT_PLATFORMS: "linux/amd64"
  MULTI_PLATFORMS: "linux/amd64,linux/arm64"
  ALL_PLATFORMS: "linux/amd64,linux/arm64,linux/arm64/v8"

jobs:
  # =============================================================================
  # SETUP: Container build strategy and binary preparation
  # =============================================================================
  setup:
    name: Container Setup & Strategy
    runs-on: ubuntu-22.04
    timeout-minutes: 8
    outputs:
      should-build: ${{ steps.changes.outputs.should-build }}
      build-matrix: ${{ steps.matrix.outputs.matrix }}
      platforms: ${{ steps.platforms.outputs.platforms }}
      image-tags: ${{ steps.tags.outputs.tags }}
      cache-key: ${{ steps.cache.outputs.key }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect container-relevant changes
        id: changes
        run: |
          if [[ "${{ github.event_name }}" == "release" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "Manual/release build - forcing container build"
          else
            # Check for relevant changes
            changed_files=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only HEAD~1 2>/dev/null || echo "")
            
            if echo "$changed_files" | grep -qE '\.(go|mod|sum)$|^(cmd|api|controllers|pkg)/|Dockerfile'; then
              echo "should-build=true" >> $GITHUB_OUTPUT
              echo "Container-relevant changes detected"
            else
              echo "should-build=false" >> $GITHUB_OUTPUT
              echo "No container-relevant changes"
            fi
          fi

      - name: Determine build platforms
        id: platforms
        run: |
          case "${{ github.event.inputs.build_platforms || 'linux/amd64' }}" in
            "linux/amd64")
              platforms="${{ env.DEFAULT_PLATFORMS }}"
              ;;
            "linux/amd64,linux/arm64")
              platforms="${{ env.MULTI_PLATFORMS }}"
              ;;
            "all-platforms")
              platforms="${{ env.ALL_PLATFORMS }}"
              ;;
            *)
              platforms="${{ env.DEFAULT_PLATFORMS }}"
              ;;
          esac
          
          echo "platforms=$platforms" >> $GITHUB_OUTPUT
          echo "Selected build platforms: $platforms"

      - name: Generate image tags
        id: tags
        run: |
          echo "üè∑Ô∏è Generating image tags..."
          
          # Base tag strategy
          if [[ "${{ github.event_name }}" == "release" ]]; then
            # Release: use release tag + latest
            RELEASE_TAG=${{ github.event.release.tag_name }}
            TAGS="$RELEASE_TAG,latest"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Main branch: use 'main' + sha
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-8)
            TAGS="main,sha-$SHORT_SHA"
          elif [[ "${{ github.ref }}" == "refs/heads/integrate/mvp" ]]; then
            # Integration branch: use 'mvp' + sha
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-8)
            TAGS="mvp,mvp-$SHORT_SHA"
          else
            # Feature/fix branches: use branch name + sha
            BRANCH_NAME=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9._-]/-/g' | tr '[:upper:]' '[:lower:]')
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-8)
            TAGS="$BRANCH_NAME,sha-$SHORT_SHA"
          fi
          
          # Add build mode suffix for non-production builds
          if [[ "$BUILD_MODE" != "release" && "${{ github.event_name }}" != "release" ]]; then
            TAGS="$(echo "$TAGS" | sed "s/,/-$BUILD_MODE,/g" | sed "s/$/-$BUILD_MODE/")"
          fi
          
          echo "Generated tags: $TAGS"
          echo "tags=$TAGS" >> $GITHUB_OUTPUT

      - name: Generate container build matrix
        id: matrix
        run: |
          case "$BUILD_MODE" in
            "fast")
              # Fast mode: Build only critical containers
              matrix='{
                "include": [
                  {
                    "name": "intent-ingest",
                    "dockerfile": "cmd/intent-ingest/Dockerfile",
                    "context": ".",
                    "binary": "intent-ingest",
                    "priority": "critical"
                  },
                  {
                    "name": "conductor-loop", 
                    "dockerfile": "cmd/conductor-loop/Dockerfile",
                    "context": ".",
                    "binary": "conductor-loop",
                    "priority": "critical"
                  },
                  {
                    "name": "llm-processor",
                    "dockerfile": "cmd/llm-processor/Dockerfile", 
                    "context": ".",
                    "binary": "llm-processor",
                    "priority": "critical"
                  },
                  {
                    "name": "webhook",
                    "dockerfile": "cmd/webhook/Dockerfile",
                    "context": ".",
                    "binary": "webhook",
                    "priority": "high"
                  }
                ]
              }'
              ;;
            "full")
              # Full mode: Build all major services
              matrix='{
                "include": [
                  {
                    "name": "intent-ingest",
                    "dockerfile": "cmd/intent-ingest/Dockerfile",
                    "context": ".",
                    "binary": "intent-ingest",
                    "priority": "critical"
                  },
                  {
                    "name": "conductor-loop",
                    "dockerfile": "cmd/conductor-loop/Dockerfile", 
                    "context": ".",
                    "binary": "conductor-loop",
                    "priority": "critical"
                  },
                  {
                    "name": "llm-processor",
                    "dockerfile": "cmd/llm-processor/Dockerfile",
                    "context": ".",
                    "binary": "llm-processor", 
                    "priority": "critical"
                  },
                  {
                    "name": "webhook",
                    "dockerfile": "cmd/webhook/Dockerfile",
                    "context": ".",
                    "binary": "webhook",
                    "priority": "high"
                  },
                  {
                    "name": "porch-publisher",
                    "dockerfile": "cmd/porch-publisher/Dockerfile",
                    "context": ".",
                    "binary": "porch-publisher",
                    "priority": "high"
                  },
                  {
                    "name": "conductor",
                    "dockerfile": "cmd/conductor/Dockerfile",
                    "context": ".",
                    "binary": "conductor",
                    "priority": "medium"
                  },
                  {
                    "name": "a1-sim",
                    "dockerfile": "cmd/a1-sim/Dockerfile",
                    "context": ".",
                    "binary": "a1-sim",
                    "priority": "medium"
                  },
                  {
                    "name": "e2-kpm-sim",
                    "dockerfile": "cmd/e2-kpm-sim/Dockerfile",
                    "context": ".",
                    "binary": "e2-kpm-sim", 
                    "priority": "medium"
                  }
                ]
              }'
              ;;
            "release")
              # Release mode: Build comprehensive set for production
              matrix='{
                "include": [
                  {
                    "name": "intent-ingest",
                    "dockerfile": "cmd/intent-ingest/Dockerfile",
                    "context": ".",
                    "binary": "intent-ingest",
                    "priority": "critical"
                  },
                  {
                    "name": "conductor-loop",
                    "dockerfile": "cmd/conductor-loop/Dockerfile",
                    "context": ".",
                    "binary": "conductor-loop", 
                    "priority": "critical"
                  },
                  {
                    "name": "llm-processor", 
                    "dockerfile": "cmd/llm-processor/Dockerfile",
                    "context": ".",
                    "binary": "llm-processor",
                    "priority": "critical"
                  },
                  {
                    "name": "webhook",
                    "dockerfile": "cmd/webhook/Dockerfile",
                    "context": ".",
                    "binary": "webhook",
                    "priority": "critical"
                  },
                  {
                    "name": "porch-publisher",
                    "dockerfile": "cmd/porch-publisher/Dockerfile", 
                    "context": ".",
                    "binary": "porch-publisher",
                    "priority": "high"
                  },
                  {
                    "name": "conductor",
                    "dockerfile": "cmd/conductor/Dockerfile",
                    "context": ".",
                    "binary": "conductor",
                    "priority": "high"
                  },
                  {
                    "name": "nephio-bridge",
                    "dockerfile": "cmd/nephio-bridge/Dockerfile",
                    "context": ".", 
                    "binary": "nephio-bridge",
                    "priority": "high"
                  },
                  {
                    "name": "a1-sim",
                    "dockerfile": "cmd/a1-sim/Dockerfile",
                    "context": ".",
                    "binary": "a1-sim",
                    "priority": "medium"
                  },
                  {
                    "name": "e2-kpm-sim",
                    "dockerfile": "cmd/e2-kpm-sim/Dockerfile",
                    "context": ".",
                    "binary": "e2-kpm-sim",
                    "priority": "medium"
                  },
                  {
                    "name": "fcaps-sim",
                    "dockerfile": "cmd/fcaps-sim/Dockerfile",
                    "context": ".",
                    "binary": "fcaps-sim",
                    "priority": "medium"
                  },
                  {
                    "name": "o1-ves-sim", 
                    "dockerfile": "cmd/o1-ves-sim/Dockerfile",
                    "context": ".",
                    "binary": "o1-ves-sim",
                    "priority": "medium"
                  }
                ]
              }'
              ;;
          esac
          
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

      - name: Generate cache key
        id: cache
        run: |
          # Container-specific cache key
          CACHE_KEY="container-v3-$(echo '${{ runner.os }}-${{ env.GO_VERSION }}-${{ hashFiles('go.sum', 'go.mod') }}' | sha256sum | cut -c1-16)"
          echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT

  # =============================================================================
  # BUILD BINARIES: Cross-platform binary compilation
  # =============================================================================
  build-binaries:
    name: Build Binaries - ${{ matrix.name }}
    runs-on: ubuntu-22.04
    needs: setup
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 15
    
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Create binary output directories
        run: |
          mkdir -p bin/linux/amd64 bin/linux/arm64 dist/

      - name: Build multi-arch binaries
        run: |
          echo "üî® Building ${{ matrix.binary }} for multiple architectures..."
          
          # Build flags optimized for containers
          BUILD_FLAGS="-trimpath -ldflags=-s -w -extldflags=-static"
          BUILD_TAGS="netgo,osusergo,static_build"
          
          # Parse target platforms
          IFS=',' read -ra PLATFORMS <<< "${{ needs.setup.outputs.platforms }}"
          
          for platform in "${PLATFORMS[@]}"; do
            echo "Building for platform: $platform"
            
            # Extract OS and ARCH
            os=$(echo "$platform" | cut -d'/' -f1)
            arch=$(echo "$platform" | cut -d'/' -f2)
            
            # Handle arm64 variants
            if [[ "$arch" == "arm64/v8" ]]; then
              arch="arm64"
            fi
            
            echo "OS: $os, ARCH: $arch"
            
            # Set environment and build
            export GOOS="$os"
            export GOARCH="$arch"
            export CGO_ENABLED=0
            
            output_dir="bin/$os/$arch"
            mkdir -p "$output_dir"
            
            if timeout 600s go build $BUILD_FLAGS -tags="$BUILD_TAGS" \
              -o "$output_dir/${{ matrix.binary }}" "./cmd/${{ matrix.binary }}"; then
              echo "‚úÖ Built ${{ matrix.binary }} for $platform"
              
              # Verify binary
              file "$output_dir/${{ matrix.binary }}"
              ls -lh "$output_dir/${{ matrix.binary }}"
            else
              echo "‚ùå Failed to build ${{ matrix.binary }} for $platform"
              exit 1
            fi
          done

      - name: Upload binary artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.name }}-${{ github.run_number }}
          path: bin/
          retention-days: 7
          compression-level: 6

  # =============================================================================
  # CREATE DOCKERFILES: Generate optimized Dockerfiles
  # =============================================================================
  create-dockerfiles:
    name: Generate Optimized Dockerfiles
    runs-on: ubuntu-22.04
    needs: setup
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate optimized Dockerfiles
        run: |
          echo "üê≥ Generating optimized Dockerfiles..."
          
          # Create Dockerfiles directory
          mkdir -p .dockerfiles
          
          # Base Dockerfile template for Go binaries
          cat > .dockerfiles/Dockerfile.template << 'EOF'
          # =============================================================================
          # Multi-stage Dockerfile for Nephoran Components - 2025 Optimized
          # =============================================================================
          
          # Stage 1: Base runtime image with security updates
          FROM gcr.io/distroless/static-debian12:nonroot AS runtime-base
          
          # Stage 2: Binary stage - copy pre-built binary
          FROM runtime-base AS binary-stage
          
          # Copy binary for target architecture
          ARG TARGETPLATFORM
          ARG BINARY_NAME
          
          # Create necessary directories
          USER root
          RUN mkdir -p /app/bin /app/config /app/logs /tmp
          
          # Copy binary based on target platform
          COPY --chown=nonroot:nonroot bin/${TARGETPLATFORM}/${BINARY_NAME} /app/bin/${BINARY_NAME}
          
          # Make binary executable
          RUN chmod +x /app/bin/${BINARY_NAME}
          
          # Stage 3: Final runtime stage
          FROM runtime-base AS final
          
          ARG BINARY_NAME
          ARG VERSION=dev
          ARG BUILD_DATE
          ARG VCS_REF
          
          # Metadata labels following OpenContainer spec
          LABEL org.opencontainers.image.title="Nephoran ${BINARY_NAME}"
          LABEL org.opencontainers.image.description="Nephoran Intent Operator - ${BINARY_NAME} component"
          LABEL org.opencontainers.image.version="${VERSION}"
          LABEL org.opencontainers.image.created="${BUILD_DATE}"
          LABEL org.opencontainers.image.revision="${VCS_REF}"
          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.url="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.vendor="Nephoran Project"
          LABEL org.opencontainers.image.licenses="Apache-2.0"
          
          # Copy from binary stage
          COPY --from=binary-stage --chown=nonroot:nonroot /app/bin/${BINARY_NAME} /usr/local/bin/${BINARY_NAME}
          
          # Set up runtime environment
          USER nonroot:nonroot
          WORKDIR /app
          
          # Health check (customize per service)
          # HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
          #   CMD ["/usr/local/bin/${BINARY_NAME}", "healthcheck"] || exit 1
          
          # Default command
          ENTRYPOINT ["/usr/local/bin/${BINARY_NAME}"]
          CMD ["--help"]
          EOF
          
          # Generate individual Dockerfiles for each component
          components='${{ needs.setup.outputs.build-matrix }}' 
          echo "$components" | jq -r '.include[] | "\(.name):\(.binary)"' | while IFS=: read -r name binary; do
            echo "Generating Dockerfile for $name ($binary)..."
            
            dockerfile_path="cmd/$name/Dockerfile"
            mkdir -p "cmd/$name"
            
            # Copy template and customize
            cp .dockerfiles/Dockerfile.template "$dockerfile_path"
            
            # Add service-specific customizations
            case "$binary" in
              "intent-ingest"|"llm-processor")
                # These services need network access
                echo "EXPOSE 8080" >> "$dockerfile_path"
                ;;
              "webhook")
                # Webhook needs TLS ports
                echo "EXPOSE 8443" >> "$dockerfile_path"
                ;;
              "*-sim")
                # Simulators might need custom ports
                echo "EXPOSE 9090" >> "$dockerfile_path"
                ;;
            esac
            
            echo "‚úÖ Generated Dockerfile for $name"
          done

      - name: Upload Dockerfiles
        uses: actions/upload-artifact@v4
        with:
          name: dockerfiles-${{ github.run_number }}
          path: cmd/*/Dockerfile
          retention-days: 7

  # =============================================================================
  # BUILD CONTAINERS: Multi-arch container building with BuildKit
  # =============================================================================
  build-containers:
    name: Build Container - ${{ matrix.name }}
    runs-on: ubuntu-22.04
    needs: [setup, build-binaries, create-dockerfiles]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 20
    
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download binary artifacts
        uses: actions/download-artifact@v4
        with:
          name: binaries-${{ matrix.name }}-${{ github.run_number }}
          path: .

      - name: Download Dockerfiles
        uses: actions/download-artifact@v4
        with:
          name: dockerfiles-${{ github.run_number }}
          path: .

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
          buildkitd-flags: |
            --allow-insecure-entitlement security.insecure
            --allow-insecure-entitlement network.host

      - name: Login to Container Registry
        if: env.PUSH_IMAGES == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_PREFIX }}-${{ matrix.name }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.setup.outputs.image-tags }}

      - name: Build and push container image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: cmd/${{ matrix.name }}/Dockerfile
          platforms: ${{ needs.setup.outputs.platforms }}
          push: ${{ env.PUSH_IMAGES }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            BINARY_NAME=${{ matrix.binary }}
            VERSION=${{ github.ref_name }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
          cache-from: type=gha,scope=nephoran-${{ matrix.name }}
          cache-to: type=gha,mode=max,scope=nephoran-${{ matrix.name }}
          provenance: true
          sbom: true

      - name: Generate container report
        run: |
          echo "# Container Build Report - ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.IMAGE_PREFIX }}-${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Binary:** ${{ matrix.binary }}" >> $GITHUB_STEP_SUMMARY
          echo "**Platforms:** ${{ needs.setup.outputs.platforms }}" >> $GITHUB_STEP_SUMMARY
          echo "**Priority:** ${{ matrix.priority }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:** ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "**Pushed:** ${{ env.PUSH_IMAGES }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # CONTAINER SECURITY: Security scanning for built images
  # =============================================================================
  container-security:
    name: Container Security Scan - ${{ matrix.name }}
    runs-on: ubuntu-22.04
    needs: [setup, build-containers]
    if: needs.setup.outputs.should-build == 'true' && env.BUILD_MODE != 'fast'
    timeout-minutes: 10
    
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_PREFIX }}-${{ matrix.name }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.name }}.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results-${{ matrix.name }}.sarif'
          category: trivy-${{ matrix.name }}
        continue-on-error: true

      - name: Generate security summary
        run: |
          echo "## Container Security - ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Scanner:** Trivy" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.IMAGE_PREFIX }}-${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Scan completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # CONTAINER SUMMARY: Build results and deployment readiness
  # =============================================================================
  container-summary:
    name: Container Build Summary
    runs-on: ubuntu-22.04
    needs: [setup, build-binaries, build-containers, container-security]
    if: always() && needs.setup.outputs.should-build == 'true'
    timeout-minutes: 5

    steps:
      - name: Generate comprehensive build summary
        run: |
          echo "# üê≥ Nephoran Container Build Summary - 2025" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build Date:** $(date -u +"%Y-%m-%d %H:%M UTC")" >> $GITHUB_STEP_SUMMARY
          echo "**Build Mode:** ${{ env.BUILD_MODE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Platforms:** ${{ needs.setup.outputs.platforms }}" >> $GITHUB_STEP_SUMMARY
          echo "**Registry:** ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
          echo "**Push Enabled:** ${{ env.PUSH_IMAGES }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üìä Build Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Binary Build | Container Build | Security Scan |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------------|-----------------|---------------|" >> $GITHUB_STEP_SUMMARY
          
          # Parse matrix to show results
          components='${{ needs.setup.outputs.build-matrix }}'
          echo "$components" | jq -r '.include[] | .name' | while read -r name; do
            binary_status="${{ needs.build-binaries.result }}"
            container_status="${{ needs.build-containers.result }}" 
            security_status="${{ needs.container-security.result || 'skipped' }}"
            echo "| $name | $binary_status | $container_status | $security_status |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üöÄ Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.build-containers.result }}" == "success" ]]; then
            echo "### Container Images Ready" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            components='${{ needs.setup.outputs.build-matrix }}'
            echo "$components" | jq -r '.include[] | .name' | while read -r name; do
              image_name="${{ env.IMAGE_PREFIX }}-$name"
              tags="${{ needs.setup.outputs.image-tags }}"
              echo "- **$name**: \`$image_name:$tags\`" >> $GITHUB_STEP_SUMMARY
            done
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Pull Commands" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            
            components='${{ needs.setup.outputs.build-matrix }}'
            echo "$components" | jq -r '.include[] | .name' | while read -r name; do
              primary_tag=$(echo "${{ needs.setup.outputs.image-tags }}" | cut -d',' -f1)
              echo "docker pull ${{ env.IMAGE_PREFIX }}-$name:$primary_tag" >> $GITHUB_STEP_SUMMARY
            done
            
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "### Kubernetes Deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Images are ready for Kubernetes deployment with:" >> $GITHUB_STEP_SUMMARY
            echo "- Multi-architecture support: ${{ needs.setup.outputs.platforms }}" >> $GITHUB_STEP_SUMMARY
            echo "- Distroless base images for minimal attack surface" >> $GITHUB_STEP_SUMMARY
            echo "- Non-root user execution for security" >> $GITHUB_STEP_SUMMARY
            echo "- SBOM and provenance attestations included" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Container build failed**" >> $GITHUB_STEP_SUMMARY
            echo "Check the build logs for specific errors." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Determine final status
        run: |
          if [[ "${{ needs.build-binaries.result }}" != "success" ]]; then
            echo "‚ùå Binary build failed"
            exit 1
          elif [[ "${{ needs.build-containers.result }}" != "success" ]]; then
            echo "‚ùå Container build failed"
            exit 1
          else
            echo "‚úÖ Container build pipeline completed successfully"
            
            if [[ "${{ env.PUSH_IMAGES }}" == "true" ]]; then
              echo "üöÄ Container images are available in ${{ env.REGISTRY }}"
            else
              echo "üì¶ Container images built locally (push disabled)"
            fi
          fi