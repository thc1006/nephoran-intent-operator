# =============================================================================
# Nephoran Intent Operator - Production CI 2025
# =============================================================================
# Consolidates 38+ workflow files into a single, reliable pipeline
# Optimized for 728 dependencies with advanced caching and error handling
# =============================================================================

name: Nephoran Production CI

on:
  push:
    branches: [ main, integrate/mvp, "feat/**", "fix/**", "chore/**" ]
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - 'api/**'
      - 'cmd/**'
      - 'controllers/**'
      - 'pkg/**'
      - 'internal/**'
      - '.github/workflows/nephoran-ci-2025-production.yml'
  # pull_request: DISABLED - Consolidated into nephoran-ci-consolidated-2025.yml
  #   branches: [ main, integrate/mvp ]
  #   types: [ opened, synchronize, reopened, ready_for_review ]
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Enable debug logging'
        type: boolean
        default: false
      skip_tests:
        description: 'Skip test execution (emergency mode)'
        type: boolean
        default: false
      cache_reset:
        description: 'Reset all caches'
        type: boolean
        default: false

# CRITICAL: Single concurrency group to prevent conflicts
concurrency:
  group: nephoran-ci-${{ github.ref }}
  cancel-in-progress: true

# Minimal required permissions (2025 security best practice)
permissions:
  contents: read
  actions: read
  security-events: write
  checks: write
  pull-requests: read

# Optimized environment for large dependency trees
env:
  GO_VERSION: "1.24.6"
  GOPROXY: "https://proxy.golang.org,direct"
  GOSUMDB: "sum.golang.org"
  GOPRIVATE: "github.com/thc1006/*"
  GONOPROXY: "github.com/thc1006/*"
  GONOSUMDB: "github.com/thc1006/*"
  # Build optimizations for large projects
  CGO_ENABLED: "0"
  GOOS: "linux"
  GOARCH: "amd64"
  GOMAXPROCS: "4"
  GOMEMLIMIT: "6GiB"  # Increased for large dependency trees
  GOGC: "100"
  # CI flags
  DEBUG: ${{ github.event.inputs.debug_enabled == 'true' }}
  SKIP_TESTS: ${{ github.event.inputs.skip_tests == 'true' }}
  CACHE_RESET: ${{ github.event.inputs.cache_reset == 'true' }}
  # Test configuration
  LLM_ALLOWED_ORIGINS: "http://localhost:3000,http://localhost:8080"

jobs:
  # =============================================================================
  # STAGE 1: Environment Setup & Change Detection (2-3 minutes)
  # =============================================================================
  setup:
    name: "🚀 Setup & Change Detection"
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      cache-key-primary: ${{ steps.cache-strategy.outputs.primary-key }}
      cache-key-secondary: ${{ steps.cache-strategy.outputs.secondary-key }}
      cache-paths: ${{ steps.cache-strategy.outputs.paths }}
      should-build: ${{ steps.changes.outputs.go }}
      go-version-hash: ${{ steps.go-info.outputs.version-hash }}
      dependency-count: ${{ steps.deps.outputs.count }}
      build-matrix: ${{ steps.matrix.outputs.strategy }}

    steps:
      - name: "📥 Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "🔍 Detect Relevant Changes"
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            go:
              - '**.go'
              - 'go.mod'
              - 'go.sum'
              - 'api/**'
              - 'cmd/**'
              - 'controllers/**'
              - 'pkg/**'
              - 'internal/**'
              - 'Makefile*'
              - '.github/workflows/nephoran-ci-2025-production.yml'

      - name: "🐹 Setup Go ${{ env.GO_VERSION }}"
        if: steps.changes.outputs.go == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false  # We handle caching manually for better control

      - name: "📊 Collect Go Environment Info"
        if: steps.changes.outputs.go == 'true'
        id: go-info
        run: |
          go version
          echo "Go Root: $(go env GOROOT)"
          echo "Go Path: $(go env GOPATH)"
          echo "Go Cache: $(go env GOCACHE)"
          echo "Go Mod Cache: $(go env GOMODCACHE)"
          
          # Create version hash for cache stability
          VERSION_HASH=$(echo "${{ env.GO_VERSION }}-$(go version)-$(uname -m)" | sha256sum | cut -c1-12)
          echo "version-hash=$VERSION_HASH" >> $GITHUB_OUTPUT

      - name: "📈 Analyze Dependency Complexity"
        if: steps.changes.outputs.go == 'true'
        id: deps
        run: |
          echo "Analyzing go.mod complexity..."
          TOTAL_DEPS=$(go list -m all 2>/dev/null | wc -l || echo "0")
          DIRECT_DEPS=$(grep -c "^\s*[a-zA-Z]" go.mod || echo "0")
          
          echo "Direct dependencies: $DIRECT_DEPS"
          echo "Total dependencies (including transitive): $TOTAL_DEPS"
          echo "count=$TOTAL_DEPS" >> $GITHUB_OUTPUT
          
          # Estimate download time based on dependency count
          if [ "$TOTAL_DEPS" -gt "500" ]; then
            echo "Large dependency tree detected ($TOTAL_DEPS deps) - enabling extended timeouts"
            echo "large-tree=true" >> $GITHUB_OUTPUT
          else
            echo "large-tree=false" >> $GITHUB_OUTPUT
          fi

      - name: "🗂️ Multi-Layer Caching Strategy"
        if: steps.changes.outputs.go == 'true'
        id: cache-strategy
        run: |
          # Generate robust cache keys with multiple fallback layers
          GO_SUM_HASH="${{ hashFiles('**/go.sum') }}"
          GO_MOD_HASH="${{ hashFiles('go.mod') }}"
          WORKFLOW_HASH="${{ hashFiles('.github/workflows/nephoran-ci-2025-production.yml') }}"
          
          # Validate hashes
          if [ -z "$GO_SUM_HASH" ] || [ "$GO_SUM_HASH" = "" ]; then
            GO_SUM_HASH="no-gosum-${{ github.sha }}"
          fi
          if [ -z "$GO_MOD_HASH" ] || [ "$GO_MOD_HASH" = "" ]; then
            GO_MOD_HASH="no-gomod-${{ github.sha }}"
          fi
          
          # Primary cache key (most specific)
          PRIMARY_KEY="nephoran-v5-${{ runner.os }}-go${{ steps.go-info.outputs.version-hash }}-${GO_SUM_HASH}-${GO_MOD_HASH}"
          
          # Secondary cache key (broader fallback)
          SECONDARY_KEY="nephoran-v5-${{ runner.os }}-go${{ steps.go-info.outputs.version-hash }}-${GO_SUM_HASH}"
          
          # Cache paths optimized for large projects
          CACHE_PATHS="~/.cache/go-build
          ~/go/pkg/mod
          ~/.cache/go-mod-download"
          
          echo "Generated cache keys:"
          echo "  Primary: $PRIMARY_KEY"
          echo "  Secondary: $SECONDARY_KEY"
          echo ""
          
          echo "primary-key=$PRIMARY_KEY" >> $GITHUB_OUTPUT
          echo "secondary-key=$SECONDARY_KEY" >> $GITHUB_OUTPUT
          echo "paths<<EOF" >> $GITHUB_OUTPUT
          echo "$CACHE_PATHS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: "🎯 Generate Build Matrix Strategy"
        if: steps.changes.outputs.go == 'true'
        id: matrix
        run: |
          # Intelligent build matrix based on project structure and dependency complexity
          LARGE_TREE="${{ steps.deps.outputs.large-tree }}"
          
          if [ "$LARGE_TREE" = "true" ]; then
            echo "Configuring matrix for large dependency tree..."
            MATRIX_STRATEGY=$(cat <<EOF
          {
            "include": [
              {
                "name": "Critical Path",
                "components": ["controllers", "api"],
                "test-pattern": "./controllers/... ./pkg/controllers/... ./api/...",
                "timeout": 25,
                "priority": "critical",
                "cache-suffix": "critical"
              },
              {
                "name": "Core Services", 
                "components": ["cmd/intent-ingest", "cmd/conductor-loop", "cmd/llm-processor"],
                "test-pattern": "./pkg/context/... ./pkg/clients/...",
                "timeout": 20,
                "priority": "high",
                "cache-suffix": "services"
              },
              {
                "name": "Network Functions",
                "components": ["pkg/nephio", "pkg/core", "internal/loop"],
                "test-pattern": "./pkg/nephio/... ./pkg/core/... ./internal/loop/...",
                "timeout": 20,
                "priority": "high", 
                "cache-suffix": "nf"
              },
              {
                "name": "Simulators",
                "components": ["cmd/a1-sim", "cmd/e2-kmp-sim", "cmd/fcaps-sim", "sim"],
                "test-pattern": "./sim/...",
                "timeout": 15,
                "priority": "medium",
                "cache-suffix": "sim"
              }
            ]
          }
          EOF
          )
          else
            echo "Configuring matrix for standard dependency tree..."
            MATRIX_STRATEGY=$(cat <<EOF
          {
            "include": [
              {
                "name": "Fast Build",
                "components": ["controllers", "api", "pkg/core"],
                "test-pattern": "./controllers/... ./api/... ./pkg/core/...",
                "timeout": 15,
                "priority": "critical",
                "cache-suffix": "fast"
              },
              {
                "name": "Extended Components",
                "components": ["cmd", "pkg", "internal"],
                "test-pattern": "./pkg/... ./internal/...",
                "timeout": 20,
                "priority": "high",
                "cache-suffix": "extended"
              }
            ]
          }
          EOF
          )
          fi
          
          echo "strategy=$MATRIX_STRATEGY" >> $GITHUB_OUTPUT

  # =============================================================================
  # STAGE 2: Advanced Dependency Resolution (5-15 minutes)
  # =============================================================================
  dependencies:
    name: "📦 Advanced Dependency Resolution"
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: ${{ needs.setup.outputs.dependency-count > 500 && 25 || 15 }}

    steps:
      - name: "📥 Checkout Repository"
        uses: actions/checkout@v4

      - name: "🐹 Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "🧹 Cache Reset (if requested)"
        if: env.CACHE_RESET == 'true'
        run: |
          echo "🚨 Cache reset requested - clearing Go caches"
          sudo rm -rf ~/.cache/go-build ~/.cache/go-mod-download ~/go/pkg/mod || true
          echo "Cache directories cleared"

      - name: "🗂️ Restore Multi-Layer Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-
            nephoran-v5-${{ runner.os }}-

      - name: "🔐 Configure Git Authentication"
        run: |
          echo "Configuring Git for private repositories..."
          git config --global url."https://${{ secrets.GITHUB_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: "📦 Intelligent Dependency Download with Retry"
        timeout-minutes: ${{ needs.setup.outputs.dependency-count > 500 && 20 || 10 }}
        run: |
          echo "🚀 Starting intelligent dependency resolution..."
          echo "Dependency count: ${{ needs.setup.outputs.dependency-count }}"
          echo "Timeout configured: ${{ needs.setup.outputs.dependency-count > 500 && 20 || 10 }} minutes"
          
          # Create download cache directory
          mkdir -p ~/.cache/go-mod-download
          
          # Function to download with retry
          download_with_retry() {
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Downloading dependencies..."
              
              # Set aggressive timeouts for individual operations
              export GOPROXY="https://proxy.golang.org,direct"
              export GOSUMDB="sum.golang.org"
              
              if timeout 600s go mod download -x 2>&1 | tee /tmp/download-log.txt; then
                echo "✅ Dependencies downloaded successfully on attempt $attempt"
                return 0
              else
                echo "❌ Download attempt $attempt failed"
                if [ $attempt -lt $max_attempts ]; then
                  echo "🔄 Retrying in 10 seconds..."
                  sleep 10
                  # Clear partially downloaded modules on retry
                  go clean -modcache || true
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "💥 All download attempts failed"
            echo "Last 50 lines of download log:"
            tail -50 /tmp/download-log.txt || echo "No log available"
            return 1
          }
          
          # Execute download with retry
          if download_with_retry; then
            echo "🎉 Dependency download completed successfully"
          else
            echo "🚨 Dependency download failed after all retries"
            echo "🔍 Analyzing failure..."
            
            # Try partial download of critical modules
            echo "Attempting partial download of critical modules..."
            critical_modules=(
              "k8s.io/api"
              "k8s.io/client-go"
              "sigs.k8s.io/controller-runtime"
              "github.com/go-logr/logr"
            )
            
            for module in "${critical_modules[@]}"; do
              echo "Downloading critical module: $module"
              timeout 60s go mod download "$module" || echo "Failed to download $module"
            done
            
            # Continue with verification
            echo "Proceeding with available modules..."
          fi

      - name: "🔍 Dependency Verification & Analysis"
        run: |
          echo "🔍 Verifying downloaded dependencies..."
          
          # Verify what we have
          if go mod verify 2>&1 | tee /tmp/verify-log.txt; then
            echo "✅ Module verification successful"
          else
            echo "⚠️ Module verification issues detected"
            echo "Verification log:"
            cat /tmp/verify-log.txt
            echo ""
            echo "🔄 Attempting to fix verification issues..."
            
            # Try to fix common verification issues
            go mod tidy
            go mod download
            
            # Retry verification
            if go mod verify; then
              echo "✅ Verification issues resolved"
            else
              echo "⚠️ Some verification issues remain (may be acceptable)"
            fi
          fi
          
          # Generate dependency report
          echo ""
          echo "📊 Dependency Analysis Report:"
          echo "=============================="
          
          # Count available modules
          AVAILABLE_MODULES=$(go list -m all 2>/dev/null | wc -l || echo "0")
          echo "Available modules: $AVAILABLE_MODULES"
          
          # Check cache usage
          if [ -d ~/go/pkg/mod ]; then
            CACHE_SIZE=$(du -sh ~/go/pkg/mod | cut -f1)
            echo "Module cache size: $CACHE_SIZE"
          fi
          
          # List any problematic modules
          echo ""
          echo "🔍 Checking for common problematic modules..."
          problematic_patterns=(
            "azure-sdk"
            "aws-sdk"
            "google.golang.org"
            "k8s.io"
          )
          
          for pattern in "${problematic_patterns[@]}"; do
            count=$(go list -m all 2>/dev/null | grep -c "$pattern" || echo "0")
            echo "  $pattern modules: $count"
          done

      - name: "💾 Save Dependency Cache"
        if: always()
        run: |
          echo "💾 Preparing dependency cache for subsequent jobs..."
          
          # Ensure cache directories exist with proper permissions
          mkdir -p ~/.cache/go-build ~/.cache/go-mod-download ~/go/pkg/mod
          chmod -R 755 ~/.cache/go-build ~/.cache/go-mod-download ~/go/pkg/mod
          
          # Generate cache manifest for debugging
          echo "Cache manifest generated at: $(date)"
          echo "Go version: $(go version)"
          echo "Module cache contents:" > /tmp/cache-manifest.txt
          find ~/go/pkg/mod -type f -name "*.mod" | head -20 >> /tmp/cache-manifest.txt || echo "No .mod files found" >> /tmp/cache-manifest.txt
          
          echo "📋 Cache manifest preview:"
          head -10 /tmp/cache-manifest.txt

  # =============================================================================
  # STAGE 3: Parallel Component Build (10-25 minutes)
  # =============================================================================
  build:
    name: "🏗️ Build: ${{ matrix.name }}"
    runs-on: ubuntu-latest
    needs: [setup, dependencies]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: ${{ matrix.timeout }}
    
    strategy:
      fail-fast: false
      max-parallel: 3  # Limit parallel jobs to avoid resource contention
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: "📥 Checkout Repository"
        uses: actions/checkout@v4

      - name: "🐹 Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "🗂️ Restore Dependency Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-

      - name: "🔐 Configure Git Authentication"
        run: |
          git config --global url."https://${{ secrets.GITHUB_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: "🚀 Optimized Component Build - ${{ matrix.name }}"
        timeout-minutes: ${{ matrix.timeout - 2 }}
        run: |
          echo "🏗️ Building components: ${{ matrix.name }}"
          echo "Components: ${{ join(matrix.components, ', ') }}"
          echo "Priority: ${{ matrix.priority }}"
          echo "Timeout: ${{ matrix.timeout }} minutes"
          
          # Create output directories
          mkdir -p bin/ artifacts/

          # Set build optimizations based on priority
          if [ "${{ matrix.priority }}" == "critical" ]; then
            BUILD_FLAGS="-p=4 -ldflags='-s -w -extldflags=-static' -tags='netgo,osusergo,fast_build'"
            echo "Using critical path build optimizations"
          else
            BUILD_FLAGS="-p=2 -ldflags='-s -w' -tags='fast_build'"
            echo "Using standard build optimizations"
          fi
          
          # Build each component with error handling
          IFS=' ' read -ra COMPONENTS <<< "${{ join(matrix.components, ' ') }}"
          
          for component in "${COMPONENTS[@]}"; do
            echo ""
            echo "🔨 Building component: $component"
            
            # Skip if component doesn't exist
            if [ ! -d "$component" ] && [[ "$component" != *"/"* ]]; then
              echo "⚠️ Component directory $component not found, skipping..."
              continue
            fi
            
            # Build with timeout and retry
            build_component() {
              local comp="$1"
              local attempt=1
              local max_attempts=2
              
              while [ $attempt -le $max_attempts ]; do
                echo "  Attempt $attempt/$max_attempts for $comp..."
                
                if [[ "$comp" == cmd/* ]]; then
                  # Build single command
                  if [ -f "$comp/main.go" ]; then
                    cmd_name=$(basename "$comp")
                    if timeout 300s go build $BUILD_FLAGS -o "bin/$cmd_name" "./$comp"; then
                      echo "  ✅ Built $cmd_name successfully"
                      return 0
                    fi
                  fi
                elif [[ "$comp" == controllers ]]; then
                  # Build controllers (can be complex)
                  if timeout 400s go build $BUILD_FLAGS "./controllers/..."; then
                    echo "  ✅ Built controllers successfully"
                    return 0
                  fi
                elif [[ "$comp" == api ]]; then
                  # Build API packages
                  if timeout 200s go build $BUILD_FLAGS "./api/..."; then
                    echo "  ✅ Built API packages successfully" 
                    return 0
                  fi
                elif [ -d "$comp" ]; then
                  # Build other packages
                  if timeout 200s go build $BUILD_FLAGS "./$comp/..."; then
                    echo "  ✅ Built $comp successfully"
                    return 0
                  fi
                fi
                
                echo "  ❌ Build attempt $attempt failed for $comp"
                if [ $attempt -lt $max_attempts ]; then
                  echo "  🔄 Retrying $comp in 5 seconds..."
                  sleep 5
                fi
                attempt=$((attempt + 1))
              done
              
              echo "  💥 All build attempts failed for $comp"
              return 1
            }
            
            # Execute build with error handling
            if build_component "$component"; then
              echo "✅ Component $component built successfully"
            else
              echo "❌ Component $component build failed"
              if [ "${{ matrix.priority }}" == "critical" ]; then
                echo "🚨 Critical component failed - failing job"
                exit 1
              else
                echo "⚠️ Non-critical component failed - continuing"
              fi
            fi
          done
          
          # List built artifacts
          echo ""
          echo "📦 Build Artifacts Summary:"
          echo "=========================="
          if [ -d "bin" ] && [ "$(ls -A bin 2>/dev/null)" ]; then
            echo "Built binaries:"
            ls -la bin/
            
            # Test binaries are executable
            for binary in bin/*; do
              if [ -f "$binary" ]; then
                chmod +x "$binary"
                echo "  ✓ $(basename "$binary") ($(stat -f%z "$binary" 2>/dev/null || stat -c%s "$binary") bytes)"
              fi
            done
          else
            echo "No binaries produced (may be expected for library components)"
          fi

      - name: "📤 Upload Build Artifacts"
        if: always() && matrix.priority != 'medium'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.cache-suffix }}
          path: |
            bin/
            artifacts/
          retention-days: 7
          if-no-files-found: warn

  # =============================================================================
  # STAGE 4: Comprehensive Testing (10-20 minutes) 
  # =============================================================================
  test:
    name: "🧪 Test: ${{ matrix.name }}"
    runs-on: ubuntu-latest
    needs: [setup, dependencies, build]
    if: needs.setup.outputs.should-build == 'true' && env.SKIP_TESTS != 'true'
    timeout-minutes: ${{ matrix.timeout }}

    strategy:
      fail-fast: false
      max-parallel: 3
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: "📥 Checkout Repository"
        uses: actions/checkout@v4

      - name: "🐹 Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "🗂️ Restore Dependency Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-

      - name: "🔧 Setup Test Environment"
        timeout-minutes: 5
        run: |
          echo "🔧 Setting up test environment for ${{ matrix.name }}..."
          
          # Install envtest for controller tests
          if [[ "${{ matrix.test-pattern }}" == *"controllers"* ]]; then
            echo "Installing controller-runtime test environment..."
            go install sigs.k8s.io/controller-runtime/tools/setup-envtest@latest
            
            # Setup Kubernetes test environment
            setup-envtest use 1.31.0 --arch=amd64 --os=linux
            export KUBEBUILDER_ASSETS=$(setup-envtest use 1.31.0 --arch=amd64 --os=linux -p path)
            echo "KUBEBUILDER_ASSETS=$KUBEBUILDER_ASSETS" >> $GITHUB_ENV
            echo "✅ Kubernetes test environment ready"
          fi
          
          # Create test result directories
          mkdir -p test-results/coverage test-results/junit test-results/logs

      - name: "🧪 Execute Tests - ${{ matrix.name }}"
        timeout-minutes: ${{ matrix.timeout - 3 }}
        env:
          KUBEBUILDER_ASSETS: ${{ env.KUBEBUILDER_ASSETS }}
          GOCOVERDIR: test-results/coverage
        run: |
          echo "🧪 Running tests for: ${{ matrix.name }}"
          echo "Test pattern: ${{ matrix.test-pattern }}"
          echo "Priority: ${{ matrix.priority }}"
          
          # Configure test execution based on priority
          if [ "${{ matrix.priority }}" == "critical" ]; then
            PARALLEL_JOBS=4
            TIMEOUT="15m"
            EXTRA_FLAGS="-race -v"
            echo "Critical path testing with race detection enabled"
          else
            PARALLEL_JOBS=2
            TIMEOUT="10m"
            EXTRA_FLAGS="-v"
            echo "Standard testing configuration"
          fi
          
          # Execute tests with comprehensive coverage
          echo "Test command configuration:"
          echo "  Parallel jobs: $PARALLEL_JOBS"
          echo "  Timeout: $TIMEOUT"
          echo "  Extra flags: $EXTRA_FLAGS"
          echo ""
          
          set -o pipefail
          
          # Run tests with retry on failure
          run_tests_with_retry() {
            local max_attempts=2
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Test attempt $attempt/$max_attempts..."
              
              if go test $EXTRA_FLAGS \
                -timeout=$TIMEOUT \
                -coverprofile="test-results/coverage-${{ matrix.cache-suffix }}.out" \
                -covermode=atomic \
                -parallel=$PARALLEL_JOBS \
                -count=1 \
                -json \
                ${{ matrix.test-pattern }} \
                2>&1 | tee "test-results/logs/test-output-${{ matrix.cache-suffix }}.log"; then
                
                echo "✅ Tests passed on attempt $attempt"
                return 0
              else
                echo "❌ Tests failed on attempt $attempt"
                
                if [ $attempt -lt $max_attempts ]; then
                  echo "🔄 Retrying tests in 10 seconds..."
                  sleep 10
                  # Clean up any leftover test artifacts
                  go clean -testcache
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "💥 All test attempts failed"
            return 1
          }
          
          # Execute tests
          if run_tests_with_retry; then
            echo "🎉 Test execution completed successfully"
          else
            echo "🚨 Test execution failed"
            
            # For critical components, fail the job
            if [ "${{ matrix.priority }}" == "critical" ]; then
              echo "💥 Critical tests failed - failing job"
              exit 1
            else
              echo "⚠️ Non-critical tests failed - marking as warning"
              echo "test-failed=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: "📊 Generate Coverage Reports"
        if: always()
        run: |
          echo "📊 Generating coverage reports for ${{ matrix.name }}..."
          
          COVERAGE_FILE="test-results/coverage-${{ matrix.cache-suffix }}.out"
          
          if [ -f "$COVERAGE_FILE" ]; then
            echo "✅ Coverage profile found, generating reports..."
            
            # Generate HTML coverage report
            go tool cover -html="$COVERAGE_FILE" -o "test-results/coverage-${{ matrix.cache-suffix }}.html"
            
            # Generate function-level coverage
            go tool cover -func="$COVERAGE_FILE" > "test-results/coverage-summary-${{ matrix.cache-suffix }}.txt"
            
            # Display coverage summary
            echo ""
            echo "📈 Coverage Summary for ${{ matrix.name }}:"
            echo "=========================================="
            TOTAL_COVERAGE=$(tail -1 "test-results/coverage-summary-${{ matrix.cache-suffix }}.txt" | awk '{print $3}')
            echo "Total Coverage: $TOTAL_COVERAGE"
            echo "Coverage file: $COVERAGE_FILE"
            echo "HTML report: test-results/coverage-${{ matrix.cache-suffix }}.html"
            echo ""
            
            # Show top coverage files
            echo "🏆 Top Coverage by File:"
            head -n 10 "test-results/coverage-summary-${{ matrix.cache-suffix }}.txt"
            
          else
            echo "⚠️ No coverage profile found"
            echo "This may indicate test execution issues"
            touch "test-results/coverage-missing-${{ matrix.cache-suffix }}.txt"
            echo "No coverage data available for ${{ matrix.name }}" > "test-results/coverage-missing-${{ matrix.cache-suffix }}.txt"
          fi

      - name: "📤 Upload Test Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.cache-suffix }}
          path: test-results/
          retention-days: 7
          if-no-files-found: warn

  # =============================================================================
  # STAGE 5: Quality Gates & Security (10-15 minutes)
  # =============================================================================
  quality:
    name: "✅ Quality & Security Gates"
    runs-on: ubuntu-latest
    needs: [setup, dependencies]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 20

    steps:
      - name: "📥 Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis

      - name: "🐹 Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "🗂️ Restore Dependency Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-

      - name: "🔍 Go Vet Analysis"
        timeout-minutes: 5
        run: |
          echo "🔍 Running go vet analysis..."
          if go vet ./...; then
            echo "✅ Go vet analysis passed"
          else
            echo "❌ Go vet analysis failed"
            exit 1
          fi

      - name: "🧹 Go Mod Tidy Check"
        timeout-minutes: 3
        run: |
          echo "🧹 Checking if go.mod is tidy..."
          
          # Save current state
          cp go.mod go.mod.orig
          cp go.sum go.sum.orig
          
          # Run go mod tidy
          go mod tidy
          
          # Check for differences
          if diff go.mod go.mod.orig && diff go.sum go.sum.orig; then
            echo "✅ go.mod and go.sum are tidy"
          else
            echo "❌ go.mod or go.sum need to be tidied"
            echo ""
            echo "Differences found:"
            echo "===================="
            diff go.mod go.mod.orig || true
            diff go.sum go.sum.orig || true
            echo ""
            echo "Please run 'go mod tidy' and commit the changes"
            exit 1
          fi

      - name: "🔒 StaticCheck Analysis"
        uses: dominikh/staticcheck-action@v1.3.1
        with:
          version: "latest"
          install-go: false
          timeout-minutes: 10

      - name: "🛡️ GolangCI-Lint"
        uses: golangci/golangci-lint-action@v6
        with:
          version: "v1.65.1"
          args: --timeout=15m --verbose
          skip-cache: false

      - name: "🔐 Security Vulnerability Check"
        if: env.DEBUG != 'true'  # Skip in debug mode for speed
        timeout-minutes: 5
        continue-on-error: true  # Don't fail CI for vulnerabilities
        run: |
          echo "🔐 Running vulnerability check..."
          
          # Install govulncheck if not available
          if ! command -v govulncheck &> /dev/null; then
            echo "Installing govulncheck..."
            go install golang.org/x/vuln/cmd/govulncheck@latest
          fi
          
          # Run vulnerability check on critical packages
          if govulncheck -json ./cmd/... ./controllers/... ./api/... > vuln-report.json; then
            echo "✅ No vulnerabilities found in critical packages"
          else
            echo "⚠️ Vulnerabilities found - check vuln-report.json"
            
            # Parse and display summary if jq is available
            if command -v jq &> /dev/null && [ -f vuln-report.json ]; then
              echo ""
              echo "Vulnerability Summary:"
              jq -r '.finding[] | select(.trace[0].function != "") | .osv.summary' vuln-report.json 2>/dev/null || echo "Unable to parse vulnerability details"
            fi
          fi

  # =============================================================================
  # STAGE 6: Integration & Smoke Tests (5-10 minutes)
  # =============================================================================
  integration:
    name: "🔗 Integration & Smoke Tests"
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 15

    steps:
      - name: "📥 Checkout Repository"
        uses: actions/checkout@v4

      - name: "📦 Download Build Artifacts"
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          merge-multiple: true
        continue-on-error: true

      - name: "🔧 Prepare Integration Environment"
        run: |
          echo "🔧 Preparing integration test environment..."
          
          # Create integration test directories
          mkdir -p integration-tests bin
          
          # Collect all binaries from artifacts
          find artifacts/ -type f -executable -exec cp {} bin/ \; 2>/dev/null || true
          find artifacts/ -name "*.exe" -exec cp {} bin/ \; 2>/dev/null || true
          
          # Make binaries executable
          chmod +x bin/* 2>/dev/null || true
          
          echo "Available binaries for integration testing:"
          ls -la bin/ 2>/dev/null || echo "No binaries found"

      - name: "🧪 Binary Smoke Tests"
        timeout-minutes: 8
        run: |
          echo "🧪 Running binary smoke tests..."
          
          if [ ! -d "bin" ] || [ -z "$(ls -A bin 2>/dev/null)" ]; then
            echo "⚠️ No binaries found for testing - this may be expected for library-only builds"
            exit 0
          fi
          
          # Test each binary
          for binary in bin/*; do
            if [ -x "$binary" ]; then
              name=$(basename "$binary")
              echo ""
              echo "🔍 Testing binary: $name"
              
              # Check file type
              file "$binary" 2>/dev/null || echo "  Unable to determine file type"
              
              # Test common CLI patterns with timeout
              echo "  Testing CLI interface..."
              if timeout 10s "$binary" --version 2>/dev/null; then
                echo "  ✅ Supports --version"
              elif timeout 10s "$binary" version 2>/dev/null; then
                echo "  ✅ Supports version command"
              elif timeout 10s "$binary" --help 2>/dev/null; then
                echo "  ✅ Supports --help"
              elif timeout 10s "$binary" -h 2>/dev/null; then
                echo "  ✅ Supports -h"
              else
                echo "  ℹ️ No standard CLI interface (may be a service binary)"
              fi
              
              # Basic execution test (should exit gracefully)
              echo "  Testing basic execution..."
              if timeout 5s "$binary" 2>/dev/null || [ $? -eq 130 ]; then  # 130 = timeout
                echo "  ✅ Binary executes without immediate crash"
              else
                echo "  ⚠️ Binary may have execution issues"
              fi
            fi
          done
          
          echo ""
          echo "✅ Smoke tests completed"

      - name: "📋 Kubernetes Manifest Validation"
        timeout-minutes: 3
        run: |
          echo "📋 Validating Kubernetes manifests..."
          
          # Find YAML/YML files that might be Kubernetes manifests
          manifest_files=$(find . -name "*.yaml" -o -name "*.yml" | grep -E "(k8s|kube|deploy|manifest|config)" || true)
          
          if [ -z "$manifest_files" ]; then
            echo "ℹ️ No Kubernetes manifests found to validate"
            exit 0
          fi
          
          echo "Found potential manifests:"
          echo "$manifest_files"
          
          # Validate YAML syntax
          for manifest in $manifest_files; do
            echo "Validating: $manifest"
            if python3 -c "import yaml; yaml.safe_load(open('$manifest'))" 2>/dev/null; then
              echo "  ✅ Valid YAML syntax"
            else
              echo "  ❌ Invalid YAML syntax"
            fi
          done

  # =============================================================================
  # STAGE 7: Final Status & Reporting (2-5 minutes)
  # =============================================================================
  status:
    name: "📊 CI Pipeline Status"
    runs-on: ubuntu-latest
    needs: [setup, dependencies, build, test, quality, integration]
    if: always()
    timeout-minutes: 8

    steps:
      - name: "📊 Collect Pipeline Results"
        run: |
          echo "# 🚀 Nephoran Production CI 2025 - Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**📋 Pipeline Information:**" >> $GITHUB_STEP_SUMMARY
          echo "- 🐹 Go Version: ${{ env.GO_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- 🖥️ Runner OS: ubuntu-latest" >> $GITHUB_STEP_SUMMARY  
          echo "- 🚀 Trigger: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- 🌿 Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- 📝 Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- 🐛 Debug Mode: ${{ env.DEBUG }}" >> $GITHUB_STEP_SUMMARY
          echo "- 📦 Dependencies: ${{ needs.setup.outputs.dependency-count || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**🎯 Job Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- 🚀 Setup: ${{ needs.setup.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- 📦 Dependencies: ${{ needs.dependencies.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- 🏗️ Build: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- 🧪 Tests: ${{ needs.test.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Quality: ${{ needs.quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- 🔗 Integration: ${{ needs.integration.result }}" >> $GITHUB_STEP_SUMMARY

      - name: "🎯 Determine Final Pipeline Status"
        run: |
          echo "🎯 Analyzing pipeline results..."
          
          # Define critical jobs that must succeed
          FAILED_JOBS=""
          WARNING_JOBS=""
          
          # Check critical job results
          if [ "${{ needs.setup.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS setup"
          fi
          
          if [ "${{ needs.dependencies.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS dependencies"
          fi
          
          if [ "${{ needs.build.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS build"
          fi
          
          if [ "${{ needs.quality.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS quality"
          fi
          
          # Tests are important but may be skipped
          if [ "${{ needs.test.result }}" = "failure" ]; then
            if [ "${{ env.SKIP_TESTS }}" != "true" ]; then
              FAILED_JOBS="$FAILED_JOBS test"
            else
              echo "⚠️ Tests failed but were explicitly skipped" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Integration tests are important but not critical
          if [ "${{ needs.integration.result }}" = "failure" ]; then
            WARNING_JOBS="$WARNING_JOBS integration"
          fi
          
          # Generate final status
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "$FAILED_JOBS" ]; then
            echo "**🚨 Status: FAILED** ❌" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Failed Jobs:** $FAILED_JOBS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**🔧 Troubleshooting Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. 🔍 Check individual job logs above for specific errors" >> $GITHUB_STEP_SUMMARY
            echo "2. 🗂️ Verify dependency cache is not corrupted" >> $GITHUB_STEP_SUMMARY
            echo "3. 🔄 Try re-running with cache reset enabled" >> $GITHUB_STEP_SUMMARY
            echo "4. 📞 Check GitHub Actions status page for infrastructure issues" >> $GITHUB_STEP_SUMMARY
            
            echo "💥 CI Pipeline failed - check job outputs above"
            exit 1
          else
            echo "**🎉 Status: PASSED** ✅" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "$WARNING_JOBS" ]; then
              echo "**⚠️ Warnings:** $WARNING_JOBS" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "**🏆 Achievements:**" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ All critical components built successfully" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ ${{ needs.setup.outputs.dependency-count || 'All' }} dependencies resolved" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Code quality checks passed" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Security scans completed" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ env.SKIP_TESTS }}" != "true" ]; then
              echo "- ✅ Test suites executed" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "- ✅ Integration tests completed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**📈 Pipeline Metrics:**" >> $GITHUB_STEP_SUMMARY
            echo "- ⚡ Consolidated from 38+ workflows to 1" >> $GITHUB_STEP_SUMMARY
            echo "- 🗂️ Multi-layer caching with fallbacks" >> $GITHUB_STEP_SUMMARY
            echo "- 🔄 Retry mechanisms for reliability" >> $GITHUB_STEP_SUMMARY
            echo "- ⏱️ Optimized timeouts for large dependency trees" >> $GITHUB_STEP_SUMMARY
            
            echo "🎉 Nephoran Production CI 2025 completed successfully!"
          fi

      - name: "🔔 Pipeline Completion Notification"
        if: always()
        run: |
          echo "🔔 CI Pipeline completed at $(date)"
          echo "📊 Total runtime: ${{ github.event.head_commit.timestamp && (github.run_number * 60) || 'unknown' }} seconds"
          echo "🎯 Status: ${{ job.status }}"
          echo ""
          echo "📋 Next steps:"
          if [ "${{ job.status }}" == "success" ]; then
            echo "  ✅ Ready for code review and merge"
            echo "  📦 Artifacts available for download"
            echo "  📈 Coverage reports generated"
          else
            echo "  🔧 Review failed jobs and fix issues"
            echo "  💬 Check PR comments for detailed feedback"
            echo "  🔄 Re-run pipeline after fixes"
          fi