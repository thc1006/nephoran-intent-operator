# =============================================================================
# Nephoran Intent Operator - Production CI 2025
# =============================================================================
# Consolidates 38+ workflow files into a single, reliable pipeline
# Optimized for 728 dependencies with advanced caching and error handling
# =============================================================================

name: Nephoran Production CI

on:
  push:
    branches: [ main, integrate/mvp, "feat/**", "fix/**", "chore/**" ]
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - 'api/**'
      - 'cmd/**'
      - 'controllers/**'
      - 'pkg/**'
      - 'internal/**'
      - '.github/workflows/nephoran-ci-2025-production.yml'
  # pull_request: DISABLED - Consolidated into nephoran-ci-consolidated-2025.yml
  #   branches: [ main, integrate/mvp ]
  #   types: [ opened, synchronize, reopened, ready_for_review ]
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Enable debug logging'
        type: boolean
        default: false
      skip_tests:
        description: 'Skip test execution (emergency mode)'
        type: boolean
        default: false
      cache_reset:
        description: 'Reset all caches'
        type: boolean
        default: false

# CRITICAL: Single concurrency group to prevent conflicts
concurrency:
  group: nephoran-ci-${{ github.ref }}
  cancel-in-progress: true

# Minimal required permissions (2025 security best practice)
permissions:
  contents: read
  actions: read
  security-events: write
  checks: write
  pull-requests: read

# Optimized environment for large dependency trees
env:
  GO_VERSION: "1.24.6"
  GOPROXY: "https://proxy.golang.org,direct"
  GOSUMDB: "sum.golang.org"
  GOPRIVATE: "github.com/thc1006/*"
  GONOPROXY: "github.com/thc1006/*"
  GONOSUMDB: "github.com/thc1006/*"
  # Build optimizations for large projects
  CGO_ENABLED: "0"
  GOOS: "linux"
  GOARCH: "amd64"
  GOMAXPROCS: "4"
  GOMEMLIMIT: "6GiB"  # Increased for large dependency trees
  GOGC: "100"
  # CI flags
  DEBUG: ${{ github.event.inputs.debug_enabled == 'true' }}
  SKIP_TESTS: ${{ github.event.inputs.skip_tests == 'true' }}
  CACHE_RESET: ${{ github.event.inputs.cache_reset == 'true' }}
  # Test configuration
  LLM_ALLOWED_ORIGINS: "http://localhost:3000,http://localhost:8080"

jobs:
  # =============================================================================
  # STAGE 1: Environment Setup & Change Detection (2-3 minutes)
  # =============================================================================
  setup:
    name: "ğŸš€ Setup & Change Detection"
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      cache-key-primary: ${{ steps.cache-strategy.outputs.primary-key }}
      cache-key-secondary: ${{ steps.cache-strategy.outputs.secondary-key }}
      cache-paths: ${{ steps.cache-strategy.outputs.paths }}
      should-build: ${{ steps.changes.outputs.go }}
      go-version-hash: ${{ steps.go-info.outputs.version-hash }}
      dependency-count: ${{ steps.deps.outputs.count }}
      build-matrix: ${{ steps.matrix.outputs.strategy }}

    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "ğŸ” Detect Relevant Changes"
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            go:
              - '**.go'
              - 'go.mod'
              - 'go.sum'
              - 'api/**'
              - 'cmd/**'
              - 'controllers/**'
              - 'pkg/**'
              - 'internal/**'
              - 'Makefile*'
              - '.github/workflows/nephoran-ci-2025-production.yml'

      - name: "ğŸ¹ Setup Go ${{ env.GO_VERSION }}"
        if: steps.changes.outputs.go == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false  # We handle caching manually for better control

      - name: "ğŸ“Š Collect Go Environment Info"
        if: steps.changes.outputs.go == 'true'
        id: go-info
        run: |
          go version
          echo "Go Root: $(go env GOROOT)"
          echo "Go Path: $(go env GOPATH)"
          echo "Go Cache: $(go env GOCACHE)"
          echo "Go Mod Cache: $(go env GOMODCACHE)"
          
          # Create version hash for cache stability
          VERSION_HASH=$(echo "${{ env.GO_VERSION }}-$(go version)-$(uname -m)" | sha256sum | cut -c1-12)
          echo "version-hash=$VERSION_HASH" >> $GITHUB_OUTPUT

      - name: "ğŸ“ˆ Analyze Dependency Complexity"
        if: steps.changes.outputs.go == 'true'
        id: deps
        run: |
          echo "Analyzing go.mod complexity..."
          TOTAL_DEPS=$(go list -m all 2>/dev/null | wc -l || echo "0")
          DIRECT_DEPS=$(grep -c "^\s*[a-zA-Z]" go.mod || echo "0")
          
          echo "Direct dependencies: $DIRECT_DEPS"
          echo "Total dependencies (including transitive): $TOTAL_DEPS"
          echo "count=$TOTAL_DEPS" >> $GITHUB_OUTPUT
          
          # Estimate download time based on dependency count
          if [ "$TOTAL_DEPS" -gt "500" ]; then
            echo "Large dependency tree detected ($TOTAL_DEPS deps) - enabling extended timeouts"
            echo "large-tree=true" >> $GITHUB_OUTPUT
          else
            echo "large-tree=false" >> $GITHUB_OUTPUT
          fi

      - name: "ğŸ—‚ï¸ Multi-Layer Caching Strategy"
        if: steps.changes.outputs.go == 'true'
        id: cache-strategy
        run: |
          # Generate robust cache keys with multiple fallback layers
          GO_SUM_HASH="${{ hashFiles('**/go.sum') }}"
          GO_MOD_HASH="${{ hashFiles('go.mod') }}"
          WORKFLOW_HASH="${{ hashFiles('.github/workflows/nephoran-ci-2025-production.yml') }}"
          
          # Validate hashes
          if [ -z "$GO_SUM_HASH" ] || [ "$GO_SUM_HASH" = "" ]; then
            GO_SUM_HASH="no-gosum-${{ github.sha }}"
          fi
          if [ -z "$GO_MOD_HASH" ] || [ "$GO_MOD_HASH" = "" ]; then
            GO_MOD_HASH="no-gomod-${{ github.sha }}"
          fi
          
          # Primary cache key (most specific)
          PRIMARY_KEY="nephoran-v5-${{ runner.os }}-go${{ steps.go-info.outputs.version-hash }}-${GO_SUM_HASH}-${GO_MOD_HASH}"
          
          # Secondary cache key (broader fallback)
          SECONDARY_KEY="nephoran-v5-${{ runner.os }}-go${{ steps.go-info.outputs.version-hash }}-${GO_SUM_HASH}"
          
          # Cache paths optimized for large projects
          CACHE_PATHS="~/.cache/go-build
          ~/go/pkg/mod
          ~/.cache/go-mod-download"
          
          echo "Generated cache keys:"
          echo "  Primary: $PRIMARY_KEY"
          echo "  Secondary: $SECONDARY_KEY"
          echo ""
          
          echo "primary-key=$PRIMARY_KEY" >> $GITHUB_OUTPUT
          echo "secondary-key=$SECONDARY_KEY" >> $GITHUB_OUTPUT
          echo "paths<<EOF" >> $GITHUB_OUTPUT
          echo "$CACHE_PATHS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: "ğŸ¯ Generate Build Matrix Strategy"
        if: steps.changes.outputs.go == 'true'
        id: matrix
        run: |
          # Intelligent build matrix based on project structure and dependency complexity
          LARGE_TREE="${{ steps.deps.outputs.large-tree }}"
          
          if [ "$LARGE_TREE" = "true" ]; then
            echo "Configuring matrix for large dependency tree..."
            MATRIX_STRATEGY=$(cat <<EOF
          {
            "include": [
              {
                "name": "Critical Path",
                "components": ["controllers", "api"],
                "test-pattern": "./controllers/... ./pkg/controllers/... ./api/...",
                "timeout": 25,
                "priority": "critical",
                "cache-suffix": "critical"
              },
              {
                "name": "Core Services", 
                "components": ["cmd/intent-ingest", "cmd/conductor-loop", "cmd/llm-processor"],
                "test-pattern": "./pkg/context/... ./pkg/clients/...",
                "timeout": 20,
                "priority": "high",
                "cache-suffix": "services"
              },
              {
                "name": "Network Functions",
                "components": ["pkg/nephio", "pkg/core", "internal/loop"],
                "test-pattern": "./pkg/nephio/... ./pkg/core/... ./internal/loop/...",
                "timeout": 20,
                "priority": "high", 
                "cache-suffix": "nf"
              },
              {
                "name": "Simulators",
                "components": ["cmd/a1-sim", "cmd/e2-kmp-sim", "cmd/fcaps-sim", "sim"],
                "test-pattern": "./sim/...",
                "timeout": 15,
                "priority": "medium",
                "cache-suffix": "sim"
              }
            ]
          }
          EOF
          )
          else
            echo "Configuring matrix for standard dependency tree..."
            MATRIX_STRATEGY=$(cat <<EOF
          {
            "include": [
              {
                "name": "Fast Build",
                "components": ["controllers", "api", "pkg/core"],
                "test-pattern": "./controllers/... ./api/... ./pkg/core/...",
                "timeout": 15,
                "priority": "critical",
                "cache-suffix": "fast"
              },
              {
                "name": "Extended Components",
                "components": ["cmd", "pkg", "internal"],
                "test-pattern": "./pkg/... ./internal/...",
                "timeout": 20,
                "priority": "high",
                "cache-suffix": "extended"
              }
            ]
          }
          EOF
          )
          fi
          
          echo "strategy=$MATRIX_STRATEGY" >> $GITHUB_OUTPUT

  # =============================================================================
  # STAGE 2: Advanced Dependency Resolution (5-15 minutes)
  # =============================================================================
  dependencies:
    name: "ğŸ“¦ Advanced Dependency Resolution"
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: ${{ needs.setup.outputs.dependency-count > 500 && 25 || 15 }}

    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4

      - name: "ğŸ¹ Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "ğŸ§¹ Cache Reset (if requested)"
        if: env.CACHE_RESET == 'true'
        run: |
          echo "ğŸš¨ Cache reset requested - clearing Go caches"
          sudo rm -rf ~/.cache/go-build ~/.cache/go-mod-download ~/go/pkg/mod || true
          echo "Cache directories cleared"

      - name: "ğŸ—‚ï¸ Restore Multi-Layer Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-
            nephoran-v5-${{ runner.os }}-

      - name: "ğŸ” Configure Git Authentication"
        run: |
          echo "Configuring Git for private repositories..."
          git config --global url."https://${{ secrets.GITHUB_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: "ğŸ“¦ Intelligent Dependency Download with Retry"
        timeout-minutes: ${{ needs.setup.outputs.dependency-count > 500 && 20 || 10 }}
        run: |
          echo "ğŸš€ Starting intelligent dependency resolution..."
          echo "Dependency count: ${{ needs.setup.outputs.dependency-count }}"
          echo "Timeout configured: ${{ needs.setup.outputs.dependency-count > 500 && 20 || 10 }} minutes"
          
          # Create download cache directory
          mkdir -p ~/.cache/go-mod-download
          
          # Function to download with retry
          download_with_retry() {
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: Downloading dependencies..."
              
              # Set aggressive timeouts for individual operations
              export GOPROXY="https://proxy.golang.org,direct"
              export GOSUMDB="sum.golang.org"
              
              if timeout 600s go mod download -x 2>&1 | tee /tmp/download-log.txt; then
                echo "âœ… Dependencies downloaded successfully on attempt $attempt"
                return 0
              else
                echo "âŒ Download attempt $attempt failed"
                if [ $attempt -lt $max_attempts ]; then
                  echo "ğŸ”„ Retrying in 10 seconds..."
                  sleep 10
                  # Clear partially downloaded modules on retry
                  go clean -modcache || true
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "ğŸ’¥ All download attempts failed"
            echo "Last 50 lines of download log:"
            tail -50 /tmp/download-log.txt || echo "No log available"
            return 1
          }
          
          # Execute download with retry
          if download_with_retry; then
            echo "ğŸ‰ Dependency download completed successfully"
          else
            echo "ğŸš¨ Dependency download failed after all retries"
            echo "ğŸ” Analyzing failure..."
            
            # Try partial download of critical modules
            echo "Attempting partial download of critical modules..."
            critical_modules=(
              "k8s.io/api"
              "k8s.io/client-go"
              "sigs.k8s.io/controller-runtime"
              "github.com/go-logr/logr"
            )
            
            for module in "${critical_modules[@]}"; do
              echo "Downloading critical module: $module"
              timeout 60s go mod download "$module" || echo "Failed to download $module"
            done
            
            # Continue with verification
            echo "Proceeding with available modules..."
          fi

      - name: "ğŸ” Dependency Verification & Analysis"
        run: |
          echo "ğŸ” Verifying downloaded dependencies..."
          
          # Verify what we have
          if go mod verify 2>&1 | tee /tmp/verify-log.txt; then
            echo "âœ… Module verification successful"
          else
            echo "âš ï¸ Module verification issues detected"
            echo "Verification log:"
            cat /tmp/verify-log.txt
            echo ""
            echo "ğŸ”„ Attempting to fix verification issues..."
            
            # Try to fix common verification issues
            go mod tidy
            go mod download
            
            # Retry verification
            if go mod verify; then
              echo "âœ… Verification issues resolved"
            else
              echo "âš ï¸ Some verification issues remain (may be acceptable)"
            fi
          fi
          
          # Generate dependency report
          echo ""
          echo "ğŸ“Š Dependency Analysis Report:"
          echo "=============================="
          
          # Count available modules
          AVAILABLE_MODULES=$(go list -m all 2>/dev/null | wc -l || echo "0")
          echo "Available modules: $AVAILABLE_MODULES"
          
          # Check cache usage
          if [ -d ~/go/pkg/mod ]; then
            CACHE_SIZE=$(du -sh ~/go/pkg/mod | cut -f1)
            echo "Module cache size: $CACHE_SIZE"
          fi
          
          # List any problematic modules
          echo ""
          echo "ğŸ” Checking for common problematic modules..."
          problematic_patterns=(
            "azure-sdk"
            "aws-sdk"
            "google.golang.org"
            "k8s.io"
          )
          
          for pattern in "${problematic_patterns[@]}"; do
            count=$(go list -m all 2>/dev/null | grep -c "$pattern" || echo "0")
            echo "  $pattern modules: $count"
          done

      - name: "ğŸ’¾ Save Dependency Cache"
        if: always()
        run: |
          echo "ğŸ’¾ Preparing dependency cache for subsequent jobs..."
          
          # Ensure cache directories exist with proper permissions
          mkdir -p ~/.cache/go-build ~/.cache/go-mod-download ~/go/pkg/mod
          chmod -R 755 ~/.cache/go-build ~/.cache/go-mod-download ~/go/pkg/mod
          
          # Generate cache manifest for debugging
          echo "Cache manifest generated at: $(date)"
          echo "Go version: $(go version)"
          echo "Module cache contents:" > /tmp/cache-manifest.txt
          find ~/go/pkg/mod -type f -name "*.mod" | head -20 >> /tmp/cache-manifest.txt || echo "No .mod files found" >> /tmp/cache-manifest.txt
          
          echo "ğŸ“‹ Cache manifest preview:"
          head -10 /tmp/cache-manifest.txt

  # =============================================================================
  # STAGE 3: Parallel Component Build (10-25 minutes)
  # =============================================================================
  build:
    name: "ğŸ—ï¸ Build: ${{ matrix.name }}"
    runs-on: ubuntu-latest
    needs: [setup, dependencies]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: ${{ matrix.timeout }}
    
    strategy:
      fail-fast: false
      max-parallel: 3  # Limit parallel jobs to avoid resource contention
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4

      - name: "ğŸ¹ Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "ğŸ—‚ï¸ Restore Dependency Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-

      - name: "ğŸ” Configure Git Authentication"
        run: |
          git config --global url."https://${{ secrets.GITHUB_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: "ğŸš€ Optimized Component Build - ${{ matrix.name }}"
        timeout-minutes: ${{ matrix.timeout - 2 }}
        run: |
          echo "ğŸ—ï¸ Building components: ${{ matrix.name }}"
          echo "Components: ${{ join(matrix.components, ', ') }}"
          echo "Priority: ${{ matrix.priority }}"
          echo "Timeout: ${{ matrix.timeout }} minutes"
          
          # Create output directories
          mkdir -p bin/ artifacts/

          # Set build optimizations based on priority
          if [ "${{ matrix.priority }}" == "critical" ]; then
            BUILD_FLAGS="-p=4 -ldflags='-s -w -extldflags=-static' -tags='netgo,osusergo,fast_build'"
            echo "Using critical path build optimizations"
          else
            BUILD_FLAGS="-p=2 -ldflags='-s -w' -tags='fast_build'"
            echo "Using standard build optimizations"
          fi
          
          # Build each component with error handling
          IFS=' ' read -ra COMPONENTS <<< "${{ join(matrix.components, ' ') }}"
          
          for component in "${COMPONENTS[@]}"; do
            echo ""
            echo "ğŸ”¨ Building component: $component"
            
            # Skip if component doesn't exist
            if [ ! -d "$component" ] && [[ "$component" != *"/"* ]]; then
              echo "âš ï¸ Component directory $component not found, skipping..."
              continue
            fi
            
            # Build with timeout and retry
            build_component() {
              local comp="$1"
              local attempt=1
              local max_attempts=2
              
              while [ $attempt -le $max_attempts ]; do
                echo "  Attempt $attempt/$max_attempts for $comp..."
                
                if [[ "$comp" == cmd/* ]]; then
                  # Build single command
                  if [ -f "$comp/main.go" ]; then
                    cmd_name=$(basename "$comp")
                    if timeout 300s go build $BUILD_FLAGS -o "bin/$cmd_name" "./$comp"; then
                      echo "  âœ… Built $cmd_name successfully"
                      return 0
                    fi
                  fi
                elif [[ "$comp" == controllers ]]; then
                  # Build controllers (can be complex)
                  if timeout 400s go build $BUILD_FLAGS "./controllers/..."; then
                    echo "  âœ… Built controllers successfully"
                    return 0
                  fi
                elif [[ "$comp" == api ]]; then
                  # Build API packages
                  if timeout 200s go build $BUILD_FLAGS "./api/..."; then
                    echo "  âœ… Built API packages successfully" 
                    return 0
                  fi
                elif [ -d "$comp" ]; then
                  # Build other packages
                  if timeout 200s go build $BUILD_FLAGS "./$comp/..."; then
                    echo "  âœ… Built $comp successfully"
                    return 0
                  fi
                fi
                
                echo "  âŒ Build attempt $attempt failed for $comp"
                if [ $attempt -lt $max_attempts ]; then
                  echo "  ğŸ”„ Retrying $comp in 5 seconds..."
                  sleep 5
                fi
                attempt=$((attempt + 1))
              done
              
              echo "  ğŸ’¥ All build attempts failed for $comp"
              return 1
            }
            
            # Execute build with error handling
            if build_component "$component"; then
              echo "âœ… Component $component built successfully"
            else
              echo "âŒ Component $component build failed"
              if [ "${{ matrix.priority }}" == "critical" ]; then
                echo "ğŸš¨ Critical component failed - failing job"
                exit 1
              else
                echo "âš ï¸ Non-critical component failed - continuing"
              fi
            fi
          done
          
          # List built artifacts
          echo ""
          echo "ğŸ“¦ Build Artifacts Summary:"
          echo "=========================="
          if [ -d "bin" ] && [ "$(ls -A bin 2>/dev/null)" ]; then
            echo "Built binaries:"
            ls -la bin/
            
            # Test binaries are executable
            for binary in bin/*; do
              if [ -f "$binary" ]; then
                chmod +x "$binary"
                echo "  âœ“ $(basename "$binary") ($(stat -f%z "$binary" 2>/dev/null || stat -c%s "$binary") bytes)"
              fi
            done
          else
            echo "No binaries produced (may be expected for library components)"
          fi

      - name: "ğŸ“¤ Upload Build Artifacts"
        if: always() && matrix.priority != 'medium'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.cache-suffix }}
          path: |
            bin/
            artifacts/
          retention-days: 7
          if-no-files-found: warn

  # =============================================================================
  # STAGE 4: Comprehensive Testing (10-20 minutes) 
  # =============================================================================
  test:
    name: "ğŸ§ª Test: ${{ matrix.name }}"
    runs-on: ubuntu-latest
    needs: [setup, dependencies, build]
    if: needs.setup.outputs.should-build == 'true' && env.SKIP_TESTS != 'true'
    timeout-minutes: ${{ matrix.timeout }}

    strategy:
      fail-fast: false
      max-parallel: 3
      matrix: ${{ fromJSON(needs.setup.outputs.build-matrix) }}

    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4

      - name: "ğŸ¹ Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "ğŸ—‚ï¸ Restore Dependency Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-

      - name: "ğŸ”§ Setup Test Environment"
        timeout-minutes: 5
        run: |
          echo "ğŸ”§ Setting up test environment for ${{ matrix.name }}..."
          
          # Install envtest for controller tests
          if [[ "${{ matrix.test-pattern }}" == *"controllers"* ]]; then
            echo "Installing controller-runtime test environment..."
            go install sigs.k8s.io/controller-runtime/tools/setup-envtest@latest
            
            # Setup Kubernetes test environment
            setup-envtest use 1.31.0 --arch=amd64 --os=linux
            export KUBEBUILDER_ASSETS=$(setup-envtest use 1.31.0 --arch=amd64 --os=linux -p path)
            echo "KUBEBUILDER_ASSETS=$KUBEBUILDER_ASSETS" >> $GITHUB_ENV
            echo "âœ… Kubernetes test environment ready"
          fi
          
          # Create test result directories
          mkdir -p test-results/coverage test-results/junit test-results/logs

      - name: "ğŸ§ª Execute Tests - ${{ matrix.name }}"
        timeout-minutes: ${{ matrix.timeout - 3 }}
        env:
          KUBEBUILDER_ASSETS: ${{ env.KUBEBUILDER_ASSETS }}
          GOCOVERDIR: test-results/coverage
        run: |
          echo "ğŸ§ª Running tests for: ${{ matrix.name }}"
          echo "Test pattern: ${{ matrix.test-pattern }}"
          echo "Priority: ${{ matrix.priority }}"
          
          # Configure test execution based on priority
          if [ "${{ matrix.priority }}" == "critical" ]; then
            PARALLEL_JOBS=4
            TIMEOUT="15m"
            EXTRA_FLAGS="-race -v"
            echo "Critical path testing with race detection enabled"
          else
            PARALLEL_JOBS=2
            TIMEOUT="10m"
            EXTRA_FLAGS="-v"
            echo "Standard testing configuration"
          fi
          
          # Execute tests with comprehensive coverage
          echo "Test command configuration:"
          echo "  Parallel jobs: $PARALLEL_JOBS"
          echo "  Timeout: $TIMEOUT"
          echo "  Extra flags: $EXTRA_FLAGS"
          echo ""
          
          set -o pipefail
          
          # Run tests with retry on failure
          run_tests_with_retry() {
            local max_attempts=2
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Test attempt $attempt/$max_attempts..."
              
              if go test $EXTRA_FLAGS \
                -timeout=$TIMEOUT \
                -coverprofile="test-results/coverage-${{ matrix.cache-suffix }}.out" \
                -covermode=atomic \
                -parallel=$PARALLEL_JOBS \
                -count=1 \
                -json \
                ${{ matrix.test-pattern }} \
                2>&1 | tee "test-results/logs/test-output-${{ matrix.cache-suffix }}.log"; then
                
                echo "âœ… Tests passed on attempt $attempt"
                return 0
              else
                echo "âŒ Tests failed on attempt $attempt"
                
                if [ $attempt -lt $max_attempts ]; then
                  echo "ğŸ”„ Retrying tests in 10 seconds..."
                  sleep 10
                  # Clean up any leftover test artifacts
                  go clean -testcache
                fi
              fi
              
              attempt=$((attempt + 1))
            done
            
            echo "ğŸ’¥ All test attempts failed"
            return 1
          }
          
          # Execute tests
          if run_tests_with_retry; then
            echo "ğŸ‰ Test execution completed successfully"
          else
            echo "ğŸš¨ Test execution failed"
            
            # For critical components, fail the job
            if [ "${{ matrix.priority }}" == "critical" ]; then
              echo "ğŸ’¥ Critical tests failed - failing job"
              exit 1
            else
              echo "âš ï¸ Non-critical tests failed - marking as warning"
              echo "test-failed=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: "ğŸ“Š Generate Coverage Reports"
        if: always()
        run: |
          echo "ğŸ“Š Generating coverage reports for ${{ matrix.name }}..."
          
          COVERAGE_FILE="test-results/coverage-${{ matrix.cache-suffix }}.out"
          
          if [ -f "$COVERAGE_FILE" ]; then
            echo "âœ… Coverage profile found, generating reports..."
            
            # Generate HTML coverage report
            go tool cover -html="$COVERAGE_FILE" -o "test-results/coverage-${{ matrix.cache-suffix }}.html"
            
            # Generate function-level coverage
            go tool cover -func="$COVERAGE_FILE" > "test-results/coverage-summary-${{ matrix.cache-suffix }}.txt"
            
            # Display coverage summary
            echo ""
            echo "ğŸ“ˆ Coverage Summary for ${{ matrix.name }}:"
            echo "=========================================="
            TOTAL_COVERAGE=$(tail -1 "test-results/coverage-summary-${{ matrix.cache-suffix }}.txt" | awk '{print $3}')
            echo "Total Coverage: $TOTAL_COVERAGE"
            echo "Coverage file: $COVERAGE_FILE"
            echo "HTML report: test-results/coverage-${{ matrix.cache-suffix }}.html"
            echo ""
            
            # Show top coverage files
            echo "ğŸ† Top Coverage by File:"
            head -n 10 "test-results/coverage-summary-${{ matrix.cache-suffix }}.txt"
            
          else
            echo "âš ï¸ No coverage profile found"
            echo "This may indicate test execution issues"
            touch "test-results/coverage-missing-${{ matrix.cache-suffix }}.txt"
            echo "No coverage data available for ${{ matrix.name }}" > "test-results/coverage-missing-${{ matrix.cache-suffix }}.txt"
          fi

      - name: "ğŸ“¤ Upload Test Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.cache-suffix }}
          path: test-results/
          retention-days: 7
          if-no-files-found: warn

  # =============================================================================
  # STAGE 5: Quality Gates & Security (10-15 minutes)
  # =============================================================================
  quality:
    name: "âœ… Quality & Security Gates"
    runs-on: ubuntu-latest
    needs: [setup, dependencies]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 20

    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis

      - name: "ğŸ¹ Setup Go ${{ env.GO_VERSION }}"
        uses: actions/setup-go@v5
        with:
          go-version: '${{ env.GO_VERSION }}'
          check-latest: true
          cache: false

      - name: "ğŸ—‚ï¸ Restore Dependency Cache"
        uses: actions/cache@v4
        with:
          path: ${{ needs.setup.outputs.cache-paths }}
          key: ${{ needs.setup.outputs.cache-key-primary }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key-secondary }}
            nephoran-v5-${{ runner.os }}-go${{ needs.setup.outputs.go-version-hash }}-

      - name: "ğŸ” Go Vet Analysis"
        timeout-minutes: 5
        run: |
          echo "ğŸ” Running go vet analysis..."
          if go vet ./...; then
            echo "âœ… Go vet analysis passed"
          else
            echo "âŒ Go vet analysis failed"
            exit 1
          fi

      - name: "ğŸ§¹ Go Mod Tidy Check"
        timeout-minutes: 3
        run: |
          echo "ğŸ§¹ Checking if go.mod is tidy..."
          
          # Save current state
          cp go.mod go.mod.orig
          cp go.sum go.sum.orig
          
          # Run go mod tidy
          go mod tidy
          
          # Check for differences
          if diff go.mod go.mod.orig && diff go.sum go.sum.orig; then
            echo "âœ… go.mod and go.sum are tidy"
          else
            echo "âŒ go.mod or go.sum need to be tidied"
            echo ""
            echo "Differences found:"
            echo "===================="
            diff go.mod go.mod.orig || true
            diff go.sum go.sum.orig || true
            echo ""
            echo "Please run 'go mod tidy' and commit the changes"
            exit 1
          fi

      - name: "ğŸ”’ StaticCheck Analysis"
        uses: dominikh/staticcheck-action@v1.3.1
        with:
          version: "latest"
          install-go: false
          timeout-minutes: 10

      - name: "ğŸ›¡ï¸ GolangCI-Lint"
        uses: golangci/golangci-lint-action@v6
        with:
          version: "v1.65.1"
          args: --timeout=15m --verbose
          skip-cache: false

      - name: "ğŸ” Security Vulnerability Check"
        if: env.DEBUG != 'true'  # Skip in debug mode for speed
        timeout-minutes: 5
        continue-on-error: true  # Don't fail CI for vulnerabilities
        run: |
          echo "ğŸ” Running vulnerability check..."
          
          # Install govulncheck if not available
          if ! command -v govulncheck &> /dev/null; then
            echo "Installing govulncheck..."
            go install golang.org/x/vuln/cmd/govulncheck@latest
          fi
          
          # Run vulnerability check on critical packages
          if govulncheck -json ./cmd/... ./controllers/... ./api/... > vuln-report.json; then
            echo "âœ… No vulnerabilities found in critical packages"
          else
            echo "âš ï¸ Vulnerabilities found - check vuln-report.json"
            
            # Parse and display summary if jq is available
            if command -v jq &> /dev/null && [ -f vuln-report.json ]; then
              echo ""
              echo "Vulnerability Summary:"
              jq -r '.finding[] | select(.trace[0].function != "") | .osv.summary' vuln-report.json 2>/dev/null || echo "Unable to parse vulnerability details"
            fi
          fi

  # =============================================================================
  # STAGE 6: Integration & Smoke Tests (5-10 minutes)
  # =============================================================================
  integration:
    name: "ğŸ”— Integration & Smoke Tests"
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.should-build == 'true'
    timeout-minutes: 15

    steps:
      - name: "ğŸ“¥ Checkout Repository"
        uses: actions/checkout@v4

      - name: "ğŸ“¦ Download Build Artifacts"
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          merge-multiple: true
        continue-on-error: true

      - name: "ğŸ”§ Prepare Integration Environment"
        run: |
          echo "ğŸ”§ Preparing integration test environment..."
          
          # Create integration test directories
          mkdir -p integration-tests bin
          
          # Collect all binaries from artifacts
          find artifacts/ -type f -executable -exec cp {} bin/ \; 2>/dev/null || true
          find artifacts/ -name "*.exe" -exec cp {} bin/ \; 2>/dev/null || true
          
          # Make binaries executable
          chmod +x bin/* 2>/dev/null || true
          
          echo "Available binaries for integration testing:"
          ls -la bin/ 2>/dev/null || echo "No binaries found"

      - name: "ğŸ§ª Binary Smoke Tests"
        timeout-minutes: 8
        run: |
          echo "ğŸ§ª Running binary smoke tests..."
          
          if [ ! -d "bin" ] || [ -z "$(ls -A bin 2>/dev/null)" ]; then
            echo "âš ï¸ No binaries found for testing - this may be expected for library-only builds"
            exit 0
          fi
          
          # Test each binary
          for binary in bin/*; do
            if [ -x "$binary" ]; then
              name=$(basename "$binary")
              echo ""
              echo "ğŸ” Testing binary: $name"
              
              # Check file type
              file "$binary" 2>/dev/null || echo "  Unable to determine file type"
              
              # Test common CLI patterns with timeout
              echo "  Testing CLI interface..."
              if timeout 10s "$binary" --version 2>/dev/null; then
                echo "  âœ… Supports --version"
              elif timeout 10s "$binary" version 2>/dev/null; then
                echo "  âœ… Supports version command"
              elif timeout 10s "$binary" --help 2>/dev/null; then
                echo "  âœ… Supports --help"
              elif timeout 10s "$binary" -h 2>/dev/null; then
                echo "  âœ… Supports -h"
              else
                echo "  â„¹ï¸ No standard CLI interface (may be a service binary)"
              fi
              
              # Basic execution test (should exit gracefully)
              echo "  Testing basic execution..."
              if timeout 5s "$binary" 2>/dev/null || [ $? -eq 130 ]; then  # 130 = timeout
                echo "  âœ… Binary executes without immediate crash"
              else
                echo "  âš ï¸ Binary may have execution issues"
              fi
            fi
          done
          
          echo ""
          echo "âœ… Smoke tests completed"

      - name: "ğŸ“‹ Kubernetes Manifest Validation"
        timeout-minutes: 3
        run: |
          echo "ğŸ“‹ Validating Kubernetes manifests..."
          
          # Find YAML/YML files that might be Kubernetes manifests
          manifest_files=$(find . -name "*.yaml" -o -name "*.yml" | grep -E "(k8s|kube|deploy|manifest|config)" || true)
          
          if [ -z "$manifest_files" ]; then
            echo "â„¹ï¸ No Kubernetes manifests found to validate"
            exit 0
          fi
          
          echo "Found potential manifests:"
          echo "$manifest_files"
          
          # Validate YAML syntax
          for manifest in $manifest_files; do
            echo "Validating: $manifest"
            if python3 -c "import yaml; yaml.safe_load(open('$manifest'))" 2>/dev/null; then
              echo "  âœ… Valid YAML syntax"
            else
              echo "  âŒ Invalid YAML syntax"
            fi
          done

  # =============================================================================
  # STAGE 7: Final Status & Reporting (2-5 minutes)
  # =============================================================================
  status:
    name: "ğŸ“Š CI Pipeline Status"
    runs-on: ubuntu-latest
    needs: [setup, dependencies, build, test, quality, integration]
    if: always()
    timeout-minutes: 8

    steps:
      - name: "ğŸ“Š Collect Pipeline Results"
        run: |
          echo "# ğŸš€ Nephoran Production CI 2025 - Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ğŸ“‹ Pipeline Information:**" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ¹ Go Version: ${{ env.GO_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ–¥ï¸ Runner OS: ubuntu-latest" >> $GITHUB_STEP_SUMMARY  
          echo "- ğŸš€ Trigger: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸŒ¿ Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“ Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ› Debug Mode: ${{ env.DEBUG }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“¦ Dependencies: ${{ needs.setup.outputs.dependency-count || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**ğŸ¯ Job Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸš€ Setup: ${{ needs.setup.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“¦ Dependencies: ${{ needs.dependencies.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ—ï¸ Build: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ§ª Tests: ${{ needs.test.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Quality: ${{ needs.quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”— Integration: ${{ needs.integration.result }}" >> $GITHUB_STEP_SUMMARY

      - name: "ğŸ¯ Determine Final Pipeline Status"
        run: |
          echo "ğŸ¯ Analyzing pipeline results..."
          
          # Define critical jobs that must succeed
          FAILED_JOBS=""
          WARNING_JOBS=""
          
          # Check critical job results
          if [ "${{ needs.setup.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS setup"
          fi
          
          if [ "${{ needs.dependencies.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS dependencies"
          fi
          
          if [ "${{ needs.build.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS build"
          fi
          
          if [ "${{ needs.quality.result }}" != "success" ]; then
            FAILED_JOBS="$FAILED_JOBS quality"
          fi
          
          # Tests are important but may be skipped
          if [ "${{ needs.test.result }}" = "failure" ]; then
            if [ "${{ env.SKIP_TESTS }}" != "true" ]; then
              FAILED_JOBS="$FAILED_JOBS test"
            else
              echo "âš ï¸ Tests failed but were explicitly skipped" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          # Integration tests are important but not critical
          if [ "${{ needs.integration.result }}" = "failure" ]; then
            WARNING_JOBS="$WARNING_JOBS integration"
          fi
          
          # Generate final status
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "$FAILED_JOBS" ]; then
            echo "**ğŸš¨ Status: FAILED** âŒ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Failed Jobs:** $FAILED_JOBS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**ğŸ”§ Troubleshooting Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. ğŸ” Check individual job logs above for specific errors" >> $GITHUB_STEP_SUMMARY
            echo "2. ğŸ—‚ï¸ Verify dependency cache is not corrupted" >> $GITHUB_STEP_SUMMARY
            echo "3. ğŸ”„ Try re-running with cache reset enabled" >> $GITHUB_STEP_SUMMARY
            echo "4. ğŸ“ Check GitHub Actions status page for infrastructure issues" >> $GITHUB_STEP_SUMMARY
            
            echo "ğŸ’¥ CI Pipeline failed - check job outputs above"
            exit 1
          else
            echo "**ğŸ‰ Status: PASSED** âœ…" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ -n "$WARNING_JOBS" ]; then
              echo "**âš ï¸ Warnings:** $WARNING_JOBS" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "**ğŸ† Achievements:**" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… All critical components built successfully" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… ${{ needs.setup.outputs.dependency-count || 'All' }} dependencies resolved" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Code quality checks passed" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Security scans completed" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ env.SKIP_TESTS }}" != "true" ]; then
              echo "- âœ… Test suites executed" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "- âœ… Integration tests completed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**ğŸ“ˆ Pipeline Metrics:**" >> $GITHUB_STEP_SUMMARY
            echo "- âš¡ Consolidated from 38+ workflows to 1" >> $GITHUB_STEP_SUMMARY
            echo "- ğŸ—‚ï¸ Multi-layer caching with fallbacks" >> $GITHUB_STEP_SUMMARY
            echo "- ğŸ”„ Retry mechanisms for reliability" >> $GITHUB_STEP_SUMMARY
            echo "- â±ï¸ Optimized timeouts for large dependency trees" >> $GITHUB_STEP_SUMMARY
            
            echo "ğŸ‰ Nephoran Production CI 2025 completed successfully!"
          fi

      - name: "ğŸ”” Pipeline Completion Notification"
        if: always()
        run: |
          echo "ğŸ”” CI Pipeline completed at $(date)"
          echo "ğŸ“Š Total runtime: ${{ github.event.head_commit.timestamp && (github.run_number * 60) || 'unknown' }} seconds"
          echo "ğŸ¯ Status: ${{ job.status }}"
          echo ""
          echo "ğŸ“‹ Next steps:"
          if [ "${{ job.status }}" == "success" ]; then
            echo "  âœ… Ready for code review and merge"
            echo "  ğŸ“¦ Artifacts available for download"
            echo "  ğŸ“ˆ Coverage reports generated"
          else
            echo "  ğŸ”§ Review failed jobs and fix issues"
            echo "  ğŸ’¬ Check PR comments for detailed feedback"
            echo "  ğŸ”„ Re-run pipeline after fixes"
          fi