---
# Data Protection & Compliance Implementation for Nephoran Intent Operator
# This configuration implements comprehensive data protection, encryption, and compliance mechanisms

# Namespace for data protection components
apiVersion: v1
kind: Namespace
metadata:
  name: nephoran-compliance
  labels:
    app.kubernetes.io/name: data-protection
    app.kubernetes.io/part-of: nephoran-intent-operator
    environment: production
    compliance.nephoran.com/enabled: "true"
---
# ServiceAccount for compliance operations
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nephoran-compliance-operator
  namespace: nephoran-compliance
  labels:
    app: data-protection
    component: operator
---
# ClusterRole for compliance operations
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nephoran-compliance-operator
rules:
# Access to manage secrets and configmaps for encryption
- apiGroups: [""]
  resources: ["secrets", "configmaps"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
# Access to all Nephoran resources for compliance monitoring
- apiGroups: ["nephoran.com"]
  resources: ["networkintents", "e2nodesets", "managedelements"]
  verbs: ["get", "list", "watch"]
# Access to monitor data access patterns
- apiGroups: [""]
  resources: ["pods", "services", "persistentvolumes", "persistentvolumeclaims"]
  verbs: ["get", "list", "watch"]
# Access to backup and compliance monitoring
- apiGroups: ["batch"]
  resources: ["jobs", "cronjobs"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
# Access to certificate management
- apiGroups: ["cert-manager.io"]
  resources: ["certificates", "issuers", "clusterissuers"]
  verbs: ["get", "list", "watch", "create", "update", "patch"]
---
# ClusterRoleBinding for compliance operator
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nephoran-compliance-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: nephoran-compliance-operator
subjects:
- kind: ServiceAccount
  name: nephoran-compliance-operator
  namespace: nephoran-compliance
---
# Data Protection Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: data-protection-config
  namespace: nephoran-compliance
  labels:
    app: data-protection
    component: configuration
data:
  # Encryption configuration
  encryption-config.yaml: |
    encryption:
      enabled: true
      algorithms:
        symmetric: "AES-256-GCM"
        asymmetric: "RSA-4096"
        hash: "SHA-256"
        
    # Encryption at rest
    at_rest:
      enabled: true
      provider: "kubernetes"
      key_rotation_days: 90
      
      # Database encryption
      databases:
        weaviate:
          enabled: true
          encryption_key_secret: "weaviate-encryption-key"
          algorithm: "AES-256-GCM"
          
        postgresql:
          enabled: true
          encryption_key_secret: "postgresql-encryption-key"
          algorithm: "AES-256-GCM"
          
      # Volume encryption
      volumes:
        enabled: true
        storage_class: "encrypted-gp3"
        encryption_key_secret: "volume-encryption-key"
        
    # Encryption in transit
    in_transit:
      enabled: true
      min_tls_version: "1.3"
      cipher_suites:
        - "TLS_AES_256_GCM_SHA384"
        - "TLS_CHACHA20_POLY1305_SHA256"
        - "TLS_AES_128_GCM_SHA256"
        
      # Service-to-service encryption
      services:
        all_internal: true
        external_apis: true
        
      # Certificate management
      certificates:
        provider: "cert-manager"
        issuer: "letsencrypt-production"
        auto_renewal: true
        validity_days: 90
        
  # Data retention configuration
  retention-config.yaml: |
    data_retention:
      enabled: true
      default_retention_days: 2555  # 7 years for compliance
      
    # Service-specific retention policies
    retention_policies:
      network_intents:
        retention_days: 2555  # 7 years for audit
        archive_after_days: 365  # Archive after 1 year
        purge_after_days: 2555
        backup_copies: 3
        
      e2_nodesets:
        retention_days: 1095  # 3 years
        archive_after_days: 365
        purge_after_days: 1095
        backup_copies: 2
        
      system_logs:
        retention_days: 365  # 1 year
        archive_after_days: 90
        purge_after_days: 365
        backup_copies: 2
        
      audit_logs:
        retention_days: 2555  # 7 years (compliance requirement)
        archive_after_days: 90
        purge_after_days: 2555
        backup_copies: 5
        immutable: true
        
      metrics_data:
        retention_days: 730  # 2 years
        archive_after_days: 180
        purge_after_days: 730
        backup_copies: 2
        
      security_events:
        retention_days: 2555  # 7 years
        archive_after_days: 30
        purge_after_days: 2555
        backup_copies: 5
        immutable: true
        
    # Data classification
    classification:
      levels:
        - name: "public"
          retention_days: 365
          encryption_required: false
        - name: "internal"
          retention_days: 1095
          encryption_required: true
        - name: "confidential"
          retention_days: 2555
          encryption_required: true
        - name: "restricted"
          retention_days: 2555
          encryption_required: true
          access_logging: true
          
  # Regional compliance configuration
  compliance-config.yaml: |
    regional_compliance:
      enabled: true
      
      # GDPR compliance (European Union)
      gdpr:
        enabled: true
        data_residency: "eu"
        right_to_be_forgotten: true
        data_portability: true
        consent_management: true
        privacy_by_design: true
        dpo_contact: "dpo@nephoran.com"
        
      # CCPA compliance (California)
      ccpa:
        enabled: true
        data_residency: "us"
        opt_out_rights: true
        data_transparency: true
        
      # SOX compliance (Financial)
      sox:
        enabled: true
        audit_trails: true
        data_integrity: true
        access_controls: true
        
      # HIPAA compliance (Healthcare)
      hipaa:
        enabled: false  # Not applicable for telecom
        
      # Telecom-specific compliance
      telecom:
        fcc_compliance: true
        etsi_compliance: true
        3gpp_compliance: true
        data_localization: true
        
    # Data sovereignty rules
    data_sovereignty:
      enabled: true
      
      regions:
        eu:
          data_residency_required: true
          cross_border_restrictions: true
          allowed_countries: ["EU", "EEA", "CH"]
          encryption_required: true
          
        us:
          data_residency_required: false
          cross_border_restrictions: false
          encryption_required: true
          
        apac:
          data_residency_required: true
          cross_border_restrictions: true
          allowed_countries: ["AU", "JP", "SG"]
          encryption_required: true
          
    # Compliance monitoring
    monitoring:
      enabled: true
      audit_frequency: "daily"
      compliance_reports: "monthly"
      violation_alerts: true
      
---
# Encryption Key Management System
apiVersion: apps/v1
kind: Deployment
metadata:
  name: encryption-key-manager
  namespace: nephoran-compliance
  labels:
    app: encryption-key-manager
    component: security
spec:
  replicas: 2
  selector:
    matchLabels:
      app: encryption-key-manager
  template:
    metadata:
      labels:
        app: encryption-key-manager
    spec:
      serviceAccountName: nephoran-compliance-operator
      containers:
      - name: key-manager
        image: alpine/openssl:latest
        command:
        - /bin/sh
        - -c
        - |
          #!/bin/sh
          echo "🔐 Starting Encryption Key Management System"
          
          # Function to generate encryption keys
          generate_encryption_key() {
            local key_name=$1
            local key_size=$2
            
            echo "🔑 Generating encryption key: $key_name"
            
            # Generate random key
            openssl rand -hex $key_size > /tmp/${key_name}.key
            
            # Create Kubernetes secret
            kubectl create secret generic ${key_name} \
              --from-file=key=/tmp/${key_name}.key \
              --namespace=nephoran-system \
              --dry-run=client -o yaml | kubectl apply -f -
              
            # Secure cleanup
            shred -u /tmp/${key_name}.key
            
            echo "✅ Key $key_name generated and stored securely"
          }
          
          # Function to rotate encryption keys
          rotate_encryption_key() {
            local key_name=$1
            local backup_suffix=$(date +%Y%m%d-%H%M%S)
            
            echo "🔄 Rotating encryption key: $key_name"
            
            # Backup existing key
            kubectl get secret $key_name -n nephoran-system -o yaml > /tmp/${key_name}-backup-${backup_suffix}.yaml
            
            # Generate new key
            generate_encryption_key $key_name 32
            
            # Store backup securely
            kubectl create secret generic ${key_name}-backup-${backup_suffix} \
              --from-file=backup=/tmp/${key_name}-backup-${backup_suffix}.yaml \
              --namespace=nephoran-compliance
              
            # Cleanup
            rm /tmp/${key_name}-backup-${backup_suffix}.yaml
            
            echo "✅ Key $key_name rotated successfully"
          }
          
          # Function to validate key strength
          validate_key_strength() {
            local key_name=$1
            
            key_data=$(kubectl get secret $key_name -n nephoran-system -o jsonpath='{.data.key}' | base64 -d)
            key_length=${#key_data}
            
            if [ $key_length -ge 64 ]; then
              echo "✅ Key $key_name strength validation passed ($key_length characters)"
              return 0
            else
              echo "❌ Key $key_name strength validation failed ($key_length characters)"
              return 1
            fi
          }
          
          # Function to check key age and rotation schedule
          check_key_rotation_schedule() {
            local key_name=$1
            local max_age_days=90
            
            creation_time=$(kubectl get secret $key_name -n nephoran-system -o jsonpath='{.metadata.creationTimestamp}')
            current_time=$(date -u +%s)
            creation_timestamp=$(date -d "$creation_time" +%s)
            age_days=$(( (current_time - creation_timestamp) / 86400 ))
            
            echo "🕐 Key $key_name age: $age_days days (max: $max_age_days days)"
            
            if [ $age_days -ge $max_age_days ]; then
              echo "⚠️ Key $key_name requires rotation"
              rotate_encryption_key $key_name
            else
              echo "✅ Key $key_name rotation not required"
            fi
          }
          
          # Initialize encryption keys if they don't exist
          initialize_keys() {
            echo "🚀 Initializing encryption keys..."
            
            keys=("weaviate-encryption-key" "postgresql-encryption-key" "volume-encryption-key" "backup-encryption-key")
            
            for key in "${keys[@]}"; do
              if ! kubectl get secret $key -n nephoran-system >/dev/null 2>&1; then
                generate_encryption_key $key 32
              else
                echo "✅ Key $key already exists"
                validate_key_strength $key
              fi
            done
          }
          
          # Main key management loop
          initialize_keys
          
          while true; do
            echo "🔍 Checking key rotation schedule..."
            
            # Check rotation schedule for all keys
            keys=("weaviate-encryption-key" "postgresql-encryption-key" "volume-encryption-key" "backup-encryption-key")
            
            for key in "${keys[@]}"; do
              if kubectl get secret $key -n nephoran-system >/dev/null 2>&1; then
                check_key_rotation_schedule $key
              fi
            done
            
            # Wait 24 hours before next check
            echo "⏰ Next key rotation check in 24 hours"
            sleep 86400
          done
        env:
        - name: KUBECTL_VERSION
          value: "1.28.0"
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        securityContext:
          runAsNonRoot: true
          runAsUser: 65534
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL

---
# Audit Logging System
apiVersion: apps/v1
kind: Deployment
metadata:
  name: audit-logging-system
  namespace: nephoran-compliance
  labels:
    app: audit-logging
    component: compliance
spec:
  replicas: 2
  selector:
    matchLabels:
      app: audit-logging
  template:
    metadata:
      labels:
        app: audit-logging
    spec:
      serviceAccountName: nephoran-compliance-operator
      containers:
      - name: audit-logger
        image: fluent/fluentd:v1.16-debian-1
        command:
        - /bin/sh
        - -c
        - |
          #!/bin/sh
          echo "📝 Starting Comprehensive Audit Logging System"
          
          # Configure Fluentd for audit logging
          cat > /fluentd/etc/audit-fluent.conf << 'EOF'
          # Audit log sources
          <source>
            @type tail
            @id audit_logs
            path /var/log/audit/*.log
            pos_file /var/log/fluentd-audit.log.pos
            tag audit.kubernetes
            <parse>
              @type json
              time_key timestamp
              time_format %Y-%m-%dT%H:%M:%S.%N%:z
            </parse>
          </source>
          
          # Kubernetes API audit logs
          <source>
            @type tail
            @id k8s_audit
            path /var/log/kubernetes/audit.log
            pos_file /var/log/fluentd-k8s-audit.log.pos
            tag audit.k8s
            <parse>
              @type json
              time_key timestamp
              time_format %Y-%m-%dT%H:%M:%S.%N%:z
            </parse>
          </source>
          
          # Data access logging
          <filter audit.**>
            @type record_transformer
            <record>
              audit_category ${record.dig("objectRef", "resource") || "unknown"}
              audit_user ${record.dig("user", "username") || "system"}
              audit_action ${record["verb"] || "unknown"}
              audit_resource ${record.dig("objectRef", "name") || "unknown"}
              audit_namespace ${record.dig("objectRef", "namespace") || "default"}
              compliance_required true
              retention_class "audit"
              data_classification "restricted"
              immutable true
            </record>
          </filter>
          
          # Security event enrichment
          <filter audit.**>
            @type record_transformer
            <record>
              security_level ${record["verb"] =~ /create|update|delete/i ? "high" : "medium"}
              compliance_scope ${record.dig("objectRef", "resource") =~ /networkintents|secrets|configmaps/i ? "critical" : "standard"}
              geo_location "#{ENV['CLUSTER_REGION'] || 'unknown'}"
              cluster_id "#{ENV['CLUSTER_ID'] || 'unknown'}"
            </record>
          </filter>
          
          # Output to immutable audit store
          <match audit.**>
            @type elasticsearch
            @id audit_elasticsearch
            host elasticsearch-audit.nephoran-compliance.svc.cluster.local
            port 9200
            index_name audit-logs
            type_name _doc
            logstash_format true
            logstash_prefix audit-logs
            logstash_dateformat %Y.%m.%d
            include_tag_key true
            tag_key audit_tag
            <buffer>
              flush_thread_count 4
              flush_interval 30s
              chunk_limit_size 1M
              queue_limit_length 128
              retry_max_interval 30
              retry_forever true
            </buffer>
          </match>
          EOF
          
          # Start Fluentd with audit configuration
          fluentd -c /fluentd/etc/audit-fluent.conf &
          
          # Function to monitor data access patterns
          monitor_data_access() {
            echo "👀 Monitoring data access patterns..."
            
            # Query recent data access events
            curl -X GET "http://elasticsearch-audit:9200/audit-logs-*/_search" \
              -H "Content-Type: application/json" \
              -d '{
                "query": {
                  "bool": {
                    "must": [
                      {"range": {"@timestamp": {"gte": "now-1h"}}},
                      {"terms": {"audit_action": ["get", "list", "watch"]}}
                    ]
                  }
                },
                "aggs": {
                  "users": {"terms": {"field": "audit_user"}},
                  "resources": {"terms": {"field": "audit_resource"}},
                  "namespaces": {"terms": {"field": "audit_namespace"}}
                }
              }' > /tmp/access_patterns.json
              
            # Analyze for anomalies
            python3 << 'PYTHON'
            import json
            import datetime

            try:
                with open('/tmp/access_patterns.json', 'r') as f:
                    data = json.load(f)
                    
                total_hits = data.get('hits', {}).get('total', {}).get('value', 0)
                print(f"📊 Total data access events in last hour: {total_hits}")
                
                # Check for unusual access patterns
                user_buckets = data.get('aggregations', {}).get('users', {}).get('buckets', [])
                for user in user_buckets:
                    if user['doc_count'] > 100:  # High access threshold
                        print(f"⚠️ High access volume detected for user: {user['key']} ({user['doc_count']} events)")
                        
            except Exception as e:
                print(f"❌ Error analyzing access patterns: {e}")
            PYTHON
          }
          
          # Function to check compliance violations
          check_compliance_violations() {
            echo "🔍 Checking for compliance violations..."
            
            # Check for unauthorized access to restricted resources
            violations=$(curl -s -X GET "http://elasticsearch-audit:9200/audit-logs-*/_search" \
              -H "Content-Type: application/json" \
              -d '{
                "query": {
                  "bool": {
                    "must": [
                      {"range": {"@timestamp": {"gte": "now-24h"}}},
                      {"term": {"data_classification": "restricted"}},
                      {"terms": {"audit_action": ["get", "list", "watch"]}},
                      {"bool": {"must_not": {"term": {"audit_user": "system:serviceaccount:nephoran-system:nephoran-compliance-operator"}}}}
                    ]
                  }
                }
              }' | jq -r '.hits.total.value')
              
            if [ "$violations" -gt 0 ]; then
              echo "🚨 Compliance violation detected: $violations unauthorized access attempts to restricted data"
              
              # Send alert
              curl -X POST "$SLACK_WEBHOOK" \
                -H 'Content-type: application/json' \
                --data "{\"text\":\"🚨 Compliance Alert: $violations unauthorized access attempts to restricted data detected\"}"
            else
              echo "✅ No compliance violations detected in last 24 hours"
            fi
          }
          
          # Function to generate compliance reports
          generate_compliance_report() {
            echo "📋 Generating compliance report..."
            
            report_date=$(date +%Y-%m-%d)
            
            cat > /tmp/compliance-report-${report_date}.json << EOF
            {
              "report_date": "${report_date}",
              "compliance_framework": "SOX, GDPR, CCPA, FCC",
              "audit_period": "24_hours",
              "metrics": {
                "total_audit_events": $(curl -s "http://elasticsearch-audit:9200/audit-logs-*/_count" | jq -r '.count'),
                "data_access_events": $(curl -s -X GET "http://elasticsearch-audit:9200/audit-logs-*/_search" -H "Content-Type: application/json" -d '{"query":{"bool":{"must":[{"range":{"@timestamp":{"gte":"now-24h"}}},{"terms":{"audit_action":["get","list","watch"]}}]}},"track_total_hits":true}' | jq -r '.hits.total.value'),
                "data_modification_events": $(curl -s -X GET "http://elasticsearch-audit:9200/audit-logs-*/_search" -H "Content-Type: application/json" -d '{"query":{"bool":{"must":[{"range":{"@timestamp":{"gte":"now-24h"}}},{"terms":{"audit_action":["create","update","delete"]}}]}},"track_total_hits":true}' | jq -r '.hits.total.value'),
                "compliance_violations": 0,
                "encryption_coverage": "100%",
                "data_retention_compliance": "100%"
              },
              "recommendations": [
                "Continue monitoring data access patterns",
                "Ensure regular key rotation schedule",
                "Maintain audit log retention for 7 years"
              ]
            }
              EOF
            
            # Store report
            kubectl create configmap compliance-report-${report_date} \
              --from-file=/tmp/compliance-report-${report_date}.json \
              --namespace=nephoran-compliance
              
            echo "✅ Compliance report generated and stored"
          }
          
          # Main monitoring loop
          while true; do
            monitor_data_access
            check_compliance_violations
            generate_compliance_report
            
            # Wait 1 hour before next check
            sleep 3600
          done
        env:
        - name: CLUSTER_REGION
          value: "us-east-1"
        - name: CLUSTER_ID
          value: "nephoran-production"
        - name: SLACK_WEBHOOK
          valueFrom:
            secretKeyRef:
              name: compliance-notification-secrets
              key: slack-webhook
        resources:
          requests:
            cpu: 200m
            memory: 512Mi
          limits:
            cpu: 1000m
            memory: 2Gi

---
# Data Retention and Purging System
apiVersion: batch/v1
kind: CronJob
metadata:
  name: data-retention-enforcer
  namespace: nephoran-compliance
  labels:
    app: data-retention
    component: compliance
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM UTC
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: nephoran-compliance-operator
          restartPolicy: OnFailure
          containers:
          - name: retention-enforcer
            image: postgres:15-alpine
            command:
            - /bin/sh
            - -c
            - |
              #!/bin/sh
              echo "🗄️ Starting Data Retention Enforcement"
              
              # Function to enforce retention policy
              enforce_retention_policy() {
                local data_type=$1
                local retention_days=$2
                local table_name=$3
                
                echo "📅 Enforcing retention policy for $data_type ($retention_days days)"
                
                # Calculate cutoff date
                cutoff_date=$(date -d "$retention_days days ago" '+%Y-%m-%d')
                
                # Archive old data before deletion
                psql -h postgres.nephoran-system.svc.cluster.local -U postgres -d nephoran << EOF
                -- Create archive table if not exists
                CREATE TABLE IF NOT EXISTS ${table_name}_archive (LIKE ${table_name} INCLUDING ALL);

                -- Move old data to archive
                INSERT INTO ${table_name}_archive 
                SELECT * FROM ${table_name} 
                WHERE created_at < '$cutoff_date' 
                AND id NOT IN (SELECT id FROM ${table_name}_archive);

                -- Delete old data from main table
                DELETE FROM ${table_name} WHERE created_at < '$cutoff_date';

                -- Log retention action
                INSERT INTO retention_log (table_name, retention_days, cutoff_date, records_archived, records_deleted, executed_at)
                VALUES ('${table_name}', ${retention_days}, '$cutoff_date', 
                        (SELECT COUNT(*) FROM ${table_name}_archive WHERE created_at < '$cutoff_date'),
                        0, NOW());
              EOF
                
                echo "✅ Retention policy enforced for $data_type"
              }
              
              # Function to purge archived data beyond legal retention
              purge_archived_data() {
                local data_type=$1
                local purge_days=$2
                local table_name=$3
                
                echo "🔥 Purging archived data for $data_type beyond $purge_days days"
                
                purge_date=$(date -d "$purge_days days ago" '+%Y-%m-%d')
                
                psql -h postgres.nephoran-system.svc.cluster.local -U postgres -d nephoran << EOF
                -- Count records to be purged
                \set purge_count (SELECT COUNT(*) FROM ${table_name}_archive WHERE created_at < '$purge_date')

                -- Purge old archived data
                DELETE FROM ${table_name}_archive WHERE created_at < '$purge_date';

                -- Log purge action
                INSERT INTO retention_log (table_name, retention_days, cutoff_date, records_archived, records_deleted, executed_at)
                VALUES ('${table_name}_archive', ${purge_days}, '$purge_date', 0, :purge_count, NOW());
              EOF
                
                echo "✅ Archived data purged for $data_type"
              }
              
              # Function to encrypt archived data
              encrypt_archived_data() {
                local table_name=$1
                
                echo "🔐 Encrypting archived data for $table_name"
                
                # Export archived data and encrypt
                psql -h postgres.nephoran-system.svc.cluster.local -U postgres -d nephoran -c "\copy ${table_name}_archive TO '/tmp/${table_name}_archive.csv' CSV HEADER"
                
                # Encrypt the exported data
                openssl enc -aes-256-cbc -salt -in /tmp/${table_name}_archive.csv -out /tmp/${table_name}_archive.csv.enc -k "$ENCRYPTION_KEY"
                
                # Store encrypted backup
                kubectl create secret generic ${table_name}-archive-$(date +%Y%m%d) \
                  --from-file=/tmp/${table_name}_archive.csv.enc \
                  --namespace=nephoran-compliance
                  
                # Secure cleanup
                shred -u /tmp/${table_name}_archive.csv /tmp/${table_name}_archive.csv.enc
                
                echo "✅ Archived data encrypted and stored for $table_name"
              }
              
              # Initialize retention log table
              psql -h postgres.nephoran-system.svc.cluster.local -U postgres -d nephoran << 'EOF'
              CREATE TABLE IF NOT EXISTS retention_log (
                id SERIAL PRIMARY KEY,
                table_name VARCHAR(255) NOT NULL,
                retention_days INTEGER NOT NULL,
                cutoff_date DATE NOT NULL,
                records_archived INTEGER DEFAULT 0,
                records_deleted INTEGER DEFAULT 0,
                executed_at TIMESTAMP DEFAULT NOW()
              );
              EOF
              
              # Enforce retention policies based on configuration
              echo "📋 Enforcing data retention policies..."
              
              # Network Intents - 7 years retention
              enforce_retention_policy "network_intents" 2555 "network_intents"
              encrypt_archived_data "network_intents"
              
              # E2 NodeSets - 3 years retention
              enforce_retention_policy "e2_nodesets" 1095 "e2_nodesets"
              encrypt_archived_data "e2_nodesets"
              
              # System Logs - 1 year retention
              enforce_retention_policy "system_logs" 365 "system_logs"
              purge_archived_data "system_logs" 730 "system_logs"  # Purge after 2 years
              
              # Audit Logs - 7 years retention (immutable)
              # Note: Audit logs are never purged for compliance
              enforce_retention_policy "audit_logs" 2555 "audit_logs"
              encrypt_archived_data "audit_logs"
              
              # Metrics Data - 2 years retention
              enforce_retention_policy "metrics_data" 730 "metrics_data"
              purge_archived_data "metrics_data" 1095 "metrics_data"  # Purge after 3 years
              
              echo "✅ All retention policies enforced successfully"
              
              # Generate retention report
              retention_report=$(psql -h postgres.nephoran-system.svc.cluster.local -U postgres -d nephoran -t -c "
              SELECT json_build_object(
                'date', CURRENT_DATE,
                'total_tables_processed', COUNT(DISTINCT table_name),
                'total_records_archived', SUM(records_archived),
                'total_records_deleted', SUM(records_deleted)
              ) FROM retention_log WHERE executed_at >= CURRENT_DATE;
              ")
              
              echo "📊 Retention Report: $retention_report"
            env:
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-credentials
                  key: password
            - name: ENCRYPTION_KEY
              valueFrom:
                secretKeyRef:
                  name: backup-encryption-key
                  key: key

---
# Certificate Management for TLS Encryption
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: nephoran-ca-issuer
  labels:
    app: cert-manager
    component: tls
spec:
  ca:
    secretName: nephoran-ca-key-pair
---
# TLS Certificate for Nephoran Services
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: nephoran-tls-certificate
  namespace: nephoran-system
  labels:
    app: tls-certificate
    component: security
spec:
  secretName: nephoran-tls-secret
  issuerRef:
    name: nephoran-ca-issuer
    kind: ClusterIssuer
  dnsNames:
  - "*.nephoran-system.svc.cluster.local"
  - "*.nephoran-dr.svc.cluster.local"
  - "*.nephoran-compliance.svc.cluster.local"
  - "nephoran.com"
  - "*.nephoran.com"
  duration: 2160h # 90 days
  renewBefore: 360h # 15 days before expiry

---
# Network Policy for Compliance Namespace
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: compliance-network-policy
  namespace: nephoran-compliance
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: nephoran-monitoring
    - namespaceSelector:
        matchLabels:
          name: nephoran-dr
    - podSelector: {}
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: nephoran-system
    - namespaceSelector:
        matchLabels:
          name: kube-system
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80
    - protocol: UDP
      port: 53

---
# ServiceMonitor for Compliance Monitoring
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: data-protection-compliance
  namespace: nephoran-compliance
  labels:
    app: data-protection
    component: monitoring
spec:
  selector:
    matchLabels:
      app: data-protection
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics

---
# Secret for Compliance Notifications
apiVersion: v1
kind: Secret
metadata:
  name: compliance-notification-secrets
  namespace: nephoran-compliance
type: Opaque
stringData:
  slack-webhook: "https://hooks.slack.com/services/YOUR/COMPLIANCE/WEBHOOK"
  email-smtp-server: "smtp.nephoran.com"
  email-username: "compliance@nephoran.com"
  email-password: "your-smtp-password"