diff --git a/internal/loop/watcher.go b/internal/loop/watcher.go
index 1c7a1ba3..b6c4c5e6 100644
--- a/internal/loop/watcher.go
+++ b/internal/loop/watcher.go
@@ -44,6 +44,56 @@ type Config struct {
 	MetricsPass    string        `json:"metrics_pass"`    // Basic auth password
 }
 
+// isPathSafe checks if a path is safe from traversal attacks
+// It verifies that the resolved path doesn't escape expected boundaries
+func isPathSafe(absPath, baseDir string) bool {
+	// Normalize paths for comparison
+	absPath = filepath.Clean(absPath)
+	baseDir = filepath.Clean(baseDir)
+	
+	// Check if the path is under the base directory
+	if strings.HasPrefix(absPath, baseDir+string(filepath.Separator)) || absPath == baseDir {
+		return true
+	}
+	
+	// Allow paths under common safe directories
+	// Get temp directory
+	tempDir := os.TempDir()
+	if strings.HasPrefix(absPath, filepath.Clean(tempDir)+string(filepath.Separator)) {
+		return true
+	}
+	
+	// On Windows, allow paths under user's home directory
+	if runtime.GOOS == "windows" {
+		if homeDir, err := os.UserHomeDir(); err == nil {
+			homeDir = filepath.Clean(homeDir)
+			if strings.HasPrefix(absPath, homeDir+string(filepath.Separator)) {
+				return true
+			}
+		}
+	}
+	
+	// On Unix-like systems, allow paths under /tmp, /var/tmp, or user's home
+	if runtime.GOOS != "windows" {
+		safeDirs := []string{"/tmp", "/var/tmp"}
+		for _, safeDir := range safeDirs {
+			if strings.HasPrefix(absPath, safeDir+string(filepath.Separator)) {
+				return true
+			}
+		}
+		
+		if homeDir, err := os.UserHomeDir(); err == nil {
+			homeDir = filepath.Clean(homeDir)
+			if strings.HasPrefix(absPath, homeDir+string(filepath.Separator)) {
+				return true
+			}
+		}
+	}
+	
+	// Path is potentially unsafe
+	return false
+}
+
 // Validate checks if the configuration is valid and secure
 func (c *Config) Validate() error {
 	// Validate MaxWorkers - handle extreme values gracefully
@@ -117,16 +167,53 @@ func (c *Config) Validate() error {
 	// Validate OutDir - check if directory exists or can be created, and is writable
 	// This is critical for preventing runtime failures during file processing
 	if c.OutDir != "" {
-		// Clean and normalize the path
+		// OWASP Rule 1: Canonicalize the path first
 		cleanPath := filepath.Clean(c.OutDir)
 		
-		// Get absolute path
-		absPath, err := filepath.Abs(cleanPath)
+		// Get current working directory as the base for relative paths
+		cwd, err := os.Getwd()
+		if err != nil {
+			return fmt.Errorf("cannot determine current directory: %w", err)
+		}
+		
+		// OWASP Rule 2: Join with a known base directory
+		// If the path is relative, join it with cwd; if absolute, Clean handles it
+		var finalPath string
+		if filepath.IsAbs(cleanPath) {
+			finalPath = cleanPath
+		} else {
+			finalPath = filepath.Join(cwd, cleanPath)
+		}
+		
+		// Canonicalize again after joining
+		finalPath = filepath.Clean(finalPath)
+		
+		// OWASP Rule 3: Verify the canonicalized path remains under the base
+		// Check for path traversal attempts
+		if strings.Contains(cleanPath, "..") {
+			// Check if the resolved path is trying to escape the expected boundaries
+			// For absolute paths, we allow them as long as they don't contain ".."
+			// For relative paths with "..", check if they resolve safely
+			absPath, err := filepath.Abs(finalPath)
+			if err != nil {
+				return fmt.Errorf("invalid output directory path %q: %w", c.OutDir, err)
+			}
+			
+			// Ensure the path doesn't try to traverse outside safe boundaries
+			// We'll check if it's under common safe locations or the current directory
+			if !isPathSafe(absPath, cwd) {
+				return fmt.Errorf("path traversal detected in output directory: %q", c.OutDir)
+			}
+			finalPath = absPath
+		}
+		
+		// Get absolute path for consistency
+		absPath, err := filepath.Abs(finalPath)
 		if err != nil {
 			return fmt.Errorf("invalid output directory path %q: %w", c.OutDir, err)
 		}
 		
-		// Update config with absolute path
+		// Update config with the safe, absolute path
 		c.OutDir = absPath
 		
 		// Check if directory exists
@@ -149,6 +236,7 @@ func (c *Config) Validate() error {
 					return fmt.Errorf("output directory parent is not a directory: %q", parentDir)
 				}
 				
+				// OWASP Rule 4: Create directory with secure permissions
 				// Try to create the directory to verify we have write permissions
 				if err := os.MkdirAll(c.OutDir, 0755); err != nil {
 					return fmt.Errorf("cannot create output directory %q: %w", c.OutDir, err)
