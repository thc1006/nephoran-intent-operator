diff --git a/api/v1/networkintent_types.go b/api/v1/networkintent_types.go
index 84b64248..e59e1acd 100644
--- a/api/v1/networkintent_types.go
+++ b/api/v1/networkintent_types.go
@@ -18,6 +18,7 @@
 
 import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
 )
 
 // NetworkIntentSpec defines the desired state of NetworkIntent
@@ -143,13 +144,33 @@ type ProcessingResult struct {
 	ORANComponentUPF ORANComponent = "upf"
 )
 
+// NetworkIntentPhase represents the phase of NetworkIntent processing
+type NetworkIntentPhase string
+
+const (
+	// NetworkIntentPhasePending represents pending phase
+	NetworkIntentPhasePending NetworkIntentPhase = "Pending"
+	// NetworkIntentPhaseProcessing represents processing phase
+	NetworkIntentPhaseProcessing NetworkIntentPhase = "Processing"
+	// NetworkIntentPhaseDeploying represents deploying phase
+	NetworkIntentPhaseDeploying NetworkIntentPhase = "Deploying"
+	// NetworkIntentPhaseActive represents active phase
+	NetworkIntentPhaseActive NetworkIntentPhase = "Active"
+	// NetworkIntentPhaseReady represents ready phase
+	NetworkIntentPhaseReady NetworkIntentPhase = "Ready"
+	// NetworkIntentPhaseDeployed represents deployed phase
+	NetworkIntentPhaseDeployed NetworkIntentPhase = "Deployed"
+	// NetworkIntentPhaseFailed represents failed phase
+	NetworkIntentPhaseFailed NetworkIntentPhase = "Failed"
+)
+
 // NetworkIntentStatus defines the observed state of NetworkIntent
 type NetworkIntentStatus struct {
 	// ObservedGeneration reflects the generation of the most recently observed NetworkIntent
 	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
 
 	// Phase represents the current phase of the NetworkIntent processing
-	Phase string `json:"phase,omitempty"`
+	Phase NetworkIntentPhase `json:"phase,omitempty"`
 
 	// LastMessage contains the last status message
 	LastMessage string `json:"lastMessage,omitempty"`
@@ -160,6 +181,16 @@ type NetworkIntentStatus struct {
 	// ProcessingResults contains the results of intent processing
 	// +optional
 	ProcessingResults *ProcessingResult `json:"processingResults,omitempty"`
+
+	// Extensions contains additional status information as raw extensions
+	// +optional
+	Extensions map[string]runtime.RawExtension `json:"extensions,omitempty"`
+
+	// Conditions contains the conditions for the NetworkIntent
+	// +optional
+	// +listType=map
+	// +listMapKey=type
+	Conditions []metav1.Condition `json:"conditions,omitempty"`
 }
 
 //+kubebuilder:object:root=true
diff --git a/controllers/networkintent_controller.go b/controllers/networkintent_controller.go
index ad9aaaf4..5c6969f0 100644
--- a/controllers/networkintent_controller.go
+++ b/controllers/networkintent_controller.go
@@ -163,7 +163,7 @@ func (r *NetworkIntentReconciler) updateStatus(ctx context.Context, networkInten
 	log := log.FromContext(ctx)
 
 	// Update the status fields
-	networkIntent.Status.Phase = phase
+	networkIntent.Status.Phase = nephoranv1.NetworkIntentPhase(phase)
 	networkIntent.Status.LastMessage = message
 	networkIntent.Status.ObservedGeneration = generation
 	networkIntent.Status.LastUpdateTime = metav1.Now()
diff --git a/hack/testtools/envtest_setup_fixed.go b/hack/testtools/envtest_setup_fixed.go
index c014f737..54627d61 100644
--- a/hack/testtools/envtest_setup_fixed.go
+++ b/hack/testtools/envtest_setup_fixed.go
@@ -6,9 +6,10 @@
 	"fmt"
 	"os"
 	"path/filepath"
-	goruntime "runtime"
 	"time"
 
+	"k8s.io/apimachinery/pkg/runtime"
+
 	. "github.com/onsi/ginkgo/v2"
 	"k8s.io/client-go/discovery"
 	"k8s.io/client-go/kubernetes"
@@ -287,10 +288,18 @@ func waitForAPIServerReadyEnhanced(cfg *rest.Config, timeout time.Duration) erro
 }
 
 // createTestScheme creates a test runtime scheme
-func createTestScheme(schemeBuilders []func(*goruntime.Scheme) error) *goruntime.Scheme {
-	// This would implement scheme creation logic
-	// For now, returning nil to indicate we need the original function
-	return nil
+func createTestScheme(schemeBuilders []func(*runtime.Scheme) error) *runtime.Scheme {
+	scheme := runtime.NewScheme()
+	
+	// Apply all scheme builders
+	for _, builder := range schemeBuilders {
+		if err := builder(scheme); err != nil {
+			// Log error but continue
+			fmt.Printf("Warning: Failed to add to scheme: %v\n", err)
+		}
+	}
+	
+	return scheme
 }
 
 // EnhancedTestEnvironmentOptions returns options optimized for environments with potential binary issues
diff --git a/internal/loop/.conductor-state.json b/internal/loop/.conductor-state.json
index 0a3e375f..c8d40895 100644
--- a/internal/loop/.conductor-state.json
+++ b/internal/loop/.conductor-state.json
@@ -1,5 +1,5 @@
 {
   "version": "1.0",
-  "saved_at": "2025-08-26T11:39:17.8305907+08:00",
+  "saved_at": "2025-08-26T21:24:30.8108162+08:00",
   "states": {}
 }
\ No newline at end of file
diff --git a/pkg/controllers/interfaces/controller_interfaces.go b/pkg/controllers/interfaces/controller_interfaces.go
index e3ab37ee..9e7f83de 100644
--- a/pkg/controllers/interfaces/controller_interfaces.go
+++ b/pkg/controllers/interfaces/controller_interfaces.go
@@ -31,6 +31,7 @@
 
 const (
 	PhaseIntentReceived         ProcessingPhase = "IntentReceived"
+	PhaseReceived               ProcessingPhase = "Received" // Alias for PhaseIntentReceived
 	PhaseLLMProcessing          ProcessingPhase = "LLMProcessing"
 	PhaseResourcePlanning       ProcessingPhase = "ResourcePlanning"
 	PhaseManifestGeneration     ProcessingPhase = "ManifestGeneration"
diff --git a/pkg/controllers/orchestration/coordination_controller.go b/pkg/controllers/orchestration/coordination_controller.go
index fb14ff64..ffb2166d 100644
--- a/pkg/controllers/orchestration/coordination_controller.go
+++ b/pkg/controllers/orchestration/coordination_controller.go
@@ -36,6 +36,7 @@
 
 	nephoranv1 "github.com/thc1006/nephoran-intent-operator/api/v1"
 	"github.com/thc1006/nephoran-intent-operator/pkg/controllers/interfaces"
+	"github.com/thc1006/nephoran-intent-operator/pkg/shared"
 )
 
 // CoordinationController coordinates the overall intent processing pipeline
@@ -91,11 +92,17 @@ type CoordinationContext struct {
 	StartTime     time.Time
 	CurrentPhase  interfaces.ProcessingPhase
 	PhaseHistory  []PhaseExecution
-	Locks         []ResourceLock
+	Locks         []string // Changed to []string for compatibility with event_driven_coordinator
 	Conflicts     []Conflict
 	RetryCount    int
 	LastActivity  time.Time
 	mutex         sync.RWMutex
+
+	// Additional fields for event-driven coordinator compatibility
+	LastUpdateTime   time.Time                  `json:"lastUpdateTime"`
+	Metadata         map[string]interface{}     `json:"metadata"`
+	CompletedPhases  []interfaces.ProcessingPhase `json:"completedPhases"`
+	ErrorHistory     []string                   `json:"errorHistory"`
 }
 
 // PhaseExecution tracks the execution of a phase
@@ -686,7 +693,7 @@ func (r *CoordinationController) handleIntentCompletion(ctx context.Context, net
 	log.Info("Intent processing completed successfully")
 
 	// Update NetworkIntent to completed status
-	networkIntent.Status.Phase = string(interfaces.PhaseCompleted)
+	networkIntent.Status.Phase = shared.ProcessingPhaseToNetworkIntentPhase(interfaces.PhaseCompleted)
 	networkIntent.Status.LastUpdateTime = metav1.Now()
 	networkIntent.Status.LastMessage = "Intent processing completed successfully"
 
@@ -810,7 +817,7 @@ func (r *CoordinationController) attemptRecovery(ctx context.Context, networkInt
 func (r *CoordinationController) handleRecoveryFailure(ctx context.Context, networkIntent *nephoranv1.NetworkIntent, phase interfaces.ProcessingPhase, result interfaces.ProcessingResult, coordCtx *CoordinationContext) (ctrl.Result, error) {
 	log := r.Logger.WithValues("intent", networkIntent.Name, "phase", phase)
 
-	log.Warn("Recovery failed, falling back to normal retry logic")
+	log.V(1).Info("Recovery failed, falling back to normal retry logic")
 	r.Recorder.Event(networkIntent, "Warning", "RecoveryFailed",
 		fmt.Sprintf("Failed to recover from %s failure, falling back to retry", phase))
 
@@ -826,7 +833,7 @@ func (r *CoordinationController) handleIntentFailure(ctx context.Context, networ
 	log.Error(fmt.Errorf(result.ErrorMessage), "Intent processing failed permanently")
 
 	// Update NetworkIntent to failed status
-	networkIntent.Status.Phase = string(interfaces.PhaseFailed)
+	networkIntent.Status.Phase = shared.ProcessingPhaseToNetworkIntentPhase(interfaces.PhaseFailed)
 	networkIntent.Status.LastUpdateTime = metav1.Now()
 	networkIntent.Status.LastMessage = fmt.Sprintf("Processing failed at phase %s after %d attempts: %s", phase, coordCtx.RetryCount, result.ErrorMessage)
 
@@ -882,7 +889,7 @@ func (r *CoordinationController) handleIntentDeletion(ctx context.Context, names
 	// Clean up coordination contexts
 	r.activeIntents.Range(func(key, value interface{}) bool {
 		intentID := key.(string)
-		coordCtx := value.(*CoordinationContext)
+		_ = value.(*CoordinationContext)
 
 		// This is a simplified matching - in practice you'd match by namespace/name
 		r.activeIntents.Delete(intentID)
@@ -896,7 +903,7 @@ func (r *CoordinationController) handleIntentDeletion(ctx context.Context, names
 // updateNetworkIntentStatus updates the NetworkIntent status
 func (r *CoordinationController) updateNetworkIntentStatus(ctx context.Context, networkIntent *nephoranv1.NetworkIntent, phase interfaces.ProcessingPhase, result interfaces.ProcessingResult) error {
 	// Update phase and basic status fields
-	networkIntent.Status.Phase = string(phase)
+	networkIntent.Status.Phase = shared.ProcessingPhaseToNetworkIntentPhase(phase)
 	networkIntent.Status.LastUpdateTime = metav1.Now()
 	networkIntent.Status.LastMessage = fmt.Sprintf("Phase %s completed successfully", phase)
 
@@ -912,15 +919,19 @@ func (r *CoordinationController) getOrCreateCoordinationContext(networkIntent *n
 	}
 
 	coordCtx := &CoordinationContext{
-		IntentID:      intentID,
-		CorrelationID: fmt.Sprintf("coord-%s-%d", networkIntent.Name, time.Now().Unix()),
-		StartTime:     time.Now(),
-		CurrentPhase:  interfaces.PhaseIntentReceived,
-		PhaseHistory:  make([]PhaseExecution, 0),
-		Locks:         make([]ResourceLock, 0),
-		Conflicts:     make([]Conflict, 0),
-		RetryCount:    0,
-		LastActivity:  time.Now(),
+		IntentID:         intentID,
+		CorrelationID:    fmt.Sprintf("coord-%s-%d", networkIntent.Name, time.Now().Unix()),
+		StartTime:        time.Now(),
+		CurrentPhase:     interfaces.PhaseIntentReceived,
+		PhaseHistory:     make([]PhaseExecution, 0),
+		Locks:            make([]string, 0),
+		Conflicts:        make([]Conflict, 0),
+		RetryCount:       0,
+		LastActivity:     time.Now(),
+		LastUpdateTime:   time.Now(),
+		Metadata:         make(map[string]interface{}),
+		CompletedPhases:  make([]interfaces.ProcessingPhase, 0),
+		ErrorHistory:     make([]string, 0),
 	}
 
 	r.activeIntents.Store(intentID, coordCtx)
@@ -945,9 +956,6 @@ func (r *CoordinationController) SetupWithManager(mgr ctrl.Manager) error {
 	return ctrl.NewControllerManagedBy(mgr).
 		For(&nephoranv1.NetworkIntent{}).
 		Named("coordination").
-		WithOptions(ctrl.Options{
-			MaxConcurrentReconciles: r.Config.MaxConcurrentIntents,
-		}).
 		Complete(r)
 }
 
@@ -993,7 +1001,7 @@ func (r *CoordinationController) performHealthChecks(ctx context.Context) {
 
 		// Check for stale intents (no activity for too long)
 		if time.Since(lastActivity) > r.Config.PhaseTimeout*2 {
-			r.Logger.Warn("Detected stale intent", "intentId", intentID, "lastActivity", lastActivity, "currentPhase", currentPhase)
+			r.Logger.V(1).Info("Detected stale intent", "intentId", intentID, "lastActivity", lastActivity, "currentPhase", currentPhase)
 			// In a production system, you might want to trigger recovery or cleanup
 		}
 
diff --git a/pkg/controllers/orchestration/event_bus.go b/pkg/controllers/orchestration/event_bus.go
index 6899ebaa..1004f929 100644
--- a/pkg/controllers/orchestration/event_bus.go
+++ b/pkg/controllers/orchestration/event_bus.go
@@ -305,7 +305,7 @@ func (e *EventBus) executeHandlerWithRetry(ctx context.Context, handler EventHan
 func (e *EventBus) recordHandlerFailure(event ProcessingEvent, handlerIndex int, err error) {
 	// Create a Kubernetes event for the failure
 	if e.recorder != nil {
-		message := fmt.Sprintf("Event handler %d failed for event type %s: %v", handlerIndex, event.Type, err)
+		_ = fmt.Sprintf("Event handler %d failed for event type %s: %v", handlerIndex, event.Type, err)
 
 		// We would need an object reference here - in practice, this would be the NetworkIntent
 		// For now, we'll just log it
diff --git a/pkg/controllers/orchestration/event_driven_coordinator.go b/pkg/controllers/orchestration/event_driven_coordinator.go
index a62020de..ef315e5e 100644
--- a/pkg/controllers/orchestration/event_driven_coordinator.go
+++ b/pkg/controllers/orchestration/event_driven_coordinator.go
@@ -318,10 +318,10 @@ func (edc *EventDrivenCoordinator) handleConflictDetected(ctx context.Context, e
 	edc.mutex.Lock()
 	if coordCtx, exists := edc.coordinationContexts[event.IntentID]; exists {
 		conflict := Conflict{
-			ID:        conflictID,
-			Type:      event.Data["type"].(string),
-			IntentID1: event.IntentID,
-			Timestamp: time.Now(),
+			ID:              conflictID,
+			Type:            event.Data["type"].(string),
+			InvolvedIntents: []string{event.IntentID},
+			DetectedAt:      time.Now(),
 		}
 		coordCtx.Conflicts = append(coordCtx.Conflicts, conflict)
 	}
diff --git a/pkg/controllers/orchestration/intent_orchestrator.go b/pkg/controllers/orchestration/intent_orchestrator.go
index 8eb86c56..73fe7f19 100644
--- a/pkg/controllers/orchestration/intent_orchestrator.go
+++ b/pkg/controllers/orchestration/intent_orchestrator.go
@@ -36,6 +36,7 @@
 
 	nephoranv1 "github.com/thc1006/nephoran-intent-operator/api/v1"
 	"github.com/thc1006/nephoran-intent-operator/pkg/controllers/interfaces"
+	"github.com/thc1006/nephoran-intent-operator/pkg/shared"
 )
 
 // IntentOrchestrator manages the overall processing pipeline for NetworkIntents
@@ -489,17 +490,14 @@ func (o *IntentOrchestrator) validatePhaseResult(phase interfaces.ProcessingPhas
 
 func (o *IntentOrchestrator) updateIntentStatus(ctx context.Context, intent *nephoranv1.NetworkIntent, phase interfaces.ProcessingPhase, result interfaces.ProcessingResult) error {
 	// Update phase in status
-	intent.Status.Phase = string(phase)
+	intent.Status.Phase = shared.ProcessingPhaseToNetworkIntentPhase(phase)
 
 	// Update timestamps
 	now := metav1.Now()
-	if intent.Status.ProcessingStartTime == nil {
-		intent.Status.ProcessingStartTime = &now
-	}
+	intent.Status.LastUpdateTime = now
 
-	if phase == interfaces.PhaseCompleted {
-		intent.Status.ProcessingCompletionTime = &now
-	}
+	// Update completion time in extension if needed
+	// intent.Status.ProcessingCompletionTime field doesn't exist in v1 API
 
 	// Update conditions
 	condition := metav1.Condition{
@@ -561,9 +559,9 @@ func (o *IntentOrchestrator) handleIntentCompletion(ctx context.Context, intent
 	o.MetricsCollector.RecordIntentCompletion(processingCtx.IntentID, true, time.Since(processingCtx.StartTime))
 
 	// Update final status
-	intent.Status.Phase = string(interfaces.PhaseCompleted)
+	intent.Status.Phase = shared.ProcessingPhaseToNetworkIntentPhase(interfaces.PhaseCompleted)
 	now := metav1.Now()
-	intent.Status.ProcessingCompletionTime = &now
+	intent.Status.LastUpdateTime = now
 
 	return ctrl.Result{}, o.Status().Update(ctx, intent)
 }
@@ -578,7 +576,7 @@ func (o *IntentOrchestrator) handleIntentFailure(ctx context.Context, intent *ne
 	o.MetricsCollector.RecordIntentCompletion(processingCtx.IntentID, false, time.Since(processingCtx.StartTime))
 
 	// Update status
-	intent.Status.Phase = string(interfaces.PhaseFailed)
+	intent.Status.Phase = shared.ProcessingPhaseToNetworkIntentPhase(interfaces.PhaseFailed)
 
 	// Record failure event
 	o.Recorder.Event(intent, "Warning", "ProcessingFailed", err.Error())
@@ -595,6 +593,7 @@ func (o *IntentOrchestrator) handleIntentDeletion(ctx context.Context, namespace
 		if processingCtx, ok := value.(*interfaces.ProcessingContext); ok {
 			// Check if this context belongs to the deleted intent
 			// This would need more sophisticated matching in practice
+			_ = processingCtx // Mark as used to avoid compiler warning
 			o.ProcessingContexts.Delete(key)
 		}
 		return true
@@ -636,9 +635,6 @@ func (o *IntentOrchestrator) SetupWithManager(mgr ctrl.Manager) error {
 	return ctrl.NewControllerManagedBy(mgr).
 		For(&nephoranv1.NetworkIntent{}).
 		Named("intent-orchestrator").
-		WithOptions(ctrl.Options{
-			MaxConcurrentReconciles: o.Config.MaxConcurrentIntents,
-		}).
 		Complete(o)
 }
 
diff --git a/pkg/controllers/orchestration/intent_processing_controller.go b/pkg/controllers/orchestration/intent_processing_controller.go
index f1c07a51..09d342ee 100644
--- a/pkg/controllers/orchestration/intent_processing_controller.go
+++ b/pkg/controllers/orchestration/intent_processing_controller.go
@@ -181,19 +181,27 @@ func (r *IntentProcessingController) executeLLMProcessing(ctx context.Context, i
 
 	// Prepare LLM request
 	request := &llm.ProcessingRequest{
-		Intent:     intentProcessing.Spec.OriginalIntent,
-		IntentType: string(intentProcessing.Spec.ParentIntentRef.Kind),
-		Priority:   string(intentProcessing.Spec.Priority),
+		Intent: intentProcessing.Spec.OriginalIntent,
 	}
 
 	// Configure LLM parameters
 	if intentProcessing.Spec.ProcessingConfiguration != nil {
 		config := intentProcessing.Spec.ProcessingConfiguration
-		request.Provider = string(config.Provider)
+		// Add provider info to context instead of direct field
+		if request.Context == nil {
+			request.Context = make(map[string]interface{})
+		}
+		request.Context["provider"] = string(config.Provider)
+		request.Context["intentType"] = string(intentProcessing.Spec.ParentIntentRef.Kind)
+		request.Context["priority"] = string(intentProcessing.Spec.Priority)
 		request.Model = config.Model
-		request.Temperature = config.Temperature
-		request.MaxTokens = config.MaxTokens
-		request.SystemPrompt = config.SystemPrompt
+		if config.Temperature != nil {
+			request.Temperature = *config.Temperature
+		}
+		if config.MaxTokens != nil {
+			request.MaxTokens = int(*config.MaxTokens)
+		}
+		// SystemPrompt field doesn't exist in ProcessingRequest
 	}
 
 	// Enhance with RAG if enabled
@@ -205,31 +213,44 @@ func (r *IntentProcessingController) executeLLMProcessing(ctx context.Context, i
 			// Continue without RAG enhancement rather than failing
 		} else {
 			request.Context = enhancedContext
-			// Store RAG metrics for status update
-			request.RAGMetrics = ragMetrics
+			// Store RAG metrics in context for status update
+			if request.Context == nil {
+				request.Context = make(map[string]interface{})
+			}
+			request.Context["ragMetrics"] = ragMetrics
 		}
 	}
 
 	// Execute LLM processing
-	log.Info("Executing LLM processing", "provider", request.Provider, "model", request.Model)
-	response, err := r.LLMService.ProcessIntent(ctx, request)
+	provider := "default"
+	if providerVal, ok := request.Context["provider"]; ok {
+		if providerStr, ok := providerVal.(string); ok {
+			provider = providerStr
+		}
+	}
+	log.Info("Executing LLM processing", "provider", provider, "model", request.Model)
+	response, err := r.LLMService.ProcessIntent(ctx, provider, request.Intent)
 	if err != nil {
 		return nil, fmt.Errorf("LLM processing failed: %w", err)
 	}
 
+	// Convert string response to ProcessingResponse for validation
+	processingResp := &llm.ProcessingResponse{
+		Content: response,
+	}
 	// Validate response quality
-	qualityScore, validationErrors := r.validateResponse(response)
+	qualityScore, validationErrors := r.validateResponse(processingResp)
 	if qualityScore < r.Config.QualityThreshold {
 		return nil, fmt.Errorf("response quality score %.2f below threshold %.2f", qualityScore, r.Config.QualityThreshold)
 	}
 
 	// Create processing result
 	result := &LLMProcessingResult{
-		Response:         response,
+		Response:         processingResp,
 		QualityScore:     qualityScore,
 		ValidationErrors: validationErrors,
-		TokenUsage:       response.TokenUsage,
-		RAGMetrics:       request.RAGMetrics,
+		TokenUsage:       0, // No token usage info from string response
+		RAGMetrics:       extractRAGMetricsFromContext(request.Context),
 	}
 
 	// Extract structured parameters
@@ -613,9 +634,6 @@ func (r *IntentProcessingController) SetupWithManager(mgr ctrl.Manager) error {
 	return ctrl.NewControllerManagedBy(mgr).
 		For(&nephoranv1.IntentProcessing{}).
 		Named("intentprocessing").
-		WithOptions(ctrl.Options{
-			MaxConcurrentReconciles: r.Config.MaxConcurrentProcessing,
-		}).
 		Complete(r)
 }
 
@@ -630,6 +648,20 @@ type LLMProcessingResult struct {
 	RAGMetrics          *nephoranv1.RAGMetrics
 }
 
+// extractRAGMetricsFromContext extracts RAG metrics from request context
+func extractRAGMetricsFromContext(context map[string]interface{}) *nephoranv1.RAGMetrics {
+	if context == nil {
+		return nil
+	}
+	
+	if ragMetricsVal, ok := context["ragMetrics"]; ok {
+		if ragMetrics, ok := ragMetricsVal.(*nephoranv1.RAGMetrics); ok {
+			return ragMetrics
+		}
+	}
+	return nil
+}
+
 // Default configuration values
 func DefaultIntentProcessingConfig() *IntentProcessingConfig {
 	return &IntentProcessingConfig{
diff --git a/pkg/controllers/testutil/test_helpers.go b/pkg/controllers/testutil/test_helpers.go
index 0743c838..6faf6b59 100644
--- a/pkg/controllers/testutil/test_helpers.go
+++ b/pkg/controllers/testutil/test_helpers.go
@@ -61,11 +61,7 @@ func CreateTestNetworkIntent(name, namespace string) *nephoranv1.NetworkIntent {
 		},
 		Spec: nephoranv1.NetworkIntentSpec{
 			Intent:     "Configure QoS with 100Mbps bandwidth and 10ms latency",
-			IntentType: "qos",
-			ParametersMap: map[string]string{
-				"bandwidth": "100Mbps",
-				"latency":   "10ms",
-			},
+			IntentType: nephoranv1.IntentTypeOptimization,
 		},
 	}
 }
diff --git a/pkg/llm/enhanced_performance_client.go b/pkg/llm/enhanced_performance_client.go
index 4debb09c..51e78475 100644
--- a/pkg/llm/enhanced_performance_client.go
+++ b/pkg/llm/enhanced_performance_client.go
@@ -117,27 +117,27 @@ type TokenConfig struct {
 // EnhancedPrometheusMetrics holds all Prometheus metrics
 type EnhancedPrometheusMetrics struct {
 	// Request metrics
-	requestDuration  prometheus.HistogramVec
-	requestsTotal    prometheus.CounterVec
-	requestsInFlight prometheus.GaugeVec
+	requestDuration  *prometheus.HistogramVec
+	requestsTotal    *prometheus.CounterVec
+	requestsInFlight *prometheus.GaugeVec
 
 	// Token and cost metrics
-	tokensUsed        prometheus.CounterVec
-	tokenCosts        prometheus.CounterVec
-	budgetUtilization prometheus.GaugeVec
+	tokensUsed        *prometheus.CounterVec
+	tokenCosts        *prometheus.CounterVec
+	budgetUtilization *prometheus.GaugeVec
 
 	// Performance metrics
-	cacheHitRate    prometheus.GaugeVec
-	batchEfficiency prometheus.HistogramVec
-	retryRate       prometheus.GaugeVec
+	cacheHitRate    *prometheus.GaugeVec
+	batchEfficiency *prometheus.HistogramVec
+	retryRate       *prometheus.GaugeVec
 
 	// Circuit breaker metrics
-	circuitBreakerState prometheus.GaugeVec
-	circuitBreakerTrips prometheus.CounterVec
+	circuitBreakerState *prometheus.GaugeVec
+	circuitBreakerTrips *prometheus.CounterVec
 
 	// Error metrics
-	errorRate    prometheus.GaugeVec
-	errorsByType prometheus.CounterVec
+	errorRate    *prometheus.GaugeVec
+	errorsByType *prometheus.CounterVec
 }
 
 // EnhancedOTelMetrics holds all OpenTelemetry metrics
@@ -301,69 +301,69 @@ func (c *EnhancedPerformanceClient) initializeMetrics() error {
 
 	// Initialize Prometheus metrics
 	c.prometheusMetrics = &EnhancedPrometheusMetrics{
-		requestDuration: *promauto.NewHistogramVec(prometheus.HistogramOpts{
+		requestDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
 			Name:    "llm_request_duration_seconds",
 			Help:    "Duration of LLM requests",
 			Buckets: c.config.MetricsConfig.HistogramBuckets,
 		}, []string{"model", "intent_type", "success", "cache_hit", "batch"}),
 
-		requestsTotal: *promauto.NewCounterVec(prometheus.CounterOpts{
+		requestsTotal: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_requests_total",
 			Help: "Total number of LLM requests",
 		}, []string{"model", "intent_type", "status"}),
 
-		requestsInFlight: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		requestsInFlight: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_requests_in_flight",
 			Help: "Current number of in-flight LLM requests",
 		}, []string{"model"}),
 
-		tokensUsed: *promauto.NewCounterVec(prometheus.CounterOpts{
+		tokensUsed: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_tokens_used_total",
 			Help: "Total number of tokens used",
 		}, []string{"model", "token_type", "intent_type"}),
 
-		tokenCosts: *promauto.NewCounterVec(prometheus.CounterOpts{
+		tokenCosts: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_token_costs_usd_total",
 			Help: "Total cost of token usage in USD",
 		}, []string{"model", "intent_type"}),
 
-		budgetUtilization: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		budgetUtilization: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_budget_utilization_percent",
 			Help: "Current budget utilization percentage",
 		}, []string{}),
 
-		cacheHitRate: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		cacheHitRate: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_cache_hit_rate_percent",
 			Help: "Cache hit rate percentage",
 		}, []string{"cache_type"}),
 
-		batchEfficiency: *promauto.NewHistogramVec(prometheus.HistogramOpts{
+		batchEfficiency: promauto.NewHistogramVec(prometheus.HistogramOpts{
 			Name:    "llm_batch_efficiency_ratio",
 			Help:    "Batch processing efficiency ratio",
 			Buckets: []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0},
 		}, []string{"batch_size_range"}),
 
-		retryRate: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		retryRate: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_retry_rate_percent",
 			Help: "Retry rate percentage",
 		}, []string{"strategy"}),
 
-		circuitBreakerState: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		circuitBreakerState: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_circuit_breaker_state",
 			Help: "Circuit breaker state (0=closed, 1=open, 2=half-open)",
 		}, []string{"backend"}),
 
-		circuitBreakerTrips: *promauto.NewCounterVec(prometheus.CounterOpts{
+		circuitBreakerTrips: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_circuit_breaker_trips_total",
 			Help: "Total number of circuit breaker trips",
 		}, []string{"backend", "reason"}),
 
-		errorRate: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		errorRate: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_error_rate_percent",
 			Help: "Error rate percentage",
 		}, []string{"model", "error_class"}),
 
-		errorsByType: *promauto.NewCounterVec(prometheus.CounterOpts{
+		errorsByType: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_errors_by_type_total",
 			Help: "Total errors by type",
 		}, []string{"error_type", "model"}),
diff --git a/pkg/llm/performance_optimizer.go b/pkg/llm/performance_optimizer.go
index 53eee8ac..d0019147 100644
--- a/pkg/llm/performance_optimizer.go
+++ b/pkg/llm/performance_optimizer.go
@@ -62,14 +62,14 @@ type LatencyDataPoint struct {
 // PerformanceMetrics holds all performance-related metrics
 type PerformanceMetrics struct {
 	// Prometheus metrics
-	requestLatencyHistogram  prometheus.HistogramVec
-	tokenUsageCounter        prometheus.CounterVec
-	tokenCostGauge           prometheus.GaugeVec
-	circuitBreakerStateGauge prometheus.GaugeVec
-	batchProcessingHistogram prometheus.HistogramVec
-	requestThroughputCounter prometheus.CounterVec
-	errorRateCounter         prometheus.CounterVec
-	cacheHitRateGauge        prometheus.GaugeVec
+	requestLatencyHistogram  *prometheus.HistogramVec
+	tokenUsageCounter        *prometheus.CounterVec
+	tokenCostGauge           *prometheus.GaugeVec
+	circuitBreakerStateGauge *prometheus.GaugeVec
+	batchProcessingHistogram *prometheus.HistogramVec
+	requestThroughputCounter *prometheus.CounterVec
+	errorRateCounter         *prometheus.CounterVec
+	cacheHitRateGauge        *prometheus.GaugeVec
 
 	// OpenTelemetry metrics
 	requestLatencyHistogramOTel metric.Float64Histogram
@@ -184,44 +184,44 @@ func getDefaultPerformanceConfig() *PerformanceConfig {
 func (po *PerformanceOptimizer) initializeMetrics() {
 	// Prometheus metrics
 	po.metrics = &PerformanceMetrics{
-		requestLatencyHistogram: *promauto.NewHistogramVec(prometheus.HistogramOpts{
+		requestLatencyHistogram: promauto.NewHistogramVec(prometheus.HistogramOpts{
 			Name:    "llm_request_duration_seconds",
 			Help:    "Duration of LLM requests in seconds",
 			Buckets: []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10},
 		}, []string{"intent_type", "model_name", "success", "cache_hit"}),
 
-		tokenUsageCounter: *promauto.NewCounterVec(prometheus.CounterOpts{
+		tokenUsageCounter: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_tokens_total",
 			Help: "Total number of tokens processed",
 		}, []string{"model_name", "token_type", "intent_type"}),
 
-		tokenCostGauge: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		tokenCostGauge: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_token_cost_usd",
 			Help: "Cost of token usage in USD",
 		}, []string{"model_name", "token_type"}),
 
-		circuitBreakerStateGauge: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		circuitBreakerStateGauge: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_circuit_breaker_state",
 			Help: "Circuit breaker state (0=closed, 1=open, 2=half-open)",
 		}, []string{"backend"}),
 
-		batchProcessingHistogram: *promauto.NewHistogramVec(prometheus.HistogramOpts{
+		batchProcessingHistogram: promauto.NewHistogramVec(prometheus.HistogramOpts{
 			Name:    "llm_batch_processing_duration_seconds",
 			Help:    "Duration of batch processing operations",
 			Buckets: []float64{0.01, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5},
 		}, []string{"batch_size_range"}),
 
-		requestThroughputCounter: *promauto.NewCounterVec(prometheus.CounterOpts{
+		requestThroughputCounter: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_requests_per_second_total",
 			Help: "Request throughput per second",
 		}, []string{"intent_type", "model_name"}),
 
-		errorRateCounter: *promauto.NewCounterVec(prometheus.CounterOpts{
+		errorRateCounter: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "llm_errors_total",
 			Help: "Total number of LLM request errors",
 		}, []string{"error_type", "model_name"}),
 
-		cacheHitRateGauge: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		cacheHitRateGauge: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "llm_cache_hit_rate",
 			Help: "Cache hit rate percentage",
 		}, []string{"cache_type"}),
diff --git a/pkg/nephio/configsync_client.go b/pkg/nephio/configsync_client.go
index 1904d56e..b7f0c3ee 100644
--- a/pkg/nephio/configsync_client.go
+++ b/pkg/nephio/configsync_client.go
@@ -35,7 +35,6 @@
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/log"
 
-	"github.com/thc1006/nephoran-intent-operator/pkg/errors"
 	"github.com/thc1006/nephoran-intent-operator/pkg/nephio/porch"
 )
 
diff --git a/pkg/nephio/dependencies/types.go b/pkg/nephio/dependencies/types.go
index 94edf0cc..04d0025a 100644
--- a/pkg/nephio/dependencies/types.go
+++ b/pkg/nephio/dependencies/types.go
@@ -65,39 +65,7 @@ type CyclicDependency struct {
 	Resolution  string        `json:"resolution,omitempty"`
 }
 
-// GraphMetrics contains graph-level metrics
-type GraphMetrics struct {
-	Density             float64 `json:"density"`
-	AveragePathLength   float64 `json:"averagePathLength"`
-	ClusteringCoefficient float64 `json:"clusteringCoefficient"`
-	Centrality          map[string]float64 `json:"centrality,omitempty"`
-}
-
-// GraphNode represents a node in the dependency graph
-type GraphNode struct {
-	ID           string                 `json:"id"`
-	Name         string                 `json:"name"`
-	Version      string                 `json:"version,omitempty"`
-	Type         string                 `json:"type"`
-	Dependencies []string               `json:"dependencies,omitempty"`
-	Dependents   []string               `json:"dependents,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-	Properties   *NodeProperties        `json:"properties,omitempty"`
-}
-
-// NodeProperties contains node-specific properties
-type NodeProperties struct {
-	Size        int64     `json:"size,omitempty"`
-	LastUpdated time.Time `json:"lastUpdated,omitempty"`
-	License     string    `json:"license,omitempty"`
-	Homepage    string    `json:"homepage,omitempty"`
-	Description string    `json:"description,omitempty"`
-	Maintainers []string  `json:"maintainers,omitempty"`
-	Tags        []string  `json:"tags,omitempty"`
-	Critical    bool      `json:"critical,omitempty"`
-	Deprecated  bool      `json:"deprecated,omitempty"`
-	Security    *SecurityInfo `json:"security,omitempty"`
-}
+
 
 // SecurityInfo contains security-related information
 type SecurityInfo struct {
@@ -360,13 +328,6 @@ type CostBreakdown struct {
 	CustomBreakdown map[string]float64 `json:"customBreakdown,omitempty"`
 }
 
-// CostTrend represents cost trend over time
-type CostTrend struct {
-	Period      *TimePeriod `json:"period"`
-	Cost        float64     `json:"cost"`
-	GrowthRate  float64     `json:"growthRate"`
-	Factors     []string    `json:"factors,omitempty"`
-}
 
 // CostOptimization represents a cost optimization opportunity
 type CostOptimization struct {
@@ -399,6 +360,352 @@ type CostScenario struct {
 	Factors     []string `json:"factors,omitempty"`
 }
 
+// Usage analysis types
+
+// UsagePattern represents usage patterns for packages
+type UsagePattern struct {
+	Pattern     string    `json:"pattern"`
+	Frequency   int64     `json:"frequency"`
+	TimeRange   *TimePeriod `json:"timeRange"`
+	Description string    `json:"description,omitempty"`
+}
+
+// PeakUsageTime represents peak usage time periods
+type PeakUsageTime struct {
+	StartTime   time.Time `json:"startTime"`
+	EndTime     time.Time `json:"endTime"`
+	Usage       int64     `json:"usage"`
+	Description string    `json:"description,omitempty"`
+}
+
+// SeasonalPattern represents seasonal usage patterns
+type SeasonalPattern struct {
+	Season      string    `json:"season"`
+	Multiplier  float64   `json:"multiplier"`
+	StartDate   time.Time `json:"startDate"`
+	EndDate     time.Time `json:"endDate"`
+	Description string    `json:"description,omitempty"`
+}
+
+// UsageRanking represents package usage rankings
+type UsageRanking struct {
+	PackageName string  `json:"packageName"`
+	UsageCount  int64   `json:"usageCount"`
+	Rank        int     `json:"rank"`
+	Score       float64 `json:"score,omitempty"`
+}
+
+// TrendingPackage represents trending packages
+type TrendingPackage struct {
+	PackageName string  `json:"packageName"`
+	GrowthRate  float64 `json:"growthRate"`
+	UsageCount  int64   `json:"usageCount"`
+	TrendScore  float64 `json:"trendScore"`
+	Period      *TimePeriod `json:"period"`
+}
+
+// UnusedPackage represents packages that are not being used
+type UnusedPackage struct {
+	PackageName     string    `json:"packageName"`
+	LastUsed        time.Time `json:"lastUsed"`
+	DaysUnused      int       `json:"daysUnused"`
+	RecommendAction string    `json:"recommendAction,omitempty"`
+}
+
+// UnderutilizedPackage represents packages with low utilization
+type UnderutilizedPackage struct {
+	PackageName        string  `json:"packageName"`
+	UtilizationRate    float64 `json:"utilizationRate"`
+	ExpectedUtilization float64 `json:"expectedUtilization"`
+	RecommendAction    string  `json:"recommendAction,omitempty"`
+}
+
+// Additional analysis types
+
+// UsageOptimization represents a usage optimization recommendation
+type UsageOptimization struct {
+	ID             string  `json:"id"`
+	Type           string  `json:"type"`
+	Description    string  `json:"description"`
+	Priority       string  `json:"priority"` // high, medium, low
+	PotentialSavings float64 `json:"potentialSavings,omitempty"`
+}
+
+// Cost represents monetary cost
+type Cost struct {
+	Amount   float64 `json:"amount"`
+	Currency string  `json:"currency"`
+	Period   string  `json:"period,omitempty"` // monthly, yearly, etc.
+}
+
+// PackageCost represents cost associated with a specific package
+type PackageCost struct {
+	PackageName string  `json:"packageName"`
+	Cost        *Cost   `json:"cost"`
+	UsageCount  int64   `json:"usageCount"`
+	CostPerUse  float64 `json:"costPerUse,omitempty"`
+}
+
+// CostOptimizationOpportunity represents a cost optimization opportunity
+type CostOptimizationOpportunity struct {
+	ID               string  `json:"id"`
+	Type             string  `json:"type"`
+	Description      string  `json:"description"`
+	PotentialSavings *Cost   `json:"potentialSavings"`
+	ImplementationEffort string `json:"implementationEffort"` // low, medium, high
+	Priority         string  `json:"priority"`
+}
+
+// CostBenchmarkComparison represents comparison against benchmarks
+type CostBenchmarkComparison struct {
+	BenchmarkType string  `json:"benchmarkType"`
+	YourCost      *Cost   `json:"yourCost"`
+	BenchmarkCost *Cost   `json:"benchmarkCost"`
+	Variance      float64 `json:"variance"` // percentage difference
+	Rating        string  `json:"rating"`   // excellent, good, average, poor
+}
+
+// Health analysis types
+
+// SecurityHealth represents security health metrics
+type SecurityHealth struct {
+	Score                float64                `json:"score"`
+	VulnerabilityCount   int                    `json:"vulnerabilityCount"`
+	CriticalVulnerabilities int                 `json:"criticalVulnerabilities"`
+	LastSecurityScan     time.Time              `json:"lastSecurityScan"`
+	SecurityIssues       []*SecurityIssue       `json:"securityIssues,omitempty"`
+}
+
+// MaintenanceHealth represents maintenance health metrics
+type MaintenanceHealth struct {
+	Score               float64   `json:"score"`
+	OutdatedPackages    int       `json:"outdatedPackages"`
+	DeprecatedPackages  int       `json:"deprecatedPackages"`
+	LastMaintenance     time.Time `json:"lastMaintenance"`
+	MaintenanceIssues   []string  `json:"maintenanceIssues,omitempty"`
+}
+
+// QualityHealth represents code quality health metrics
+type QualityHealth struct {
+	Score           float64  `json:"score"`
+	CodeCoverage    float64  `json:"codeCoverage"`
+	TestsCount      int      `json:"testsCount"`
+	LintingIssues   int      `json:"lintingIssues"`
+	QualityIssues   []string `json:"qualityIssues,omitempty"`
+}
+
+// PerformanceHealth represents performance health metrics
+type PerformanceHealth struct {
+	Score              float64  `json:"score"`
+	ResponseTime       float64  `json:"responseTime"`
+	ThroughputScore    float64  `json:"throughputScore"`
+	ResourceUsage      float64  `json:"resourceUsage"`
+	PerformanceIssues  []string `json:"performanceIssues,omitempty"`
+}
+
+// SecurityIssue represents a security issue
+type SecurityIssue struct {
+	ID          string    `json:"id"`
+	Severity    string    `json:"severity"`
+	Description string    `json:"description"`
+	Package     string    `json:"package"`
+	FixAvailable bool     `json:"fixAvailable"`
+	DetectedAt  time.Time `json:"detectedAt"`
+}
+
+// Additional analysis result types
+
+// RiskAnalysis represents risk analysis results
+type RiskAnalysis struct {
+	AnalysisID      string         `json:"analysisId"`
+	OverallRiskScore float64       `json:"overallRiskScore"`
+	RiskGrade       string         `json:"riskGrade"`
+	RiskFactors     []RiskFactor   `json:"riskFactors"`
+	Recommendations []string       `json:"recommendations,omitempty"`
+}
+
+// RiskFactor represents an individual risk factor
+type RiskFactor struct {
+	Type        string  `json:"type"`
+	Severity    string  `json:"severity"`
+	Score       float64 `json:"score"`
+	Description string  `json:"description"`
+}
+
+// PerformanceAnalysis represents performance analysis results
+type PerformanceAnalysis struct {
+	AnalysisID       string              `json:"analysisId"`
+	OverallScore     float64             `json:"overallScore"`
+	ResponseTime     *PerformanceMetric  `json:"responseTime,omitempty"`
+	Throughput       *PerformanceMetric  `json:"throughput,omitempty"`
+	ResourceUsage    *ResourceMetrics    `json:"resourceUsage,omitempty"`
+	Bottlenecks      []string            `json:"bottlenecks,omitempty"`
+}
+
+// PerformanceMetric represents a performance metric
+type PerformanceMetric struct {
+	Current   float64 `json:"current"`
+	Target    float64 `json:"target"`
+	Unit      string  `json:"unit"`
+	Status    string  `json:"status"` // good, warning, critical
+}
+
+// ResourceMetrics represents resource usage metrics
+type ResourceMetrics struct {
+	CPU    float64 `json:"cpu"`
+	Memory float64 `json:"memory"`
+	Disk   float64 `json:"disk"`
+	Network float64 `json:"network"`
+}
+
+// HealthSnapshot represents a health snapshot at a point in time
+type HealthSnapshot struct {
+	Timestamp    time.Time `json:"timestamp"`
+	HealthScore  float64   `json:"healthScore"`
+	Grade        string    `json:"grade"`
+	IssuesCount  int       `json:"issuesCount"`
+}
+
+// CriticalIssue represents a critical issue
+type CriticalIssue struct {
+	ID          string    `json:"id"`
+	Type        string    `json:"type"`
+	Severity    string    `json:"severity"`
+	Description string    `json:"description"`
+	Impact      string    `json:"impact"`
+	DetectedAt  time.Time `json:"detectedAt"`
+	Resolution  string    `json:"resolution,omitempty"`
+}
+
+// HealthWarning represents a health warning
+type HealthWarning struct {
+	ID          string    `json:"id"`
+	Type        string    `json:"type"`
+	Message     string    `json:"message"`
+	Severity    string    `json:"severity"`
+	DetectedAt  time.Time `json:"detectedAt"`
+}
+
+// HealthRecommendation represents a health improvement recommendation
+type HealthRecommendation struct {
+	ID           string  `json:"id"`
+	Type         string  `json:"type"`
+	Priority     string  `json:"priority"`
+	Description  string  `json:"description"`
+	ActionItems  []string `json:"actionItems"`
+	EstimatedImpact float64 `json:"estimatedImpact"`
+}
+
+// VersionOptimization represents a version optimization recommendation
+type VersionOptimization struct {
+	PackageName     string `json:"packageName"`
+	CurrentVersion  string `json:"currentVersion"`
+	RecommendedVersion string `json:"recommendedVersion"`
+	Reason          string `json:"reason"`
+	Priority        string `json:"priority"`
+	Impact          string `json:"impact,omitempty"`
+}
+
+// DependencyOptimization represents a dependency optimization recommendation
+type DependencyOptimization struct {
+	Type            string   `json:"type"` // remove, replace, upgrade
+	Description     string   `json:"description"`
+	AffectedPackages []string `json:"affectedPackages"`
+	Benefit         string   `json:"benefit"`
+	Effort          string   `json:"effort"`
+}
+
+// DistributionStats represents statistical distribution
+type DistributionStats struct {
+	Mean       float64 `json:"mean"`
+	Median     float64 `json:"median"`
+	Mode       float64 `json:"mode"`
+	StdDev     float64 `json:"stdDev"`
+	Min        float64 `json:"min"`
+	Max        float64 `json:"max"`
+	Percentiles map[string]float64 `json:"percentiles,omitempty"`
+}
+
+// More analysis types
+
+// UpgradeRecommendation represents an upgrade recommendation
+type UpgradeRecommendation struct {
+	PackageName     string `json:"packageName"`
+	CurrentVersion  string `json:"currentVersion"`
+	RecommendedVersion string `json:"recommendedVersion"`
+	Reason          string `json:"reason"`
+	Priority        string `json:"priority"`
+	Benefits        []string `json:"benefits,omitempty"`
+	Risks           []string `json:"risks,omitempty"`
+}
+
+// ReplacementSuggestion represents a package replacement suggestion
+type ReplacementSuggestion struct {
+	OriginalPackage string `json:"originalPackage"`
+	SuggestedPackage string `json:"suggestedPackage"`
+	Reason          string `json:"reason"`
+	Benefits        []string `json:"benefits,omitempty"`
+	MigrationEffort string `json:"migrationEffort"`
+}
+
+// IssuePrediction represents predicted issues
+type IssuePrediction struct {
+	Type            string    `json:"type"`
+	Probability     float64   `json:"probability"`
+	Severity        string    `json:"severity"`
+	Description     string    `json:"description"`
+	PredictedDate   time.Time `json:"predictedDate,omitempty"`
+	PreventionSteps []string  `json:"preventionSteps,omitempty"`
+}
+
+// SecurityOptimization represents security optimization recommendations
+type SecurityOptimization struct {
+	Type            string   `json:"type"`
+	Description     string   `json:"description"`
+	AffectedPackages []string `json:"affectedPackages"`
+	Severity        string   `json:"severity"`
+	Action          string   `json:"action"`
+	Priority        string   `json:"priority"`
+}
+
+// PerformanceOptimization represents performance optimization recommendations
+type PerformanceOptimization struct {
+	Type            string   `json:"type"`
+	Description     string   `json:"description"`
+	AffectedPackages []string `json:"affectedPackages"`
+	ExpectedImprovement string `json:"expectedImprovement"`
+	ImplementationEffort string `json:"implementationEffort"`
+}
+
+// OptimizationAction represents an optimization action
+type OptimizationAction struct {
+	ID          string    `json:"id"`
+	Type        string    `json:"type"`
+	Description string    `json:"description"`
+	Priority    string    `json:"priority"`
+	Status      string    `json:"status"`
+	CreatedAt   time.Time `json:"createdAt"`
+	DueDate     time.Time `json:"dueDate,omitempty"`
+}
+
+// OptimizationBenefits represents expected benefits from optimizations
+type OptimizationBenefits struct {
+	CostSavings       *Cost   `json:"costSavings,omitempty"`
+	PerformanceGains  float64 `json:"performanceGains,omitempty"`
+	SecurityImprovements []string `json:"securityImprovements,omitempty"`
+	MaintenanceReduction string `json:"maintenanceReduction,omitempty"`
+}
+
+// MLRecommendation represents ML-driven recommendations
+type MLRecommendation struct {
+	ID          string  `json:"id"`
+	Type        string  `json:"type"`
+	Description string  `json:"description"`
+	Confidence  float64 `json:"confidence"`
+	ModelVersion string `json:"modelVersion"`
+	Evidence    []string `json:"evidence,omitempty"`
+}
+
 // String methods for debugging
 func (tr *TimeRange) String() string {
 	return fmt.Sprintf("TimeRange{Start: %v, End: %v}", tr.Start, tr.End)
diff --git a/pkg/nephio/krm/container_runtime.go b/pkg/nephio/krm/container_runtime.go
index 54a3e483..8f43bce6 100644
--- a/pkg/nephio/krm/container_runtime.go
+++ b/pkg/nephio/krm/container_runtime.go
@@ -345,12 +345,12 @@ type IPAMSubnet struct {
 
 // ContainerRuntimeMetrics provides comprehensive metrics
 type ContainerRuntimeMetrics struct {
-	ContainersStarted   prometheus.CounterVec
-	ContainerExecutions prometheus.HistogramVec
-	ResourceUtilization prometheus.GaugeVec
-	SecurityViolations  prometheus.CounterVec
-	NetworkIOBytes      prometheus.CounterVec
-	ErrorRate           prometheus.CounterVec
+	ContainersStarted   *prometheus.CounterVec
+	ContainerExecutions *prometheus.HistogramVec
+	ResourceUtilization *prometheus.GaugeVec
+	SecurityViolations  *prometheus.CounterVec
+	NetworkIOBytes      *prometheus.CounterVec
+	ErrorRate           *prometheus.CounterVec
 	CacheHitRate        prometheus.Counter
 	ActiveContainers    prometheus.Gauge
 }
@@ -399,14 +399,14 @@ func NewContainerRuntime(config *ContainerRuntimeConfig) (*ContainerRuntime, err
 
 	// Initialize metrics
 	metrics := &ContainerRuntimeMetrics{
-		ContainersStarted: *promauto.NewCounterVec(
+		ContainersStarted: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_container_starts_total",
 				Help: "Total number of container starts",
 			},
 			[]string{"image", "function", "status"},
 		),
-		ContainerExecutions: *promauto.NewHistogramVec(
+		ContainerExecutions: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_container_execution_duration_seconds",
 				Help:    "Duration of container executions",
@@ -414,28 +414,28 @@ func NewContainerRuntime(config *ContainerRuntimeConfig) (*ContainerRuntime, err
 			},
 			[]string{"image", "function"},
 		),
-		ResourceUtilization: *promauto.NewGaugeVec(
+		ResourceUtilization: promauto.NewGaugeVec(
 			prometheus.GaugeOpts{
 				Name: "krm_container_resource_utilization",
 				Help: "Container resource utilization",
 			},
 			[]string{"resource_type", "container_id"},
 		),
-		SecurityViolations: *promauto.NewCounterVec(
+		SecurityViolations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_container_security_violations_total",
 				Help: "Total number of security violations",
 			},
 			[]string{"violation_type", "severity"},
 		),
-		NetworkIOBytes: *promauto.NewCounterVec(
+		NetworkIOBytes: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_container_network_io_bytes_total",
 				Help: "Total container network I/O bytes",
 			},
 			[]string{"direction", "container_id"},
 		),
-		ErrorRate: *promauto.NewCounterVec(
+		ErrorRate: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_container_errors_total",
 				Help: "Total number of container execution errors",
diff --git a/pkg/nephio/krm/function_manager.go b/pkg/nephio/krm/function_manager.go
index d8f5156d..ce7f120d 100644
--- a/pkg/nephio/krm/function_manager.go
+++ b/pkg/nephio/krm/function_manager.go
@@ -274,14 +274,14 @@ func NewFunctionManager(config *FunctionManagerConfig, runtime *Runtime, contain
 
 	// Initialize metrics
 	metrics := &FunctionManagerMetrics{
-		FunctionExecutions: *promauto.NewCounterVec(
+		FunctionExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_function_manager_executions_total",
 				Help: "Total number of function executions",
 			},
 			[]string{"function", "mode", "status"},
 		),
-		ExecutionDuration: *promauto.NewHistogramVec(
+		ExecutionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_function_manager_execution_duration_seconds",
 				Help:    "Duration of function executions",
@@ -295,14 +295,14 @@ func NewFunctionManager(config *FunctionManagerConfig, runtime *Runtime, contain
 				Help: "Total number of registered functions",
 			},
 		),
-		ExecutionErrors: *promauto.NewCounterVec(
+		ExecutionErrors: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_function_manager_errors_total",
 				Help: "Total number of execution errors",
 			},
 			[]string{"function", "error_type"},
 		),
-		CachePerformance: *promauto.NewHistogramVec(
+		CachePerformance: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_function_manager_cache_operation_duration_seconds",
 				Help:    "Duration of cache operations",
@@ -310,14 +310,14 @@ func NewFunctionManager(config *FunctionManagerConfig, runtime *Runtime, contain
 			},
 			[]string{"operation", "result"},
 		),
-		SecurityViolations: *promauto.NewCounterVec(
+		SecurityViolations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_function_manager_security_violations_total",
 				Help: "Total number of security violations",
 			},
 			[]string{"violation_type", "severity"},
 		),
-		ResourceUtilization: *promauto.NewGaugeVec(
+		ResourceUtilization: promauto.NewGaugeVec(
 			prometheus.GaugeOpts{
 				Name: "krm_function_manager_resource_utilization",
 				Help: "Resource utilization during function execution",
@@ -968,9 +968,6 @@ func validateFunctionManagerConfig(config *FunctionManagerConfig) error {
 	return nil
 }
 
-func generateExecutionID() string {
-	return fmt.Sprintf("exec-%d", time.Now().UnixNano())
-}
 
 func convertToKRMResources(resources []*porch.KRMResource) []porch.KRMResource {
 	result := make([]porch.KRMResource, len(resources))
diff --git a/pkg/nephio/krm/pipeline.go b/pkg/nephio/krm/pipeline.go
index e7b9913e..a327d9bc 100644
--- a/pkg/nephio/krm/pipeline.go
+++ b/pkg/nephio/krm/pipeline.go
@@ -80,27 +80,6 @@ type PipelineConfig struct {
 	DetailedLogging bool `json:"detailedLogging" yaml:"detailedLogging"`
 }
 
-// PipelineDefinition defines the structure of a KRM function pipeline
-type PipelineDefinition struct {
-	// Metadata
-	Name        string            `json:"name" yaml:"name"`
-	Version     string            `json:"version" yaml:"version"`
-	Description string            `json:"description,omitempty" yaml:"description,omitempty"`
-	Labels      map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`
-	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty"`
-
-	// Pipeline structure
-	Stages     []*PipelineStage    `json:"stages" yaml:"stages"`
-	Variables  map[string]Variable `json:"variables,omitempty" yaml:"variables,omitempty"`
-	Conditions []*Condition        `json:"conditions,omitempty" yaml:"conditions,omitempty"`
-
-	// Execution settings
-	Execution *ExecutionSettings `json:"execution,omitempty" yaml:"execution,omitempty"`
-	Rollback  *RollbackSettings  `json:"rollback,omitempty" yaml:"rollback,omitempty"`
-
-	// O-RAN and telecom specific
-	TelecomProfile *TelecomProfile `json:"telecomProfile,omitempty" yaml:"telecomProfile,omitempty"`
-}
 
 // PipelineStage represents a stage in the pipeline
 type PipelineStage struct {
@@ -433,14 +412,14 @@ func NewPipeline(config *PipelineConfig, runtime *Runtime, registry *Registry) (
 
 	// Initialize metrics
 	metrics := &PipelineMetrics{
-		PipelineExecutions: *promauto.NewCounterVec(
+		PipelineExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_executions_total",
 				Help: "Total number of pipeline executions",
 			},
 			[]string{"pipeline", "status"},
 		),
-		ExecutionDuration: *promauto.NewHistogramVec(
+		ExecutionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_pipeline_execution_duration_seconds",
 				Help:    "Duration of pipeline executions",
@@ -448,14 +427,14 @@ func NewPipeline(config *PipelineConfig, runtime *Runtime, registry *Registry) (
 			},
 			[]string{"pipeline"},
 		),
-		StageExecutions: *promauto.NewCounterVec(
+		StageExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_stage_executions_total",
 				Help: "Total number of stage executions",
 			},
 			[]string{"pipeline", "stage", "status"},
 		),
-		StageDuration: *promauto.NewHistogramVec(
+		StageDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_pipeline_stage_duration_seconds",
 				Help:    "Duration of stage executions",
@@ -463,14 +442,14 @@ func NewPipeline(config *PipelineConfig, runtime *Runtime, registry *Registry) (
 			},
 			[]string{"pipeline", "stage"},
 		),
-		FunctionExecutions: *promauto.NewCounterVec(
+		FunctionExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_function_executions_total",
 				Help: "Total number of function executions in pipelines",
 			},
 			[]string{"pipeline", "stage", "function", "status"},
 		),
-		FunctionDuration: *promauto.NewHistogramVec(
+		FunctionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_pipeline_function_duration_seconds",
 				Help:    "Duration of function executions in pipelines",
@@ -478,14 +457,14 @@ func NewPipeline(config *PipelineConfig, runtime *Runtime, registry *Registry) (
 			},
 			[]string{"pipeline", "stage", "function"},
 		),
-		ErrorRate: *promauto.NewCounterVec(
+		ErrorRate: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_errors_total",
 				Help: "Total number of pipeline execution errors",
 			},
 			[]string{"pipeline", "stage", "error_type"},
 		),
-		RetryCount: *promauto.NewCounterVec(
+		RetryCount: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_retries_total",
 				Help: "Total number of execution retries",
@@ -504,7 +483,7 @@ func NewPipeline(config *PipelineConfig, runtime *Runtime, registry *Registry) (
 				Help: "Number of active pipeline executions",
 			},
 		),
-		CheckpointOperations: *promauto.NewCounterVec(
+		CheckpointOperations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_checkpoint_operations_total",
 				Help: "Total number of checkpoint operations",
@@ -1337,6 +1316,3 @@ func validatePipelineConfig(config *PipelineConfig) error {
 	return nil
 }
 
-func generateExecutionID() string {
-	return fmt.Sprintf("exec-%d", time.Now().UnixNano())
-}
diff --git a/pkg/nephio/krm/pipeline_orchestrator.go b/pkg/nephio/krm/pipeline_orchestrator.go
index 1997cc59..806383b4 100644
--- a/pkg/nephio/krm/pipeline_orchestrator.go
+++ b/pkg/nephio/krm/pipeline_orchestrator.go
@@ -114,47 +114,9 @@ type PipelineDefinition struct {
 	TelecomProfile *TelecomPipelineProfile `json:"telecomProfile,omitempty" yaml:"telecomProfile,omitempty"`
 }
 
-// PipelineStage represents a stage in the pipeline
-type PipelineStage struct {
-	// Basic properties
-	Name        string `json:"name" yaml:"name"`
-	Description string `json:"description,omitempty" yaml:"description,omitempty"`
-	Type        string `json:"type" yaml:"type"` // function, parallel-group, conditional
+// PipelineStage is defined in pipeline.go
 
-	// Function configuration
-	Functions []*StageFunction `json:"functions,omitempty" yaml:"functions,omitempty"`
-
-	// Control flow
-	DependsOn []string        `json:"dependsOn,omitempty" yaml:"dependsOn,omitempty"`
-	Condition *StageCondition `json:"condition,omitempty" yaml:"condition,omitempty"`
-
-	// Execution settings
-	Timeout     time.Duration `json:"timeout,omitempty" yaml:"timeout,omitempty"`
-	Concurrency int           `json:"concurrency,omitempty" yaml:"concurrency,omitempty"`
-	Priority    int           `json:"priority,omitempty" yaml:"priority,omitempty"`
-
-	// Error handling
-	OnFailure *FailureAction `json:"onFailure,omitempty" yaml:"onFailure,omitempty"`
-	OnSuccess *SuccessAction `json:"onSuccess,omitempty" yaml:"onSuccess,omitempty"`
-
-	// Resource requirements
-	Resources *StageResources `json:"resources,omitempty" yaml:"resources,omitempty"`
-
-	// Variables and outputs
-	InputMapping  map[string]string `json:"inputMapping,omitempty" yaml:"inputMapping,omitempty"`
-	OutputMapping map[string]string `json:"outputMapping,omitempty" yaml:"outputMapping,omitempty"`
-}
-
-// StageFunction represents a function within a stage
-type StageFunction struct {
-	Name           string                 `json:"name" yaml:"name"`
-	Image          string                 `json:"image,omitempty" yaml:"image,omitempty"`
-	Config         map[string]interface{} `json:"config,omitempty" yaml:"config,omitempty"`
-	ResourceFilter *ResourceFilter        `json:"resourceFilter,omitempty" yaml:"resourceFilter,omitempty"`
-	Timeout        time.Duration          `json:"timeout,omitempty" yaml:"timeout,omitempty"`
-	RetryPolicy    *RetryPolicy           `json:"retryPolicy,omitempty" yaml:"retryPolicy,omitempty"`
-	Optional       bool                   `json:"optional,omitempty" yaml:"optional,omitempty"`
-}
+// StageFunction is defined in pipeline.go
 
 // StageDependency defines dependencies between stages
 type StageDependency struct {
@@ -195,14 +157,7 @@ type FailurePolicy struct {
 	Conditions []*StageCondition `json:"conditions,omitempty" yaml:"conditions,omitempty"`
 }
 
-// RetryPolicy defines retry behavior
-type RetryPolicy struct {
-	MaxAttempts   int           `json:"maxAttempts" yaml:"maxAttempts"`
-	InitialDelay  time.Duration `json:"initialDelay" yaml:"initialDelay"`
-	MaxDelay      time.Duration `json:"maxDelay" yaml:"maxDelay"`
-	BackoffFactor float64       `json:"backoffFactor" yaml:"backoffFactor"`
-	RetryOn       []string      `json:"retryOn,omitempty" yaml:"retryOn,omitempty"`
-}
+// RetryPolicy is defined in pipeline.go
 
 // FailureAction defines what to do on stage failure
 type FailureAction struct {
@@ -231,15 +186,7 @@ type ResourceFilter struct {
 	Exclude []*ResourceSelector `json:"exclude,omitempty" yaml:"exclude,omitempty"`
 }
 
-// ResourceSelector defines resource selection criteria
-type ResourceSelector struct {
-	APIVersion string            `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty"`
-	Kind       string            `json:"kind,omitempty" yaml:"kind,omitempty"`
-	Name       string            `json:"name,omitempty" yaml:"name,omitempty"`
-	Namespace  string            `json:"namespace,omitempty" yaml:"namespace,omitempty"`
-	Labels     map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`
-	Fields     map[string]string `json:"fields,omitempty" yaml:"fields,omitempty"`
-}
+// ResourceSelector is defined in pipeline.go
 
 // TelecomPipelineProfile defines telecom-specific pipeline characteristics
 type TelecomPipelineProfile struct {
@@ -250,47 +197,7 @@ type TelecomPipelineProfile struct {
 	Optimization string   `json:"optimization" yaml:"optimization"` // performance, cost, compliance
 }
 
-// PipelineExecution represents a pipeline execution instance
-type PipelineExecution struct {
-	// Metadata
-	ID       string              `json:"id"`
-	Name     string              `json:"name"`
-	Pipeline *PipelineDefinition `json:"pipeline"`
-
-	// Execution state
-	Status    PipelineStatus `json:"status"`
-	Phase     PipelinePhase  `json:"phase"`
-	StartTime time.Time      `json:"startTime"`
-	EndTime   *time.Time     `json:"endTime,omitempty"`
-	Duration  time.Duration  `json:"duration"`
-
-	// Stage execution tracking
-	Stages       map[string]*StageExecution `json:"stages"`
-	CurrentStage string                     `json:"currentStage,omitempty"`
-
-	// Input/Output
-	InputResources  []*porch.KRMResource `json:"inputResources"`
-	OutputResources []*porch.KRMResource `json:"outputResources"`
-
-	// Results and errors
-	Results []*ExecutionResult `json:"results"`
-	Errors  []*ExecutionError  `json:"errors"`
-
-	// State management
-	Variables   map[string]interface{} `json:"variables"`
-	Checkpoints []*ExecutionCheckpoint `json:"checkpoints"`
-
-	// Performance metrics
-	ResourceUsage *PipelineResourceUsage `json:"resourceUsage,omitempty"`
-
-	// Audit and tracing
-	AuditLogs []string `json:"auditLogs"`
-	TraceID   string   `json:"traceId,omitempty"`
-	SpanID    string   `json:"spanId,omitempty"`
-
-	// Context
-	Context map[string]interface{} `json:"context"`
-}
+// PipelineExecution is defined in pipeline.go
 
 // StageExecution represents execution of a pipeline stage
 type StageExecution struct {
@@ -543,14 +450,14 @@ func NewPipelineOrchestrator(config *PipelineOrchestratorConfig, functionManager
 
 	// Initialize metrics
 	metrics := &PipelineOrchestratorMetrics{
-		PipelineExecutions: *promauto.NewCounterVec(
+		PipelineExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_orchestrator_executions_total",
 				Help: "Total number of pipeline executions",
 			},
 			[]string{"pipeline", "status"},
 		),
-		ExecutionDuration: *promauto.NewHistogramVec(
+		ExecutionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_pipeline_orchestrator_execution_duration_seconds",
 				Help:    "Duration of pipeline executions",
@@ -558,14 +465,14 @@ func NewPipelineOrchestrator(config *PipelineOrchestratorConfig, functionManager
 			},
 			[]string{"pipeline"},
 		),
-		StageExecutions: *promauto.NewCounterVec(
+		StageExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_orchestrator_stage_executions_total",
 				Help: "Total number of stage executions",
 			},
 			[]string{"pipeline", "stage", "status"},
 		),
-		StageDuration: *promauto.NewHistogramVec(
+		StageDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_pipeline_orchestrator_stage_duration_seconds",
 				Help:    "Duration of stage executions",
@@ -573,7 +480,7 @@ func NewPipelineOrchestrator(config *PipelineOrchestratorConfig, functionManager
 			},
 			[]string{"pipeline", "stage"},
 		),
-		DependencyResolution: *promauto.NewHistogramVec(
+		DependencyResolution: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_pipeline_orchestrator_dependency_resolution_seconds",
 				Help:    "Duration of dependency resolution",
@@ -581,14 +488,14 @@ func NewPipelineOrchestrator(config *PipelineOrchestratorConfig, functionManager
 			},
 			[]string{"pipeline"},
 		),
-		ErrorRate: *promauto.NewCounterVec(
+		ErrorRate: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_pipeline_orchestrator_errors_total",
 				Help: "Total number of execution errors",
 			},
 			[]string{"pipeline", "stage", "error_type"},
 		),
-		ResourceUtilization: *promauto.NewGaugeVec(
+		ResourceUtilization: promauto.NewGaugeVec(
 			prometheus.GaugeOpts{
 				Name: "krm_pipeline_orchestrator_resource_utilization",
 				Help: "Resource utilization during pipeline execution",
diff --git a/pkg/nephio/krm/porch_integration.go b/pkg/nephio/krm/porch_integration.go
index 6b65aba3..3a476118 100644
--- a/pkg/nephio/krm/porch_integration.go
+++ b/pkg/nephio/krm/porch_integration.go
@@ -191,35 +191,35 @@ functionManager *FunctionManager,
 
 	// Initialize metrics
 	metrics := &PorchIntegrationMetrics{
-		PackageCreations: *promauto.NewCounterVec(
+		PackageCreations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_porch_package_creations_total",
 				Help: "Total number of package creations",
 			},
 			[]string{"repository", "intent_type", "status"},
 		),
-		PackageRevisions: *promauto.NewCounterVec(
+		PackageRevisions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_porch_package_revisions_total",
 				Help: "Total number of package revisions created",
 			},
 			[]string{"repository", "package", "lifecycle", "status"},
 		),
-		FunctionExecutions: *promauto.NewCounterVec(
+		FunctionExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_porch_function_executions_total",
 				Help: "Total number of KRM function executions in Porch context",
 			},
 			[]string{"function", "package", "status"},
 		),
-		PipelineExecutions: *promauto.NewCounterVec(
+		PipelineExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_porch_pipeline_executions_total",
 				Help: "Total number of KRM pipeline executions",
 			},
 			[]string{"pipeline", "package", "status"},
 		),
-		ExecutionDuration: *promauto.NewHistogramVec(
+		ExecutionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_porch_execution_duration_seconds",
 				Help:    "Duration of Porch integration operations",
@@ -227,7 +227,7 @@ functionManager *FunctionManager,
 			},
 			[]string{"operation", "intent_type"},
 		),
-		PackageSize: *promauto.NewHistogramVec(
+		PackageSize: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_porch_package_size_bytes",
 				Help:    "Size of generated packages in bytes",
@@ -247,7 +247,7 @@ functionManager *FunctionManager,
 				Help: "Total number of cache misses",
 			},
 		),
-		ErrorRate: *promauto.NewCounterVec(
+		ErrorRate: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_porch_errors_total",
 				Help: "Total number of errors in Porch integration",
diff --git a/pkg/nephio/krm/registry.go b/pkg/nephio/krm/registry.go
index f698bef2..903af1a3 100644
--- a/pkg/nephio/krm/registry.go
+++ b/pkg/nephio/krm/registry.go
@@ -379,11 +379,11 @@ func NewRegistry(config *RegistryConfig) (*Registry, error) {
 			Name: "krm_registry_repositories_total",
 			Help: "Total number of configured repositories",
 		}),
-		FunctionCount: *promauto.NewGaugeVec(prometheus.GaugeOpts{
+		FunctionCount: promauto.NewGaugeVec(prometheus.GaugeOpts{
 			Name: "krm_registry_functions_total",
 			Help: "Total number of functions by repository",
 		}, []string{"repository"}),
-		DiscoveryDuration: *promauto.NewHistogramVec(prometheus.HistogramOpts{
+		DiscoveryDuration: promauto.NewHistogramVec(prometheus.HistogramOpts{
 			Name: "krm_registry_discovery_duration_seconds",
 			Help: "Duration of function discovery operations",
 		}, []string{"repository"}),
@@ -395,7 +395,7 @@ func NewRegistry(config *RegistryConfig) (*Registry, error) {
 			Name: "krm_registry_cache_misses_total",
 			Help: "Total number of cache misses",
 		}),
-		HealthCheckFailures: *promauto.NewCounterVec(prometheus.CounterOpts{
+		HealthCheckFailures: promauto.NewCounterVec(prometheus.CounterOpts{
 			Name: "krm_registry_health_check_failures_total",
 			Help: "Total number of health check failures",
 		}, []string{"repository", "reason"}),
diff --git a/pkg/nephio/krm/runtime.go b/pkg/nephio/krm/runtime.go
index 232e1c83..b8b6d54a 100644
--- a/pkg/nephio/krm/runtime.go
+++ b/pkg/nephio/krm/runtime.go
@@ -205,14 +205,14 @@ type FileSystemPolicy struct {
 
 // RuntimeMetrics provides comprehensive metrics for function execution
 type RuntimeMetrics struct {
-	FunctionExecutions  prometheus.CounterVec
-	ExecutionDuration   prometheus.HistogramVec
-	ResourceUtilization prometheus.GaugeVec
-	ErrorRate           prometheus.CounterVec
+	FunctionExecutions  *prometheus.CounterVec
+	ExecutionDuration   *prometheus.HistogramVec
+	ResourceUtilization *prometheus.GaugeVec
+	ErrorRate           *prometheus.CounterVec
 	QueueDepth          prometheus.Gauge
 	ActiveExecutors     prometheus.Gauge
 	CacheHitRate        prometheus.Counter
-	SecurityViolations  prometheus.CounterVec
+	SecurityViolations  *prometheus.CounterVec
 }
 
 // Default configuration
@@ -254,14 +254,14 @@ func NewRuntime(config *RuntimeConfig) (*Runtime, error) {
 
 	// Initialize metrics
 	metrics := &RuntimeMetrics{
-		FunctionExecutions: *promauto.NewCounterVec(
+		FunctionExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_function_executions_total",
 				Help: "Total number of KRM function executions",
 			},
 			[]string{"function", "status", "image"},
 		),
-		ExecutionDuration: *promauto.NewHistogramVec(
+		ExecutionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_function_execution_duration_seconds",
 				Help:    "Duration of KRM function executions",
@@ -269,14 +269,14 @@ func NewRuntime(config *RuntimeConfig) (*Runtime, error) {
 			},
 			[]string{"function", "image"},
 		),
-		ResourceUtilization: *promauto.NewGaugeVec(
+		ResourceUtilization: promauto.NewGaugeVec(
 			prometheus.GaugeOpts{
 				Name: "krm_function_resource_utilization",
 				Help: "Resource utilization during function execution",
 			},
 			[]string{"resource_type", "function"},
 		),
-		ErrorRate: *promauto.NewCounterVec(
+		ErrorRate: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_function_errors_total",
 				Help: "Total number of KRM function execution errors",
@@ -301,7 +301,7 @@ func NewRuntime(config *RuntimeConfig) (*Runtime, error) {
 				Help: "Total number of function cache hits",
 			},
 		),
-		SecurityViolations: *promauto.NewCounterVec(
+		SecurityViolations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_function_security_violations_total",
 				Help: "Total number of security violations during function execution",
@@ -956,9 +956,6 @@ func validateRuntimeConfig(config *RuntimeConfig) error {
 	return nil
 }
 
-func generateExecutionID() string {
-	return fmt.Sprintf("exec-%d-%d", time.Now().UnixNano(), runtime.NumGoroutine())
-}
 
 func generateExecutorID() string {
 	return fmt.Sprintf("executor-%d-%d", time.Now().UnixNano(), runtime.NumGoroutine())
diff --git a/pkg/nephio/krm/validator.go b/pkg/nephio/krm/validator.go
index 6956a31d..d3e218b1 100644
--- a/pkg/nephio/krm/validator.go
+++ b/pkg/nephio/krm/validator.go
@@ -461,14 +461,14 @@ type CachedValidationResult struct {
 
 // ValidatorMetrics provides comprehensive metrics
 type ValidatorMetrics struct {
-	ValidationsTotal     prometheus.CounterVec
-	ValidationDuration   prometheus.HistogramVec
-	SecurityScansTotal   prometheus.CounterVec
-	ComplianceChecks     prometheus.CounterVec
-	PerformanceTests     prometheus.CounterVec
+	ValidationsTotal     *prometheus.CounterVec
+	ValidationDuration   *prometheus.HistogramVec
+	SecurityScansTotal   *prometheus.CounterVec
+	ComplianceChecks     *prometheus.CounterVec
+	PerformanceTests     *prometheus.CounterVec
 	CacheHits            prometheus.Counter
 	CacheMisses          prometheus.Counter
-	CertificationsIssued prometheus.CounterVec
+	CertificationsIssued *prometheus.CounterVec
 }
 
 // Default validator configuration
@@ -511,14 +511,14 @@ func NewValidator(config *ValidatorConfig) (*Validator, error) {
 
 	// Initialize metrics
 	metrics := &ValidatorMetrics{
-		ValidationsTotal: *promauto.NewCounterVec(
+		ValidationsTotal: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_validator_validations_total",
 				Help: "Total number of validations performed",
 			},
 			[]string{"type", "result"},
 		),
-		ValidationDuration: *promauto.NewHistogramVec(
+		ValidationDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "krm_validator_validation_duration_seconds",
 				Help:    "Duration of validations",
@@ -526,21 +526,21 @@ func NewValidator(config *ValidatorConfig) (*Validator, error) {
 			},
 			[]string{"type"},
 		),
-		SecurityScansTotal: *promauto.NewCounterVec(
+		SecurityScansTotal: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_validator_security_scans_total",
 				Help: "Total number of security scans performed",
 			},
 			[]string{"scanner", "result"},
 		),
-		ComplianceChecks: *promauto.NewCounterVec(
+		ComplianceChecks: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_validator_compliance_checks_total",
 				Help: "Total number of compliance checks performed",
 			},
 			[]string{"standard", "result"},
 		),
-		PerformanceTests: *promauto.NewCounterVec(
+		PerformanceTests: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_validator_performance_tests_total",
 				Help: "Total number of performance tests performed",
@@ -559,7 +559,7 @@ func NewValidator(config *ValidatorConfig) (*Validator, error) {
 				Help: "Total number of validation cache misses",
 			},
 		),
-		CertificationsIssued: *promauto.NewCounterVec(
+		CertificationsIssued: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "krm_validator_certifications_issued_total",
 				Help: "Total number of certifications issued",
diff --git a/pkg/nephio/nephio_integration.go b/pkg/nephio/nephio_integration.go
index 755244c9..5dc22319 100644
--- a/pkg/nephio/nephio_integration.go
+++ b/pkg/nephio/nephio_integration.go
@@ -21,12 +21,10 @@
 	"fmt"
 	"time"
 
-	"github.com/go-logr/logr"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/log"
 
 	v1 "github.com/thc1006/nephoran-intent-operator/api/v1"
-	"github.com/thc1006/nephoran-intent-operator/pkg/errors"
 	"github.com/thc1006/nephoran-intent-operator/pkg/nephio/porch"
 )
 
diff --git a/pkg/nephio/package_catalog.go b/pkg/nephio/package_catalog.go
index fa42cbc3..505789d1 100644
--- a/pkg/nephio/package_catalog.go
+++ b/pkg/nephio/package_catalog.go
@@ -19,22 +19,17 @@
 import (
 	"context"
 	"fmt"
-	"sync"
 	"time"
 
-	"github.com/go-logr/logr"
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promauto"
 	"go.opentelemetry.io/otel"
 	"go.opentelemetry.io/otel/attribute"
-	"go.opentelemetry.io/otel/trace"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/log"
 
 	v1 "github.com/thc1006/nephoran-intent-operator/api/v1"
-	"github.com/thc1006/nephoran-intent-operator/pkg/errors"
 	"github.com/thc1006/nephoran-intent-operator/pkg/nephio/porch"
 )
 
diff --git a/pkg/nephio/package_generator.go b/pkg/nephio/package_generator.go
index b8616e3f..f1d3105a 100644
--- a/pkg/nephio/package_generator.go
+++ b/pkg/nephio/package_generator.go
@@ -12,7 +12,6 @@
 
 	"github.com/thc1006/nephoran-intent-operator/api/v1"
 	"github.com/thc1006/nephoran-intent-operator/pkg/nephio/porch"
-	"k8s.io/apimachinery/pkg/runtime"
 	"sigs.k8s.io/yaml"
 )
 
diff --git a/pkg/nephio/testutil/porch_fixtures.go b/pkg/nephio/testutil/porch_fixtures.go
index 7ff8ec4b..4de64757 100644
--- a/pkg/nephio/testutil/porch_fixtures.go
+++ b/pkg/nephio/testutil/porch_fixtures.go
@@ -466,7 +466,7 @@ func WithIntent(intentText string) NetworkIntentOption {
 // WithIntentPhase sets the intent phase
 func WithIntentPhase(phase string) NetworkIntentOption {
 	return func(intent *v1.NetworkIntent) {
-		intent.Status.Phase = phase
+		intent.Status.Phase = v1.NetworkIntentPhase(phase)
 	}
 }
 
diff --git a/pkg/nephio/workflow_engine.go b/pkg/nephio/workflow_engine.go
index dce1e5dc..3b6b6829 100644
--- a/pkg/nephio/workflow_engine.go
+++ b/pkg/nephio/workflow_engine.go
@@ -21,7 +21,6 @@
 	"fmt"
 	"time"
 
-	"github.com/go-logr/logr"
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promauto"
 	"go.opentelemetry.io/otel"
@@ -337,21 +336,21 @@ func NewNephioWorkflowEngine(config *WorkflowEngineConfig) (*NephioWorkflowEngin
 
 	// Initialize metrics
 	metrics := &WorkflowEngineMetrics{
-		WorkflowRegistrations: *promauto.NewCounterVec(
+		WorkflowRegistrations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "nephio_workflow_registrations_total",
 				Help: "Total number of workflow registrations",
 			},
 			[]string{"workflow", "intent_type", "status"},
 		),
-		WorkflowExecutions: *promauto.NewCounterVec(
+		WorkflowExecutions: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "nephio_workflow_engine_executions_total",
 				Help: "Total number of workflow executions by the engine",
 			},
 			[]string{"workflow", "phase", "status"},
 		),
-		ExecutionDuration: *promauto.NewHistogramVec(
+		ExecutionDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "nephio_workflow_engine_execution_duration_seconds",
 				Help:    "Duration of workflow executions",
@@ -359,7 +358,7 @@ func NewNephioWorkflowEngine(config *WorkflowEngineConfig) (*NephioWorkflowEngin
 			},
 			[]string{"workflow", "phase"},
 		),
-		WorkflowErrors: *promauto.NewCounterVec(
+		WorkflowErrors: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "nephio_workflow_engine_errors_total",
 				Help: "Total number of workflow engine errors",
diff --git a/pkg/nephio/workflow_orchestrator.go b/pkg/nephio/workflow_orchestrator.go
index 5b5873aa..1e582300 100644
--- a/pkg/nephio/workflow_orchestrator.go
+++ b/pkg/nephio/workflow_orchestrator.go
@@ -22,20 +22,17 @@
 	"sync"
 	"time"
 
-	"github.com/go-logr/logr"
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promauto"
 	"go.opentelemetry.io/otel"
 	"go.opentelemetry.io/otel/attribute"
 	"go.opentelemetry.io/otel/trace"
-	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/log"
 
 	v1 "github.com/thc1006/nephoran-intent-operator/api/v1"
-	"github.com/thc1006/nephoran-intent-operator/pkg/errors"
 	"github.com/thc1006/nephoran-intent-operator/pkg/nephio/porch"
 )
 
@@ -142,7 +139,7 @@ type WorkflowPhaseExecution struct {
 type WorkflowExecutionResults struct {
 	PackageRevisions  []*porch.PackageRevision  `json:"packageRevisions"`
 	DeploymentResults []*DeploymentResult       `json:"deploymentResults"`
-	ValidationResults []*ValidationResult       `json:"validationResults"`
+	ValidationResults []*porch.ValidationResult `json:"validationResults"`
 	ConfigSyncResults []*ConfigSyncResult       `json:"configSyncResults"`
 	ClusterHealth     map[string]*ClusterHealth `json:"clusterHealth"`
 	ResourceUsage     *ResourceUsageSummary     `json:"resourceUsage"`
@@ -160,7 +157,6 @@ type ConfigSyncResult struct {
 	Timestamp       time.Time     `json:"timestamp"`
 }
 
-
 // WorkloadClusterRegistry manages workload cluster lifecycle
 type WorkloadClusterRegistry struct {
 	client        client.Client
@@ -224,36 +220,36 @@ type NephioPackageCatalog struct {
 
 // BlueprintPackage represents a blueprint package in the catalog
 type BlueprintPackage struct {
-	Name           string                 `json:"name"`
-	Repository     string                 `json:"repository"`
-	Version        string                 `json:"version"`
-	Description    string                 `json:"description"`
-	Category       string                 `json:"category"`
-	IntentTypes    []v1.IntentType `json:"intentTypes"`
-	Dependencies   []PackageDependency    `json:"dependencies"`
-	Parameters     []ParameterDefinition  `json:"parameters"`
-	Validations    []ValidationRule       `json:"validations"`
-	Resources      []ResourceTemplate     `json:"resources"`
-	Functions      []FunctionDefinition   `json:"functions"`
-	Specialization *SpecializationSpec    `json:"specialization,omitempty"`
-	Metadata       map[string]string      `json:"metadata"`
-	CreatedAt      time.Time              `json:"createdAt"`
-	UpdatedAt      time.Time              `json:"updatedAt"`
+	Name           string                `json:"name"`
+	Repository     string                `json:"repository"`
+	Version        string                `json:"version"`
+	Description    string                `json:"description"`
+	Category       string                `json:"category"`
+	IntentTypes    []v1.IntentType       `json:"intentTypes"`
+	Dependencies   []PackageDependency   `json:"dependencies"`
+	Parameters     []ParameterDefinition `json:"parameters"`
+	Validations    []ValidationRule      `json:"validations"`
+	Resources      []ResourceTemplate    `json:"resources"`
+	Functions      []FunctionDefinition  `json:"functions"`
+	Specialization *SpecializationSpec   `json:"specialization,omitempty"`
+	Metadata       map[string]string     `json:"metadata"`
+	CreatedAt      time.Time             `json:"createdAt"`
+	UpdatedAt      time.Time             `json:"updatedAt"`
 }
 
 // PackageVariant represents a specialized package for a target cluster
 type PackageVariant struct {
-	Name              string                 `json:"name"`
-	Blueprint         *BlueprintPackage      `json:"blueprint"`
-	TargetCluster     *WorkloadCluster       `json:"targetCluster"`
-	Specialization    *SpecializationRequest `json:"specialization"`
-	Status            PackageVariantStatus   `json:"status"`
-	PackageRevision   *porch.PackageRevision `json:"packageRevision"`
-	DeploymentStatus  *porch.DeploymentStatus      `json:"deploymentStatus,omitempty"`
-	ValidationResults []*ValidationResult    `json:"validationResults,omitempty"`
-	Errors            []string               `json:"errors,omitempty"`
-	CreatedAt         time.Time              `json:"createdAt"`
-	UpdatedAt         time.Time              `json:"updatedAt"`
+	Name              string                    `json:"name"`
+	Blueprint         *BlueprintPackage         `json:"blueprint"`
+	TargetCluster     *WorkloadCluster          `json:"targetCluster"`
+	Specialization    *SpecializationRequest    `json:"specialization"`
+	Status            PackageVariantStatus      `json:"status"`
+	PackageRevision   *porch.PackageRevision    `json:"packageRevision"`
+	DeploymentStatus  *porch.DeploymentStatus   `json:"deploymentStatus,omitempty"`
+	ValidationResults []*porch.ValidationResult `json:"validationResults,omitempty"`
+	Errors            []string                  `json:"errors,omitempty"`
+	CreatedAt         time.Time                 `json:"createdAt"`
+	UpdatedAt         time.Time                 `json:"updatedAt"`
 }
 
 // SpecializationRequest defines how to specialize a blueprint
@@ -291,18 +287,18 @@ type NephioWorkflowEngine struct {
 
 // WorkflowDefinition defines a Nephio workflow
 type WorkflowDefinition struct {
-	Name          string                 `json:"name"`
-	Description   string                 `json:"description"`
-	IntentTypes   []v1.IntentType `json:"intentTypes"`
-	Phases        []WorkflowPhase        `json:"phases"`
-	Conditions    []WorkflowCondition    `json:"conditions"`
-	Rollback      *RollbackStrategy      `json:"rollback,omitempty"`
-	Approvals     *ApprovalStrategy      `json:"approvals,omitempty"`
-	Notifications *NotificationStrategy  `json:"notifications,omitempty"`
-	Timeouts      *TimeoutStrategy       `json:"timeouts,omitempty"`
-	Metadata      map[string]string      `json:"metadata"`
-	CreatedAt     time.Time              `json:"createdAt"`
-	UpdatedAt     time.Time              `json:"updatedAt"`
+	Name          string                `json:"name"`
+	Description   string                `json:"description"`
+	IntentTypes   []v1.IntentType       `json:"intentTypes"`
+	Phases        []WorkflowPhase       `json:"phases"`
+	Conditions    []WorkflowCondition   `json:"conditions"`
+	Rollback      *RollbackStrategy     `json:"rollback,omitempty"`
+	Approvals     *ApprovalStrategy     `json:"approvals,omitempty"`
+	Notifications *NotificationStrategy `json:"notifications,omitempty"`
+	Timeouts      *TimeoutStrategy      `json:"timeouts,omitempty"`
+	Metadata      map[string]string     `json:"metadata"`
+	CreatedAt     time.Time             `json:"createdAt"`
+	UpdatedAt     time.Time             `json:"updatedAt"`
 }
 
 // WorkflowPhase represents a phase in the workflow
@@ -324,6 +320,7 @@ type WorkflowPhase struct {
 const (
 	WorkflowPhaseTypeBlueprintSelection    WorkflowPhaseType = "BlueprintSelection"
 	WorkflowPhaseTypePackageSpecialization WorkflowPhaseType = "PackageSpecialization"
+	WorkflowPhaseTypeConfiguration         WorkflowPhaseType = "Configuration"
 	WorkflowPhaseTypeValidation            WorkflowPhaseType = "Validation"
 	WorkflowPhaseTypeApproval              WorkflowPhaseType = "Approval"
 	WorkflowPhaseTypeDeployment            WorkflowPhaseType = "Deployment"
@@ -469,18 +466,8 @@ func NewNephioWorkflowOrchestrator(
 	}
 
 	// Initialize Config Sync client
-	configSyncConfig := &ConfigSyncConfig{
-		Repository: config.DownstreamRepository,
-		Branch:     config.GitBranch,
-		Directory:  "clusters",
-		SyncPeriod: 30 * time.Second,
-		PolicyDir:  "system",
-		Namespaces: []string{config.DefaultNamespace},
-	}
-
 	configSync := &ConfigSyncClient{
 		client: client,
-		config: configSyncConfig,
 		tracer: otel.Tracer("nephio-configsync"),
 	}
 
@@ -870,7 +857,7 @@ func (nwo *NephioWorkflowOrchestrator) executeValidationPhase(ctx context.Contex
 
 	logger := log.FromContext(ctx).WithName("validation")
 
-	validationResults := make([]*ValidationResult, 0)
+	validationResults := make([]*porch.ValidationResult, 0)
 	validationErrors := make([]string, 0)
 
 	// Validate each package variant
@@ -888,22 +875,20 @@ func (nwo *NephioWorkflowOrchestrator) executeValidationPhase(ctx context.Contex
 			continue
 		}
 
-		validationResults = append(validationResults, &ValidationResult{
-			PackageName: variant.PackageRevision.Spec.PackageName,
-			Valid:       result.Valid,
-			Errors:      result.Errors,
-			Warnings:    result.Warnings,
+		validationResults = append(validationResults, &porch.ValidationResult{
+			Valid:    result.Valid,
+			Errors:   result.Errors,
+			Warnings: result.Warnings,
 		})
 
 		if !result.Valid {
 			validationErrors = append(validationErrors, fmt.Sprintf("package %s failed validation", variant.Name))
 		}
 
-		variant.ValidationResults = []*ValidationResult{{
-			PackageName: variant.PackageRevision.Spec.PackageName,
-			Valid:       result.Valid,
-			Errors:      result.Errors,
-			Warnings:    result.Warnings,
+		variant.ValidationResults = []*porch.ValidationResult{{
+			Valid:    result.Valid,
+			Errors:   result.Errors,
+			Warnings: result.Warnings,
 		}}
 	}
 
@@ -1184,14 +1169,25 @@ func (nwo *NephioWorkflowOrchestrator) extractParametersFromIntent(intent *v1.Ne
 	// Extract configuration parameters from intent
 	params := make(map[string]interface{})
 
-	if intent.Spec.Configuration != nil {
-		for k, v := range intent.Spec.Configuration {
-			params[k] = v
+	if intent.Spec.ProcessedParameters != nil {
+		if intent.Spec.ProcessedParameters.NetworkFunction != "" {
+			params["networkFunction"] = intent.Spec.ProcessedParameters.NetworkFunction
+		}
+		if intent.Spec.ProcessedParameters.Region != "" {
+			params["region"] = intent.Spec.ProcessedParameters.Region
+		}
+		if intent.Spec.ProcessedParameters.CustomParameters != nil {
+			for k, v := range intent.Spec.ProcessedParameters.CustomParameters {
+				params[k] = v
+			}
 		}
 	}
 
 	params["intentType"] = string(intent.Spec.IntentType)
-	params["targetComponent"] = intent.Spec.TargetComponent
+	if len(intent.Spec.TargetComponents) > 0 {
+		params["targetComponents"] = intent.Spec.TargetComponents
+		params["targetComponent"] = string(intent.Spec.TargetComponents[0]) // Use first component for backward compatibility
+	}
 
 	return params
 }
@@ -1222,35 +1218,53 @@ func (nwo *NephioWorkflowOrchestrator) updateIntentWithWorkflowStatus(ctx contex
 		intent.Status.Phase = v1.NetworkIntentPhaseFailed
 	}
 
-	// Update with package information
+	// Update last message with execution summary
+	if len(execution.PackageVariants) > 0 {
+		intent.Status.LastMessage = fmt.Sprintf("Workflow execution %s: %d package variants created", execution.Status, len(execution.PackageVariants))
+	} else {
+		intent.Status.LastMessage = fmt.Sprintf("Workflow execution %s", execution.Status)
+	}
+
+	// Store execution details in extensions
+	if intent.Status.Extensions == nil {
+		intent.Status.Extensions = make(map[string]runtime.RawExtension)
+	}
+
+	// Store package revision information in extensions
 	if len(execution.PackageVariants) > 0 && execution.PackageVariants[0].PackageRevision != nil {
 		pr := execution.PackageVariants[0].PackageRevision
-		intent.Status.PackageRevision = &v1.PackageRevisionReference{
-			Repository:  pr.Spec.Repository,
-			PackageName: pr.Spec.PackageName,
-			Revision:    pr.Spec.Revision,
+		_ = map[string]interface{}{
+			"repository":  pr.Spec.Repository,
+			"packageName": pr.Spec.PackageName,
+			"revision":    pr.Spec.Revision,
 		}
+		packageInfoJSON := fmt.Sprintf(`{"repository":"%s","packageName":"%s","revision":"%s"}`, pr.Spec.Repository, pr.Spec.PackageName, pr.Spec.Revision)
+		intent.Status.Extensions["packageRevision"] = runtime.RawExtension{Raw: []byte(packageInfoJSON)}
 	}
 
-	// Update deployment status
+	// Store deployment status in extensions
 	if len(execution.Deployments) > 0 {
-		intent.Status.DeploymentStatus = &v1.DeploymentStatus{
-			Phase:   "Deployed",
-			Targets: make([]v1.DeploymentTargetStatus, 0, len(execution.Deployments)),
+		deploymentInfo := map[string]interface{}{
+			"phase":   "Deployed",
+			"targets": make([]map[string]interface{}, 0, len(execution.Deployments)),
 		}
 
 		for _, deployment := range execution.Deployments {
-			intent.Status.DeploymentStatus.Targets = append(intent.Status.DeploymentStatus.Targets, v1.DeploymentTargetStatus{
-				Cluster:   deployment.TargetCluster.Name,
-				Namespace: nwo.config.DefaultNamespace,
-				Status:    deployment.Status,
-			})
+			target := map[string]interface{}{
+				"cluster":   deployment.TargetCluster.Name,
+				"namespace": nwo.config.DefaultNamespace,
+				"status":    deployment.Status,
+			}
+			deploymentInfo["targets"] = append(deploymentInfo["targets"].([]map[string]interface{}), target)
 		}
+
+		deploymentInfoJSON := fmt.Sprintf(`{"phase":"Deployed","targetCount":%d}`, len(execution.Deployments))
+		intent.Status.Extensions["deploymentStatus"] = runtime.RawExtension{Raw: []byte(deploymentInfoJSON)}
 	}
 
 	// Update timestamp
 	now := metav1.NewTime(time.Now())
-	intent.Status.LastProcessed = &now
+	intent.Status.LastUpdateTime = now
 
 	return nwo.client.Status().Update(ctx, intent)
 }
diff --git a/pkg/nephio/workload_cluster_registry.go b/pkg/nephio/workload_cluster_registry.go
index e6926a40..b799da65 100644
--- a/pkg/nephio/workload_cluster_registry.go
+++ b/pkg/nephio/workload_cluster_registry.go
@@ -22,19 +22,13 @@
 	"sync"
 	"time"
 
-	"github.com/go-logr/logr"
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promauto"
 	"go.opentelemetry.io/otel"
 	"go.opentelemetry.io/otel/attribute"
 	"go.opentelemetry.io/otel/trace"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/types"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/log"
-
-	"github.com/thc1006/nephoran-intent-operator/pkg/errors"
 )
 
 // WorkloadClusterConfig defines configuration for workload cluster management
@@ -170,21 +164,21 @@ func NewWorkloadClusterRegistry(
 
 	// Initialize metrics
 	metrics := &ClusterRegistryMetrics{
-		ClusterRegistrations: *promauto.NewCounterVec(
+		ClusterRegistrations: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "nephio_cluster_registrations_total",
 				Help: "Total number of workload cluster registrations",
 			},
 			[]string{"cluster", "region", "status"},
 		),
-		ClusterHealth: *promauto.NewGaugeVec(
+		ClusterHealth: promauto.NewGaugeVec(
 			prometheus.GaugeOpts{
 				Name: "nephio_cluster_health",
 				Help: "Health status of workload clusters",
 			},
 			[]string{"cluster", "region", "component"},
 		),
-		HealthCheckDuration: *promauto.NewHistogramVec(
+		HealthCheckDuration: promauto.NewHistogramVec(
 			prometheus.HistogramOpts{
 				Name:    "nephio_cluster_health_check_duration_seconds",
 				Help:    "Duration of cluster health checks",
@@ -192,21 +186,21 @@ func NewWorkloadClusterRegistry(
 			},
 			[]string{"cluster", "region"},
 		),
-		ClusterCapabilities: *promauto.NewGaugeVec(
+		ClusterCapabilities: promauto.NewGaugeVec(
 			prometheus.GaugeOpts{
 				Name: "nephio_cluster_capabilities",
 				Help: "Number of capabilities per cluster",
 			},
 			[]string{"cluster", "region", "capability"},
 		),
-		RegistrationErrors: *promauto.NewCounterVec(
+		RegistrationErrors: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "nephio_cluster_registration_errors_total",
 				Help: "Total number of cluster registration errors",
 			},
 			[]string{"cluster", "error_type"},
 		),
-		ClusterEvents: *promauto.NewCounterVec(
+		ClusterEvents: promauto.NewCounterVec(
 			prometheus.CounterOpts{
 				Name: "nephio_cluster_events_total",
 				Help: "Total number of cluster events",
@@ -270,7 +264,7 @@ func (wcr *WorkloadClusterRegistry) RegisterWorkloadCluster(ctx context.Context,
 		wcr.metrics.RegistrationErrors.WithLabelValues(
 			cluster.Name, "validation_failed",
 		).Inc()
-		return errors.WithContext(err, "cluster validation failed")
+		return fmt.Errorf("cluster validation failed: %w", err)
 	}
 
 	// Check if cluster already exists
diff --git a/pkg/optimization/telecom_optimizer.go b/pkg/optimization/telecom_optimizer.go
index 1d3a169c..80715c99 100644
--- a/pkg/optimization/telecom_optimizer.go
+++ b/pkg/optimization/telecom_optimizer.go
@@ -18,8 +18,6 @@
 
 import (
 	"context"
-	"fmt"
-	"math"
 	"strings"
 	"time"
 
diff --git a/pkg/oran/e2/e2ap_messages.go b/pkg/oran/e2/e2ap_messages.go
index 7daaf07e..9a1303c3 100644
--- a/pkg/oran/e2/e2ap_messages.go
+++ b/pkg/oran/e2/e2ap_messages.go
@@ -180,6 +180,7 @@ type GlobalE2NodeID struct {
 	PLMNIdentity PLMNIdentity `json:"plmn_identity"`
 	NodeType     E2NodeType   `json:"node_type"`
 	NodeID       string       `json:"node_id"`
+	E2NodeID     E2NodeID     `json:"e2_node_id"`
 }
 
 // GlobalRICID represents the global RIC identifier
diff --git a/pkg/oran/o2/models/deployment_instances.go b/pkg/oran/o2/models/deployment_instances.go
index a2f289fb..cf8f51d4 100644
--- a/pkg/oran/o2/models/deployment_instances.go
+++ b/pkg/oran/o2/models/deployment_instances.go
@@ -39,7 +39,7 @@ type Deployment struct {
 	Health           *DeploymentHealth      `json:"health,omitempty"`
 	
 	// Resources and scaling
-	ResourceStatus   *ResourceStatus        `json:"resourceStatus,omitempty"`
+	ResourceUtilization *ResourceUtilization `json:"resourceUtilization,omitempty"`
 	ScalingPolicy    *ScalingPolicy         `json:"scalingPolicy,omitempty"`
 	
 	// Lifecycle metadata
@@ -108,8 +108,8 @@ type ProbeStatus struct {
 	FailureReason string    `json:"failureReason,omitempty"`
 }
 
-// ResourceStatus represents the resource utilization status
-type ResourceStatus struct {
+// ResourceUtilization represents the resource utilization status
+type ResourceUtilization struct {
 	// Resource allocation
 	AllocatedCPU     string                 `json:"allocatedCpu,omitempty"`
 	AllocatedMemory  string                 `json:"allocatedMemory,omitempty"`
@@ -135,37 +135,6 @@ type ResourceStatus struct {
 	CustomMetrics    map[string]interface{} `json:"customMetrics,omitempty"`
 }
 
-// ScalingPolicy defines auto-scaling policies for the deployment
-type ScalingPolicy struct {
-	Enabled          bool                   `json:"enabled"`
-	MinInstances     int                    `json:"minInstances"`
-	MaxInstances     int                    `json:"maxInstances"`
-	
-	// Scaling triggers
-	CPUThreshold     *float64               `json:"cpuThreshold,omitempty"`
-	MemoryThreshold  *float64               `json:"memoryThreshold,omitempty"`
-	RequestsPerSecond *float64              `json:"requestsPerSecond,omitempty"`
-	
-	// Scaling behavior
-	ScaleUpCooldown  *time.Duration         `json:"scaleUpCooldown,omitempty"`
-	ScaleDownCooldown *time.Duration        `json:"scaleDownCooldown,omitempty"`
-	ScaleUpPolicy    string                 `json:"scaleUpPolicy,omitempty"`
-	ScaleDownPolicy  string                 `json:"scaleDownPolicy,omitempty"`
-	
-	// Custom scaling metrics
-	CustomTriggers   []ScalingTrigger       `json:"customTriggers,omitempty"`
-}
-
-// ScalingTrigger represents a custom scaling trigger
-type ScalingTrigger struct {
-	Name         string      `json:"name"`
-	Type         string      `json:"type"` // metric, queue, custom
-	Threshold    float64     `json:"threshold"`
-	Operator     string      `json:"operator"` // gt, lt, eq, gte, lte
-	MetricPath   string      `json:"metricPath,omitempty"`
-	Query        string      `json:"query,omitempty"`
-	Enabled      bool        `json:"enabled"`
-}
 
 // DeploymentEndpoint represents a network endpoint exposed by the deployment
 type DeploymentEndpoint struct {
@@ -252,13 +221,6 @@ type SecurityCapabilities struct {
 	Drop   []string `json:"drop,omitempty"`
 }
 
-// SELinuxOptions represents SELinux options
-type SELinuxOptions struct {
-	User  string `json:"user,omitempty"`
-	Role  string `json:"role,omitempty"`
-	Type  string `json:"type,omitempty"`
-	Level string `json:"level,omitempty"`
-}
 
 // ComplianceStatus represents compliance and audit information
 type ComplianceStatus struct {
diff --git a/pkg/oran/o2/models/deployments.go b/pkg/oran/o2/models/deployments.go
index cefc909e..18928ddb 100644
--- a/pkg/oran/o2/models/deployments.go
+++ b/pkg/oran/o2/models/deployments.go
@@ -127,6 +127,18 @@ type ScalingPolicy struct {
 	ScaleDownPolicy   *ScalePolicy     `json:"scaleDownPolicy,omitempty"`
 	Metrics           []ScalingMetric  `json:"metrics,omitempty"`
 	Behavior          *ScalingBehavior `json:"behavior,omitempty"`
+	CustomTriggers    []ScalingTrigger `json:"customTriggers,omitempty"`
+}
+
+// ScalingTrigger represents a custom scaling trigger
+type ScalingTrigger struct {
+	Name         string      `json:"name"`
+	Type         string      `json:"type"` // metric, queue, custom
+	Threshold    float64     `json:"threshold"`
+	Operator     string      `json:"operator"` // gt, lt, eq, gte, lte
+	MetricPath   string      `json:"metricPath,omitempty"`
+	Query        string      `json:"query,omitempty"`
+	Enabled      bool        `json:"enabled"`
 }
 
 // ScalePolicy defines scale up/down policies
@@ -404,13 +416,13 @@ type MTLSConfig struct {
 
 // TrafficPolicyConfig defines traffic policy configuration
 type TrafficPolicyConfig struct {
-	LoadBalancer     *LoadBalancerConfig     `json:"loadBalancer,omitempty"`
-	CircuitBreaker   *CircuitBreakerConfig   `json:"circuitBreaker,omitempty"`
-	OutlierDetection *OutlierDetectionConfig `json:"outlierDetection,omitempty"`
+	LoadBalancer     *TrafficLoadBalancerConfig `json:"loadBalancer,omitempty"`
+	CircuitBreaker   *CircuitBreakerConfig      `json:"circuitBreaker,omitempty"`
+	OutlierDetection *OutlierDetectionConfig    `json:"outlierDetection,omitempty"`
 }
 
-// LoadBalancerConfig defines load balancer configuration
-type LoadBalancerConfig struct {
+// TrafficLoadBalancerConfig defines load balancer configuration for traffic policies
+type TrafficLoadBalancerConfig struct {
 	Simple string `json:"simple,omitempty"` // ROUND_ROBIN, LEAST_CONN, RANDOM, PASSTHROUGH
 }
 
@@ -648,8 +660,8 @@ type LabelSelectorRequirement struct {
 	Values   []string `json:"values,omitempty"`
 }
 
-// Deployment represents a deployment instance created from a template
-type Deployment struct {
+// DeploymentInstance represents a deployment instance created from a template
+type DeploymentInstance struct {
 	DeploymentManagerID string                 `json:"deploymentManagerId"`
 	Name                string                 `json:"name"`
 	Description         string                 `json:"description,omitempty"`
@@ -935,19 +947,6 @@ type UpdateStrategy struct {
 	PauseConditions []string      `json:"pauseConditions,omitempty"`
 }
 
-// System Information Model
-
-// SystemInfo represents O2 IMS system information
-type SystemInfo struct {
-	Name                   string                 `json:"name"`
-	Description            string                 `json:"description"`
-	Version                string                 `json:"version"`
-	APIVersions            []string               `json:"apiVersions"`
-	SupportedResourceTypes []string               `json:"supportedResourceTypes"`
-	Extensions             map[string]interface{} `json:"extensions"`
-	Timestamp              time.Time              `json:"timestamp"`
-}
-
 // Additional helper types for deployments
 
 // TemplateParameter defines a parameter for deployment templates
diff --git a/pkg/oran/o2/models/o2_models.go b/pkg/oran/o2/models/o2_models.go
index f6ec65ed..98ff761b 100644
--- a/pkg/oran/o2/models/o2_models.go
+++ b/pkg/oran/o2/models/o2_models.go
@@ -48,30 +48,6 @@ type ConsumerInfo struct {
 	Description  string `json:"description,omitempty"`
 }
 
-// Subscription represents an O2 subscription
-type Subscription struct {
-	SubscriptionID         string                 `json:"subscriptionId"`
-	ConsumerSubscriptionID string                 `json:"consumerSubscriptionId"`
-	Filter                 string                 `json:"filter,omitempty"`
-	Callback               string                 `json:"callback"`
-	ConsumerInfo           *ConsumerInfo          `json:"consumerInfo,omitempty"`
-	EventTypes             []string               `json:"eventTypes"`
-	Status                 string                 `json:"status"`
-	CreatedAt              time.Time              `json:"createdAt"`
-	UpdatedAt              time.Time              `json:"updatedAt"`
-	Metadata               map[string]interface{} `json:"metadata,omitempty"`
-}
-
-// SubscriptionFilter represents filter criteria for subscriptions
-type SubscriptionFilter struct {
-	SubscriptionID         string    `json:"subscriptionId,omitempty"`
-	ConsumerSubscriptionID string    `json:"consumerSubscriptionId,omitempty"`
-	ConsumerID             string    `json:"consumerId,omitempty"`
-	Status                 string    `json:"status,omitempty"`
-	EventTypes             []string  `json:"eventTypes,omitempty"`
-	CreatedAfter           *time.Time `json:"createdAfter,omitempty"`
-	CreatedBefore          *time.Time `json:"createdBefore,omitempty"`
-}
 
 // UpdateSubscriptionRequest represents a subscription update request
 type UpdateSubscriptionRequest struct {
@@ -90,47 +66,6 @@ type NotificationEventType struct {
 	Version     string `json:"version"`
 }
 
-// Node represents an infrastructure inventory node
-type Node struct {
-	NodeID      string                 `json:"nodeId"`
-	Name        string                 `json:"name"`
-	Description string                 `json:"description,omitempty"`
-	Type        string                 `json:"type"`
-	Status      string                 `json:"status"`
-	Location    *NodeLocation          `json:"location,omitempty"`
-	Properties  map[string]interface{} `json:"properties,omitempty"`
-	Resources   []*NodeResource        `json:"resources,omitempty"`
-	CreatedAt   time.Time              `json:"createdAt"`
-	UpdatedAt   time.Time              `json:"updatedAt"`
-}
-
-// NodeLocation represents geographical location of a node
-type NodeLocation struct {
-	Latitude  float64 `json:"latitude"`
-	Longitude float64 `json:"longitude"`
-	Address   string  `json:"address,omitempty"`
-	Site      string  `json:"site,omitempty"`
-	Zone      string  `json:"zone,omitempty"`
-}
-
-// NodeResource represents resources available on a node
-type NodeResource struct {
-	ResourceType string                 `json:"resourceType"`
-	Capacity     map[string]interface{} `json:"capacity"`
-	Available    map[string]interface{} `json:"available"`
-	Reserved     map[string]interface{} `json:"reserved,omitempty"`
-}
-
-// NodeFilter represents filter criteria for inventory nodes
-type NodeFilter struct {
-	NodeID      string   `json:"nodeId,omitempty"`
-	Name        string   `json:"name,omitempty"`
-	Type        string   `json:"type,omitempty"`
-	Status      []string `json:"status,omitempty"`
-	Site        string   `json:"site,omitempty"`
-	Zone        string   `json:"zone,omitempty"`
-	HasResource string   `json:"hasResource,omitempty"`
-}
 
 // Alarm represents an O2 alarm
 type Alarm struct {
@@ -186,36 +121,6 @@ type AlarmClearRequest struct {
 	Metadata     map[string]interface{} `json:"metadata,omitempty"`
 }
 
-// ResourcePoolFilter represents filter criteria for resource pools
-type ResourcePoolFilter struct {
-	PoolID       string   `json:"poolId,omitempty"`
-	Name         string   `json:"name,omitempty"`
-	Type         string   `json:"type,omitempty"`
-	Status       []string `json:"status,omitempty"`
-	Location     string   `json:"location,omitempty"`
-	HasResources bool     `json:"hasResources,omitempty"`
-}
-
-// CreateResourcePoolRequest represents a resource pool creation request
-type CreateResourcePoolRequest struct {
-	Name         string                 `json:"name"`
-	Description  string                 `json:"description,omitempty"`
-	Type         string                 `json:"type"`
-	Location     *PoolLocation          `json:"location,omitempty"`
-	Capacity     map[string]interface{} `json:"capacity,omitempty"`
-	Properties   map[string]interface{} `json:"properties,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
-
-// UpdateResourcePoolRequest represents a resource pool update request
-type UpdateResourcePoolRequest struct {
-	Name         string                 `json:"name,omitempty"`
-	Description  string                 `json:"description,omitempty"`
-	Status       string                 `json:"status,omitempty"`
-	Capacity     map[string]interface{} `json:"capacity,omitempty"`
-	Properties   map[string]interface{} `json:"properties,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
 
 // PoolLocation represents geographical location of a resource pool
 type PoolLocation struct {
@@ -227,100 +132,10 @@ type PoolLocation struct {
 	Region    string  `json:"region,omitempty"`
 }
 
-// ResourceTypeFilter represents filter criteria for resource types
-type ResourceTypeFilter struct {
-	TypeID      string   `json:"typeId,omitempty"`
-	Name        string   `json:"name,omitempty"`
-	Category    string   `json:"category,omitempty"`
-	Vendor      string   `json:"vendor,omitempty"`
-	Version     string   `json:"version,omitempty"`
-	Deployable  *bool    `json:"deployable,omitempty"`
-}
 
-// ResourceFilter represents filter criteria for resources
-type ResourceFilter struct {
-	ResourceID   string   `json:"resourceId,omitempty"`
-	Name         string   `json:"name,omitempty"`
-	Type         string   `json:"type,omitempty"`
-	Status       []string `json:"status,omitempty"`
-	PoolID       string   `json:"poolId,omitempty"`
-	ParentID     string   `json:"parentId,omitempty"`
-	HasChildren  *bool    `json:"hasChildren,omitempty"`
-}
 
-// CreateResourceRequest represents a resource creation request
-type CreateResourceRequest struct {
-	Name         string                 `json:"name"`
-	Description  string                 `json:"description,omitempty"`
-	Type         string                 `json:"type"`
-	PoolID       string                 `json:"poolId"`
-	ParentID     string                 `json:"parentId,omitempty"`
-	Properties   map[string]interface{} `json:"properties,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
 
-// UpdateResourceRequest represents a resource update request
-type UpdateResourceRequest struct {
-	Name         string                 `json:"name,omitempty"`
-	Description  string                 `json:"description,omitempty"`
-	Status       string                 `json:"status,omitempty"`
-	Properties   map[string]interface{} `json:"properties,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
-
-// DeploymentTemplateFilter represents filter criteria for deployment templates
-type DeploymentTemplateFilter struct {
-	TemplateID  string   `json:"templateId,omitempty"`
-	Name        string   `json:"name,omitempty"`
-	Type        string   `json:"type,omitempty"`
-	Version     string   `json:"version,omitempty"`
-	Status      []string `json:"status,omitempty"`
-	Category    string   `json:"category,omitempty"`
-}
 
-// CreateDeploymentTemplateRequest represents a deployment template creation request
-type CreateDeploymentTemplateRequest struct {
-	Name         string                 `json:"name"`
-	Description  string                 `json:"description,omitempty"`
-	Type         string                 `json:"type"`
-	Version      string                 `json:"version"`
-	Category     string                 `json:"category,omitempty"`
-	Template     map[string]interface{} `json:"template"`
-	Parameters   []*TemplateParameter   `json:"parameters,omitempty"`
-	Requirements *TemplateRequirements  `json:"requirements,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
-
-// UpdateDeploymentTemplateRequest represents a deployment template update request
-type UpdateDeploymentTemplateRequest struct {
-	Name         string                 `json:"name,omitempty"`
-	Description  string                 `json:"description,omitempty"`
-	Status       string                 `json:"status,omitempty"`
-	Template     map[string]interface{} `json:"template,omitempty"`
-	Parameters   []*TemplateParameter   `json:"parameters,omitempty"`
-	Requirements *TemplateRequirements  `json:"requirements,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
-
-// TemplateParameter represents a template parameter
-type TemplateParameter struct {
-	Name         string      `json:"name"`
-	Type         string      `json:"type"`
-	Description  string      `json:"description,omitempty"`
-	DefaultValue interface{} `json:"defaultValue,omitempty"`
-	Required     bool        `json:"required"`
-	Constraints  *ParamConstraints `json:"constraints,omitempty"`
-}
-
-// ParamConstraints represents parameter constraints
-type ParamConstraints struct {
-	MinValue    *float64 `json:"minValue,omitempty"`
-	MaxValue    *float64 `json:"maxValue,omitempty"`
-	MinLength   *int     `json:"minLength,omitempty"`
-	MaxLength   *int     `json:"maxLength,omitempty"`
-	Pattern     string   `json:"pattern,omitempty"`
-	AllowedValues []interface{} `json:"allowedValues,omitempty"`
-}
 
 // TemplateRequirements represents template resource requirements
 type TemplateRequirements struct {
@@ -340,34 +155,4 @@ type NetworkReqs struct {
 	NetworkPolicies []string  `json:"networkPolicies,omitempty"`
 }
 
-// DeploymentFilter represents filter criteria for deployments
-type DeploymentFilter struct {
-	DeploymentID string   `json:"deploymentId,omitempty"`
-	Name         string   `json:"name,omitempty"`
-	TemplateID   string   `json:"templateId,omitempty"`
-	Status       []string `json:"status,omitempty"`
-	Environment  string   `json:"environment,omitempty"`
-	PoolID       string   `json:"poolId,omitempty"`
-	CreatedBy    string   `json:"createdBy,omitempty"`
-}
-
-// CreateDeploymentRequest represents a deployment creation request
-type CreateDeploymentRequest struct {
-	Name         string                 `json:"name"`
-	Description  string                 `json:"description,omitempty"`
-	TemplateID   string                 `json:"templateId"`
-	Parameters   map[string]interface{} `json:"parameters,omitempty"`
-	PoolID       string                 `json:"poolId"`
-	Environment  string                 `json:"environment,omitempty"`
-	AutoStart    bool                   `json:"autoStart"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
 
-// UpdateDeploymentRequest represents a deployment update request
-type UpdateDeploymentRequest struct {
-	Name         string                 `json:"name,omitempty"`
-	Description  string                 `json:"description,omitempty"`
-	Status       string                 `json:"status,omitempty"`
-	Parameters   map[string]interface{} `json:"parameters,omitempty"`
-	Metadata     map[string]interface{} `json:"metadata,omitempty"`
-}
\ No newline at end of file
diff --git a/pkg/packagerevision/factory.go b/pkg/packagerevision/factory.go
index 5c4f9d74..14e5d787 100644
--- a/pkg/packagerevision/factory.go
+++ b/pkg/packagerevision/factory.go
@@ -387,7 +387,11 @@ func (f *systemFactory) CreateCompleteSystem(ctx context.Context, systemConfig *
 func (f *systemFactory) CreatePorchClient(ctx context.Context, config *porch.ClientConfig) (porch.PorchClient, error) {
 	f.logger.Info("Creating Porch client", "endpoint", config.Endpoint)
 
-	client, err := porch.NewClient(config)
+	opts := porch.ClientOptions{
+		Config: config,
+		Logger: f.logger,
+	}
+	client, err := porch.NewClient(opts)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create Porch client: %w", err)
 	}
@@ -406,7 +410,13 @@ func (f *systemFactory) CreatePorchClient(ctx context.Context, config *porch.Cli
 func (f *systemFactory) CreateLifecycleManager(ctx context.Context, client porch.PorchClient, config *porch.LifecycleManagerConfig) (porch.LifecycleManager, error) {
 	f.logger.Info("Creating lifecycle manager")
 
-	lifecycleManager, err := porch.NewLifecycleManager(client, config)
+	// Type assert PorchClient to *Client for NewLifecycleManager
+	clientImpl, ok := client.(*porch.Client)
+	if !ok {
+		return nil, fmt.Errorf("client must be *porch.Client, got %T", client)
+	}
+
+	lifecycleManager, err := porch.NewLifecycleManager(clientImpl, config)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create lifecycle manager: %w", err)
 	}
@@ -613,7 +623,7 @@ func (f *systemFactory) performSystemHealthCheck(ctx context.Context, system *Pa
 	}
 
 	// Check Porch client health
-	if porchHealth, err := system.Components.PorchClient.Health(ctx); err != nil {
+	if _, err := system.Components.PorchClient.Health(ctx); err != nil {
 		health.Status = "degraded"
 		health.Components["porch-client"] = ComponentHealth{
 			Status:    "unhealthy",
@@ -624,7 +634,7 @@ func (f *systemFactory) performSystemHealthCheck(ctx context.Context, system *Pa
 		health.Components["porch-client"] = ComponentHealth{
 			Status:    "healthy",
 			LastCheck: time.Now(),
-			Version:   porchHealth.Version,
+			// Note: HealthStatus doesn't have Version field
 		}
 	}
 
@@ -810,7 +820,7 @@ func GetDefaultSystemConfig() *SystemConfig {
 		GracefulShutdownTimeout: 30 * time.Second,
 		PorchConfig: &porch.ClientConfig{
 			Endpoint: "http://porch-server:8080",
-			Timeout:  30 * time.Second,
+			// Note: ClientConfig doesn't have Timeout field
 		},
 		Features: &FeatureFlags{
 			EnableORANCompliance:     true,
diff --git a/pkg/packagerevision/integration.go b/pkg/packagerevision/integration.go
index cfe34f8a..4f923285 100644
--- a/pkg/packagerevision/integration.go
+++ b/pkg/packagerevision/integration.go
@@ -259,7 +259,7 @@ func (r *NetworkIntentPackageReconciler) initializeIntent(ctx context.Context, i
 
 	// Update status to pending
 	intent.Status.Phase = nephoranv1.NetworkIntentPhasePending
-	intent.Status.Message = "Initializing intent processing"
+	intent.Status.LastMessage = "Initializing intent processing"
 
 	return ctrl.Result{RequeueAfter: time.Second}, nil
 }
@@ -272,7 +272,7 @@ func (r *NetworkIntentPackageReconciler) handlePendingIntent(ctx context.Context
 	if status.PackageReference != nil {
 		// PackageRevision exists, move to processing
 		intent.Status.Phase = nephoranv1.NetworkIntentPhaseProcessing
-		intent.Status.Message = "PackageRevision exists, processing intent"
+		intent.Status.LastMessage = "PackageRevision exists, processing intent"
 		return ctrl.Result{RequeueAfter: time.Second}, nil
 	}
 
@@ -280,7 +280,7 @@ func (r *NetworkIntentPackageReconciler) handlePendingIntent(ctx context.Context
 	packageRevision, err := r.PackageManager.CreateFromIntent(ctx, intent)
 	if err != nil {
 		intent.Status.Phase = nephoranv1.NetworkIntentPhaseFailed
-		intent.Status.Message = fmt.Sprintf("Failed to create PackageRevision: %v", err)
+		intent.Status.LastMessage = fmt.Sprintf("Failed to create PackageRevision: %v", err)
 		return ctrl.Result{RequeueAfter: r.Config.FailureRetryInterval}, err
 	}
 
@@ -304,7 +304,7 @@ func (r *NetworkIntentPackageReconciler) handlePendingIntent(ctx context.Context
 
 	// Move to processing phase
 	intent.Status.Phase = nephoranv1.NetworkIntentPhaseProcessing
-	intent.Status.Message = fmt.Sprintf("PackageRevision created: %s", status.PackageReference.GetPackageKey())
+	intent.Status.LastMessage = fmt.Sprintf("PackageRevision created: %s", status.PackageReference.GetPackageKey())
 
 	r.Logger.Info("PackageRevision created successfully",
 		"intent", intent.Name,
@@ -328,7 +328,7 @@ func (r *NetworkIntentPackageReconciler) handleProcessingIntent(ctx context.Cont
 		if err != nil {
 			if !r.Config.ContinueOnValidationError {
 				intent.Status.Phase = nephoranv1.NetworkIntentPhaseFailed
-				intent.Status.Message = fmt.Sprintf("YANG validation failed: %v", err)
+				intent.Status.LastMessage = fmt.Sprintf("YANG validation failed: %v", err)
 				return ctrl.Result{RequeueAfter: r.Config.FailureRetryInterval}, err
 			}
 			r.Logger.Error(err, "YANG validation failed but continuing", "intent", intent.Name)
@@ -341,7 +341,7 @@ func (r *NetworkIntentPackageReconciler) handleProcessingIntent(ctx context.Cont
 		transitionResult, err := r.promotePackage(ctx, intent, status, porch.PackageRevisionLifecycleProposed)
 		if err != nil {
 			intent.Status.Phase = nephoranv1.NetworkIntentPhaseFailed
-			intent.Status.Message = fmt.Sprintf("Failed to promote to Proposed: %v", err)
+			intent.Status.LastMessage = fmt.Sprintf("Failed to promote to Proposed: %v", err)
 			return ctrl.Result{RequeueAfter: r.Config.FailureRetryInterval}, err
 		}
 
@@ -358,14 +358,14 @@ func (r *NetworkIntentPackageReconciler) handleProcessingIntent(ctx context.Cont
 		if status.ApprovalStatus == nil || status.ApprovalStatus.Status == "pending" {
 			// Approval workflow is pending
 			intent.Status.Phase = nephoranv1.NetworkIntentPhaseProcessing
-			intent.Status.Message = fmt.Sprintf("Waiting for approvals (%d/%d required)",
+			intent.Status.LastMessage = fmt.Sprintf("Waiting for approvals (%d/%d required)",
 				r.getReceivedApprovals(status), r.Config.RequiredApprovals)
 			return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
 		}
 
 		if status.ApprovalStatus.Status == "rejected" {
 			intent.Status.Phase = nephoranv1.NetworkIntentPhaseFailed
-			intent.Status.Message = "Intent rejected during approval workflow"
+			intent.Status.LastMessage = "Intent rejected during approval workflow"
 			return ctrl.Result{}, nil
 		}
 	}
@@ -378,7 +378,7 @@ func (r *NetworkIntentPackageReconciler) handleProcessingIntent(ctx context.Cont
 		transitionResult, err := r.promotePackage(ctx, intent, status, porch.PackageRevisionLifecyclePublished)
 		if err != nil {
 			intent.Status.Phase = nephoranv1.NetworkIntentPhaseFailed
-			intent.Status.Message = fmt.Sprintf("Failed to promote to Published: %v", err)
+			intent.Status.LastMessage = fmt.Sprintf("Failed to promote to Published: %v", err)
 			return ctrl.Result{RequeueAfter: r.Config.FailureRetryInterval}, err
 		}
 
@@ -387,7 +387,7 @@ func (r *NetworkIntentPackageReconciler) handleProcessingIntent(ctx context.Cont
 
 		// Move to deploying phase
 		intent.Status.Phase = nephoranv1.NetworkIntentPhaseDeploying
-		intent.Status.Message = "Package published, starting deployment"
+		intent.Status.LastMessage = "Package published, starting deployment"
 
 		r.Logger.Info("Package promoted to Published",
 			"intent", intent.Name,
@@ -399,7 +399,7 @@ func (r *NetworkIntentPackageReconciler) handleProcessingIntent(ctx context.Cont
 	// If package is published but we're still in processing, move to deploying
 	if status.PackageLifecycle == porch.PackageRevisionLifecyclePublished {
 		intent.Status.Phase = nephoranv1.NetworkIntentPhaseDeploying
-		intent.Status.Message = "Package published, starting deployment"
+		intent.Status.LastMessage = "Package published, starting deployment"
 		return ctrl.Result{RequeueAfter: time.Second}, nil
 	}
 
@@ -425,7 +425,7 @@ func (r *NetworkIntentPackageReconciler) handleDeployingIntent(ctx context.Conte
 	switch deploymentStatus {
 	case "deployed":
 		intent.Status.Phase = nephoranv1.NetworkIntentPhaseActive
-		intent.Status.Message = "Intent successfully deployed"
+		intent.Status.LastMessage = "Intent successfully deployed"
 		r.Logger.Info("NetworkIntent deployment completed",
 			"intent", intent.Name,
 			"package", status.PackageReference.GetPackageKey())
@@ -433,15 +433,15 @@ func (r *NetworkIntentPackageReconciler) handleDeployingIntent(ctx context.Conte
 
 	case "failed":
 		intent.Status.Phase = nephoranv1.NetworkIntentPhaseFailed
-		intent.Status.Message = "Deployment failed"
+		intent.Status.LastMessage = "Deployment failed"
 		return ctrl.Result{RequeueAfter: r.Config.FailureRetryInterval}, nil
 
 	case "pending", "deploying":
-		intent.Status.Message = "Deployment in progress"
+		intent.Status.LastMessage = "Deployment in progress"
 		return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
 
 	default:
-		intent.Status.Message = fmt.Sprintf("Unknown deployment status: %s", deploymentStatus)
+		intent.Status.LastMessage = fmt.Sprintf("Unknown deployment status: %s", deploymentStatus)
 		return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
 	}
 }
@@ -456,7 +456,7 @@ func (r *NetworkIntentPackageReconciler) handleActiveIntent(ctx context.Context,
 		if err != nil {
 			r.Logger.Error(err, "Failed to detect configuration drift", "intent", intent.Name)
 		} else if driftResult.HasDrift {
-			intent.Status.Message = fmt.Sprintf("Configuration drift detected (severity: %s)", driftResult.Severity)
+			intent.Status.LastMessage = fmt.Sprintf("Configuration drift detected (severity: %s)", driftResult.Severity)
 			r.Logger.Info("Configuration drift detected",
 				"intent", intent.Name,
 				"severity", driftResult.Severity,
@@ -467,7 +467,7 @@ func (r *NetworkIntentPackageReconciler) handleActiveIntent(ctx context.Context,
 				if err := r.PackageManager.CorrectConfigurationDrift(ctx, status.PackageReference, driftResult); err != nil {
 					r.Logger.Error(err, "Failed to correct configuration drift", "intent", intent.Name)
 				} else {
-					intent.Status.Message = "Configuration drift auto-corrected"
+					intent.Status.LastMessage = "Configuration drift auto-corrected"
 					r.Logger.Info("Configuration drift auto-corrected", "intent", intent.Name)
 				}
 			}
@@ -491,14 +491,14 @@ func (r *NetworkIntentPackageReconciler) handleFailedIntent(ctx context.Context,
 
 		// Reset to pending for retry
 		intent.Status.Phase = nephoranv1.NetworkIntentPhasePending
-		intent.Status.Message = fmt.Sprintf("Retrying intent processing (attempt %d/%d)",
+		intent.Status.LastMessage = fmt.Sprintf("Retrying intent processing (attempt %d/%d)",
 			status.ErrorCount+1, r.Config.FailureRetryCount)
 
 		return ctrl.Result{RequeueAfter: r.Config.FailureRetryInterval}, nil
 	}
 
 	// Max retries exceeded, keep in failed state
-	intent.Status.Message = fmt.Sprintf("Intent failed after %d attempts. Last error: %s",
+	intent.Status.LastMessage = fmt.Sprintf("Intent failed after %d attempts. Last error: %s",
 		r.Config.FailureRetryCount, status.LastError)
 
 	return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil
diff --git a/pkg/shared/state_manager.go b/pkg/shared/state_manager.go
index 3c556abe..41526a30 100644
--- a/pkg/shared/state_manager.go
+++ b/pkg/shared/state_manager.go
@@ -447,7 +447,7 @@ func (sm *StateManager) updateKubernetesState(ctx context.Context, namespacedNam
 	}
 
 	// Update intent status based on state
-	intent.Status.Phase = string(state.CurrentPhase)
+	intent.Status.Phase = ProcessingPhaseToNetworkIntentPhase(state.CurrentPhase)
 
 	// Update last message from conditions if available
 	if len(state.Conditions) > 0 {
diff --git a/tests/disaster-recovery/disaster_recovery_test_fixed.go b/tests/disaster-recovery/disaster_recovery_test_fixed.go
index ba864edc..8b2784af 100644
--- a/tests/disaster-recovery/disaster_recovery_test_fixed.go
+++ b/tests/disaster-recovery/disaster_recovery_test_fixed.go
@@ -16,8 +16,6 @@
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
-	"k8s.io/client-go/kubernetes/scheme"
-	"sigs.k8s.io/controller-runtime/pkg/client"
 
 	nephoran "github.com/thc1006/nephoran-intent-operator/api/v1"
 	"github.com/thc1006/nephoran-intent-operator/hack/testtools"
diff --git a/tests/validation/system_validator.go b/tests/validation/system_validator.go
index 29f22937..1f62e411 100644
--- a/tests/validation/system_validator.go
+++ b/tests/validation/system_validator.go
@@ -83,24 +83,24 @@ func (sv *SystemValidator) ValidateIntentProcessingPipeline(ctx context.Context)
 			return false
 		}
 
-		phasesObserved[testIntent.Status.Phase] = true
+		phasesObserved[string(testIntent.Status.Phase)] = true
 
 		// Check if we've seen all expected phases or reached a terminal state
 		for _, phase := range expectedPhases {
 			if !phasesObserved[phase] &&
-				testIntent.Status.Phase != "Deployed" &&
-				testIntent.Status.Phase != "Failed" {
+				string(testIntent.Status.Phase) != "Deployed" &&
+				string(testIntent.Status.Phase) != "Failed" {
 				return false
 			}
 		}
 
-		return testIntent.Status.Phase == "Deployed" ||
+		return string(testIntent.Status.Phase) == "Deployed" ||
 			len(phasesObserved) >= len(expectedPhases)-1
 	}, 5*time.Minute, 5*time.Second).Should(gomega.BeTrue())
 
 	// Verify final state is not failed
 	finalErr := sv.k8sClient.Get(ctx, client.ObjectKeyFromObject(testIntent), testIntent)
-	if finalErr != nil || testIntent.Status.Phase == "Failed" {
+	if finalErr != nil || string(testIntent.Status.Phase) == "Failed" {
 		ginkgo.By(fmt.Sprintf("Intent processing failed: phase=%s", testIntent.Status.Phase))
 		return false
 	}
@@ -157,9 +157,9 @@ func (sv *SystemValidator) ValidateLLMRAGIntegration(ctx context.Context) bool {
 		gomega.Eventually(func() bool {
 			err := sv.k8sClient.Get(ctx, client.ObjectKeyFromObject(testIntent), testIntent)
 			return err == nil &&
-				(testIntent.Status.Phase == "ResourcePlanning" ||
-					testIntent.Status.Phase == "ManifestGeneration" ||
-					testIntent.Status.Phase == "Deployed")
+				(string(testIntent.Status.Phase) == "ResourcePlanning" ||
+					string(testIntent.Status.Phase) == "ManifestGeneration" ||
+					string(testIntent.Status.Phase) == "Deployed")
 		}, 2*time.Minute, 2*time.Second).Should(gomega.BeTrue())
 
 		// Verify the LLM correctly identified the network function type
@@ -218,8 +218,8 @@ func (sv *SystemValidator) ValidatePorchIntegration(ctx context.Context) bool {
 	gomega.Eventually(func() bool {
 		err := sv.k8sClient.Get(ctx, client.ObjectKeyFromObject(testIntent), testIntent)
 		return err == nil &&
-			(testIntent.Status.Phase == "ManifestGeneration" ||
-				testIntent.Status.Phase == "Deployed")
+			(string(testIntent.Status.Phase) == "ManifestGeneration" ||
+				string(testIntent.Status.Phase) == "Deployed")
 	}, 3*time.Minute, 5*time.Second).Should(gomega.BeTrue())
 
 	// Verify package-related status information
@@ -236,8 +236,8 @@ func (sv *SystemValidator) ValidatePorchIntegration(ctx context.Context) bool {
 	}
 
 	// Verify packages were created (check status or annotations)
-	packageCreated := testIntent.Status.Phase == "ManifestGeneration" ||
-		testIntent.Status.Phase == "Deployed"
+	packageCreated := string(testIntent.Status.Phase) == "ManifestGeneration" ||
+		string(testIntent.Status.Phase) == "Deployed"
 
 	if packageCreated {
 		ginkgo.By("✓ Porch package integration verified")
@@ -279,7 +279,7 @@ func (sv *SystemValidator) ValidateMultiClusterDeployment(ctx context.Context) b
 	ginkgo.By("Waiting for multi-cluster deployment")
 	gomega.Eventually(func() bool {
 		err := sv.k8sClient.Get(ctx, client.ObjectKeyFromObject(testIntent), testIntent)
-		return err == nil && testIntent.Status.Phase == "Deployed"
+		return err == nil && string(testIntent.Status.Phase) == "Deployed"
 	}, 5*time.Minute, 10*time.Second).Should(gomega.BeTrue())
 
 	// Verify deployment succeeded
@@ -288,7 +288,7 @@ func (sv *SystemValidator) ValidateMultiClusterDeployment(ctx context.Context) b
 		return false
 	}
 
-	deployed := testIntent.Status.Phase == "Deployed"
+	deployed := string(testIntent.Status.Phase) == "Deployed"
 	if deployed {
 		ginkgo.By("✓ Multi-cluster deployment validated")
 	} else {
