#!/bin/bash
# Nephoran Intent Operator Vulnerability Scanner
# Performs comprehensive vulnerability assessment for containers and dependencies
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NAMESPACE="${NAMESPACE:-nephoran-system}"
REPORT_DIR="${REPORT_DIR:-/tmp/nephoran-security-reports}"
TIMESTAMP=$(date +"%Y%m%d-%H%M%S")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
}

success() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] SUCCESS: $1${NC}"
}

# Initialize report directory
mkdir -p "$REPORT_DIR"

check_scanner_dependencies() {
    local missing_tools=()
    
    # Check for Trivy
    if ! command -v trivy >/dev/null 2>&1; then
        missing_tools+=("trivy")
    fi
    
    # Check for Docker
    if ! command -v docker >/dev/null 2>&1; then
        missing_tools+=("docker")
    fi
    
    # Check for kubectl
    if ! command -v kubectl >/dev/null 2>&1; then
        missing_tools+=("kubectl")
    fi
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        error "Missing required tools: ${missing_tools[*]}"
        log "Installing missing tools..."
        
        # Install Trivy if missing
        if [[ " ${missing_tools[*]} " =~ " trivy " ]]; then
            log "Installing Trivy..."
            if command -v apt-get >/dev/null 2>&1; then
                sudo apt-get update
                sudo apt-get install -y wget apt-transport-https gnupg lsb-release
                wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
                echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
                sudo apt-get update
                sudo apt-get install -y trivy
            elif command -v yum >/dev/null 2>&1; then
                sudo yum install -y wget
                sudo rpm --import https://aquasecurity.github.io/trivy-repo/rpm/public.key
                echo -e "[trivy]\nname=Trivy repository\nbaseurl=https://aquasecurity.github.io/trivy-repo/rpm/releases/\$basearch/\ngpgcheck=1\nenabled=1" | sudo tee -a /etc/yum.repos.d/trivy.repo
                sudo yum install -y trivy
            else
                warn "Please install Trivy manually: https://aquasecurity.github.io/trivy/latest/getting-started/installation/"
                return 1
            fi
        fi
    fi
    
    success "All required tools are available"
    return 0
}

scan_container_vulnerabilities() {
    log "Scanning container images for vulnerabilities..."
    
    local images_report="$REPORT_DIR/container-vulnerabilities-$TIMESTAMP.json"
    local total_vulnerabilities=0
    local critical_vulnerabilities=0
    local high_vulnerabilities=0
    
    echo "{\"timestamp\": \"$(date -Iseconds)\", \"images\": []}" > "$images_report"
    
    # Get all unique images from the namespace
    local images=$(kubectl get pods -n "$NAMESPACE" -o json | \
        jq -r '.items[].spec.containers[].image' | sort -u)
    
    for image in $images; do
        log "Scanning image: $image"
        
        # Create temporary file for trivy output
        local temp_report="/tmp/trivy-scan-$(basename "$image" | tr '/' '-' | tr ':' '-').json"
        
        # Run Trivy scan
        if trivy image --format json --output "$temp_report" "$image" 2>/dev/null; then
            # Parse Trivy results
            local image_vulns=$(jq -r '.Results[]?.Vulnerabilities[]? | length' "$temp_report" 2>/dev/null | paste -sd+ - | bc 2>/dev/null || echo "0")
            local image_critical=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | length' "$temp_report" 2>/dev/null | paste -sd+ - | bc 2>/dev/null || echo "0")
            local image_high=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH") | length' "$temp_report" 2>/dev/null | paste -sd+ - | bc 2>/dev/null || echo "0")
            
            total_vulnerabilities=$((total_vulnerabilities + image_vulns))
            critical_vulnerabilities=$((critical_vulnerabilities + image_critical))
            high_vulnerabilities=$((high_vulnerabilities + image_high))
            
            # Add to report
            jq --arg image "$image" --argjson vulns "$image_vulns" --argjson critical "$image_critical" --argjson high "$image_high" \
                '.images += [{"image": $image, "total_vulnerabilities": $vulns, "critical": $critical, "high": $high}]' \
                "$images_report" > "${images_report}.tmp" && mv "${images_report}.tmp" "$images_report"
            
            log "  Found $image_vulns vulnerabilities ($image_critical critical, $image_high high)"
        else
            warn "Failed to scan image: $image"
            jq --arg image "$image" '.images += [{"image": $image, "scan_failed": true}]' \
                "$images_report" > "${images_report}.tmp" && mv "${images_report}.tmp" "$images_report"
        fi
        
        # Cleanup temp file
        rm -f "$temp_report"
    done
    
    # Update summary
    jq --argjson total "$total_vulnerabilities" --argjson critical "$critical_vulnerabilities" --argjson high "$high_vulnerabilities" \
        '.summary = {"total_vulnerabilities": $total, "critical_vulnerabilities": $critical, "high_vulnerabilities": $high}' \
        "$images_report" > "${images_report}.tmp" && mv "${images_report}.tmp" "$images_report"
    
    log "Container vulnerability scan complete:"
    log "  Total vulnerabilities: $total_vulnerabilities"
    log "  Critical: $critical_vulnerabilities"
    log "  High: $high_vulnerabilities"
    
    return $((critical_vulnerabilities + high_vulnerabilities))
}

scan_kubernetes_configuration() {
    log "Scanning Kubernetes configuration for security issues..."
    
    local k8s_report="$REPORT_DIR/k8s-security-scan-$TIMESTAMP.json"
    local issues=0
    
    echo "{\"timestamp\": \"$(date -Iseconds)\", \"findings\": []}" > "$k8s_report"
    
    # Scan with Trivy for Kubernetes configuration issues
    local temp_k8s_report="/tmp/trivy-k8s-scan.json"
    
    if kubectl get all -n "$NAMESPACE" -o yaml | trivy config --format json --output "$temp_k8s_report" - 2>/dev/null; then
        # Parse and process results
        local config_issues=$(jq -r '.Results[]?.Misconfigurations[]? | length' "$temp_k8s_report" 2>/dev/null | paste -sd+ - | bc 2>/dev/null || echo "0")
        issues=$((issues + config_issues))
        
        # Extract specific findings
        jq -r '.Results[]?.Misconfigurations[]? | {type: .Type, severity: .Severity, title: .Title, description: .Description}' "$temp_k8s_report" 2>/dev/null | \
        while IFS= read -r finding; do
            if [ -n "$finding" ] && [ "$finding" != "null" ]; then
                jq --argjson finding "$finding" '.findings += [$finding]' \
                    "$k8s_report" > "${k8s_report}.tmp" && mv "${k8s_report}.tmp" "$k8s_report"
            fi
        done
        
        log "Found $config_issues Kubernetes configuration issues"
    else
        warn "Failed to scan Kubernetes configuration"
    fi
    
    # Cleanup temp file
    rm -f "$temp_k8s_report"
    
    return $issues
}

scan_dependency_vulnerabilities() {
    log "Scanning dependency vulnerabilities..."
    
    local deps_report="$REPORT_DIR/dependency-vulnerabilities-$TIMESTAMP.json"
    local total_deps=0
    
    echo "{\"timestamp\": \"$(date -Iseconds)\", \"dependencies\": []}" > "$deps_report"
    
    # Scan Go dependencies if go.mod exists
    if [[ -f "go.mod" ]]; then
        log "Scanning Go dependencies..."
        
        # Use go list to get dependencies and scan with Trivy
        if command -v go >/dev/null 2>&1; then
            local temp_deps="/tmp/go-deps.txt"
            go list -m all > "$temp_deps" 2>/dev/null || echo "" > "$temp_deps"
            
            if trivy fs --security-checks vuln --format json --output "/tmp/go-scan.json" . 2>/dev/null; then
                local go_vulns=$(jq -r '.Results[]?.Vulnerabilities[]? | length' "/tmp/go-scan.json" 2>/dev/null | paste -sd+ - | bc 2>/dev/null || echo "0")
                total_deps=$((total_deps + go_vulns))
                
                jq '.dependencies += [{"type": "go", "vulnerabilities": '${go_vulns}'}]' \
                    "$deps_report" > "${deps_report}.tmp" && mv "${deps_report}.tmp" "$deps_report"
                
                log "Found $go_vulns Go dependency vulnerabilities"
            fi
            
            rm -f "$temp_deps" "/tmp/go-scan.json"
        fi
    fi
    
    # Scan Python dependencies if requirements files exist
    for req_file in requirements*.txt; do
        if [[ -f "$req_file" ]]; then
            log "Scanning Python dependencies from $req_file..."
            
            if trivy fs --security-checks vuln --format json --output "/tmp/python-scan.json" "$req_file" 2>/dev/null; then
                local python_vulns=$(jq -r '.Results[]?.Vulnerabilities[]? | length' "/tmp/python-scan.json" 2>/dev/null | paste -sd+ - | bc 2>/dev/null || echo "0")
                total_deps=$((total_deps + python_vulns))
                
                jq --arg file "$req_file" '.dependencies += [{"type": "python", "file": $file, "vulnerabilities": '${python_vulns}'}]' \
                    "$deps_report" > "${deps_report}.tmp" && mv "${deps_report}.tmp" "$deps_report"
                
                log "Found $python_vulns Python dependency vulnerabilities in $req_file"
            fi
            
            rm -f "/tmp/python-scan.json"
        fi
    done
    
    log "Dependency vulnerability scan complete: $total_deps vulnerabilities found"
    return $total_deps
}

perform_network_security_scan() {
    log "Performing network security assessment..."
    
    local network_report="$REPORT_DIR/network-security-$TIMESTAMP.json"
    local network_issues=0
    
    echo "{\"timestamp\": \"$(date -Iseconds)\", \"network_findings\": []}" > "$network_report"
    
    # Check for exposed services
    local exposed_services=$(kubectl get services -n "$NAMESPACE" -o json | \
        jq -r '.items[] | select(.spec.type == "LoadBalancer" or .spec.type == "NodePort") | .metadata.name' | wc -l)
    
    if [ "$exposed_services" -gt 0 ]; then
        warn "Found $exposed_services exposed services (LoadBalancer/NodePort)"
        network_issues=$((network_issues + exposed_services))
        
        jq --argjson count "$exposed_services" '.network_findings += [{"type": "exposed_services", "count": $count, "severity": "medium"}]' \
            "$network_report" > "${network_report}.tmp" && mv "${network_report}.tmp" "$network_report"
    fi
    
    # Check for services without network policies
    local services_without_netpol=0
    kubectl get services -n "$NAMESPACE" -o json | jq -r '.items[].metadata.name' | \
    while read service; do
        local netpol_count=$(kubectl get networkpolicies -n "$NAMESPACE" -o json | \
            jq -r --arg svc "$service" '.items[] | select(.spec.podSelector.matchLabels.app == $svc) | .metadata.name' | wc -l)
        
        if [ "$netpol_count" -eq 0 ]; then
            services_without_netpol=$((services_without_netpol + 1))
        fi
    done
    
    if [ "$services_without_netpol" -gt 0 ]; then
        warn "Found $services_without_netpol services without specific NetworkPolicies"
        network_issues=$((network_issues + services_without_netpol))
    fi
    
    # Check for ingress configurations
    local insecure_ingress=$(kubectl get ingress -n "$NAMESPACE" -o json 2>/dev/null | \
        jq -r '.items[] | select(.spec.tls == null) | .metadata.name' | wc -l || echo "0")
    
    if [ "$insecure_ingress" -gt 0 ]; then
        warn "Found $insecure_ingress ingresses without TLS configuration"
        network_issues=$((network_issues + insecure_ingress))
        
        jq --argjson count "$insecure_ingress" '.network_findings += [{"type": "insecure_ingress", "count": $count, "severity": "high"}]' \
            "$network_report" > "${network_report}.tmp" && mv "${network_report}.tmp" "$network_report"
    fi
    
    log "Network security scan complete: $network_issues issues found"
    return $network_issues
}

generate_vulnerability_report() {
    log "Generating comprehensive vulnerability assessment report..."
    
    local vuln_report="$REPORT_DIR/vulnerability-assessment-$TIMESTAMP.json"
    
    # Run all vulnerability scans
    scan_container_vulnerabilities
    local container_issues=$?
    
    scan_kubernetes_configuration
    local k8s_issues=$?
    
    scan_dependency_vulnerabilities
    local dep_issues=$?
    
    perform_network_security_scan
    local network_issues=$?
    
    local total_issues=$((container_issues + k8s_issues + dep_issues + network_issues))
    
    # Calculate vulnerability score
    local max_score=100
    local critical_deduction=10
    local high_deduction=5
    local medium_deduction=2
    
    # For simplicity, assuming equal distribution of severities
    local critical_count=$((container_issues / 3))
    local high_count=$((container_issues / 3))
    local medium_count=$((total_issues - critical_count - high_count))
    
    local vuln_score=$((max_score - (critical_count * critical_deduction) - (high_count * high_deduction) - (medium_count * medium_deduction)))
    if [ "$vuln_score" -lt 0 ]; then
        vuln_score=0
    fi
    
    # Generate comprehensive report
    cat > "$vuln_report" <<EOF
{
  "timestamp": "$(date -Iseconds)",
  "namespace": "$NAMESPACE",
  "vulnerability_assessment": {
    "total_issues": $total_issues,
    "vulnerability_score": $vuln_score,
    "max_score": $max_score,
    "status": "$([ $vuln_score -ge 80 ] && echo "PASS" || echo "FAIL")"
  },
  "scan_results": {
    "container_vulnerabilities": {
      "issues": $container_issues,
      "status": "$([ $container_issues -le 5 ] && echo "PASS" || echo "FAIL")"
    },
    "kubernetes_configuration": {
      "issues": $k8s_issues,
      "status": "$([ $k8s_issues -eq 0 ] && echo "PASS" || echo "FAIL")"
    },
    "dependency_vulnerabilities": {
      "issues": $dep_issues,
      "status": "$([ $dep_issues -le 3 ] && echo "PASS" || echo "FAIL")"
    },
    "network_security": {
      "issues": $network_issues,
      "status": "$([ $network_issues -le 2 ] && echo "PASS" || echo "FAIL")"
    }
  },
  "severity_breakdown": {
    "critical": $critical_count,
    "high": $high_count,
    "medium": $medium_count
  },
  "recommendations": [
    $([ $container_issues -gt 5 ] && echo "\"Update container images to latest versions with security patches\",")
    $([ $k8s_issues -gt 0 ] && echo "\"Fix Kubernetes configuration security issues\",")
    $([ $dep_issues -gt 3 ] && echo "\"Update dependencies to non-vulnerable versions\",")
    $([ $network_issues -gt 2 ] && echo "\"Implement proper network security controls\",")
    "\"Regular vulnerability scanning and continuous monitoring\",",
    "\"Implement automated security patch management\""
  ]
}
EOF
    
    log "Vulnerability assessment complete:"
    log "  Total issues: $total_issues"
    log "  Vulnerability score: $vuln_score/$max_score"
    log "  Status: $([ $vuln_score -ge 80 ] && echo "PASS" || echo "FAIL")"
    log "  Report saved to: $vuln_report"
    
    if [ $vuln_score -ge 80 ]; then
        success "Vulnerability assessment PASSED with score $vuln_score/100"
        return 0
    else
        error "Vulnerability assessment FAILED with score $vuln_score/100"
        return 1
    fi
}

main() {
    log "Starting Nephoran Intent Operator Vulnerability Assessment"
    log "Namespace: $NAMESPACE"
    log "Report directory: $REPORT_DIR"
    
    # Check dependencies
    if ! check_scanner_dependencies; then
        error "Required dependencies not available"
        return 1
    fi
    
    # Ensure namespace exists
    if ! kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
        error "Namespace $NAMESPACE does not exist"
        return 1
    fi
    
    # Run vulnerability assessment
    generate_vulnerability_report
    local result=$?
    
    log "Vulnerability assessment complete"
    return $result
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi