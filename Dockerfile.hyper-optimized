# =============================================================================
# Hyper-Optimized Production Dockerfile - 2025 Go 1.24+ Performance Edition
# =============================================================================
# Performance Goals:
# - Build time: < 20 seconds with warm cache, < 60 seconds cold
# - Image size: < 15MB compressed
# - Module download: < 5 seconds with optimized caching
# - Zero dependency conflicts with advanced resolution
# =============================================================================

# Build arguments with smart defaults
ARG SERVICE
ARG BUILDPLATFORM=linux/amd64
ARG TARGETPLATFORM=linux/amd64
ARG PREBUILT_BINARY=""
ARG GO_VERSION=1.24.1

# =============================================================================
# STAGE 1: Ultra-Fast Module Resolver (Dependency Pre-processing)
# =============================================================================
FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-alpine AS mod-resolver

# Performance environment for module operations
ENV GOMAXPROCS=32 \
    GOMEMLIMIT=16GiB \
    GOGC=50 \
    GODEBUG=gctrace=0,scavtrace=0 \
    GOEXPERIMENT=swisstable,pacer,nocoverageredesign,rangefunc,aliastypeparams

# Module proxy optimization
ENV GOPROXY=https://proxy.golang.org,direct \
    GOSUMDB=sum.golang.org \
    GOPRIVATE="" \
    GONOPROXY="" \
    GONOSUMDB=""

WORKDIR /mod

# Advanced module caching with integrity verification
COPY go.mod go.sum ./
RUN --mount=type=cache,target=/go/pkg/mod,sharing=locked \
    --mount=type=cache,target=/root/.cache/go-build,sharing=locked \
    set -eux; \
    echo "=== Starting Ultra-Fast Module Resolution ==="; \
    echo "Go version: $(go version)"; \
    echo "Available CPUs: $(nproc)"; \
    echo "Memory limit: ${GOMEMLIMIT}"; \
    echo "Module proxy: ${GOPROXY}"; \
    \
    # Pre-verify module integrity before download
    echo "Verifying module checksums..."; \
    go mod verify || { \
        echo "Module verification failed, cleaning and retrying..."; \
        go clean -modcache; \
        sleep 1; \
    }; \
    \
    # Ultra-fast parallel module download with aggressive timeout and retry
    echo "Starting parallel module download..."; \
    timeout 90s go mod download -x 2>&1 || { \
        echo "First download attempt timed out, retrying with longer timeout..."; \
        timeout 180s go mod download -x 2>&1; \
    }; \
    \
    # Verify all modules are properly downloaded
    echo "Verifying downloaded modules..."; \
    go list -m all > /tmp/modules.txt; \
    MODULE_COUNT=$(wc -l < /tmp/modules.txt); \
    echo "Successfully resolved ${MODULE_COUNT} modules"; \
    \
    # Pre-compile module dependencies for build cache warming
    echo "Pre-compiling standard library and common dependencies..."; \
    go install -a std 2>/dev/null || true; \
    \
    echo "=== Module resolution completed ===";

# =============================================================================
# STAGE 2: Hyper-Optimized Go Builder
# =============================================================================
FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-alpine AS builder

ARG SERVICE
ARG TARGETPLATFORM
ARG TARGETOS=linux
ARG TARGETARCH=amd64

# Extract target architecture for cross-compilation
ENV GOOS=${TARGETOS} \
    GOARCH=${TARGETARCH} \
    CGO_ENABLED=0

# Performance-optimized environment for Go 1.24+
ENV GOMAXPROCS=32 \
    GOMEMLIMIT=16GiB \
    GOGC=50 \
    GODEBUG=gctrace=0,scavtrace=0,inittrace=0 \
    GOEXPERIMENT=swisstable,pacer,nocoverageredesign,rangefunc,aliastypeparams \
    GOCACHE=/tmp/.cache/go-build \
    GOMODCACHE=/go/pkg/mod

# Advanced build configuration
ENV GOAMD64=v3 \
    GOFLAGS="-mod=readonly -buildvcs=false -trimpath" \
    BUILD_PARALLEL=32

WORKDIR /build

# Copy modules from resolver stage
COPY --from=mod-resolver /go/pkg/mod /go/pkg/mod
COPY go.mod go.sum ./

# Verify modules are available and warm the build cache
RUN --mount=type=cache,target=/tmp/.cache/go-build,sharing=locked \
    set -eux; \
    echo "=== Verifying Module Cache ==="; \
    go list -m all | head -5; \
    echo "Modules verified successfully"; \
    \
    # Pre-warm build cache with common packages
    echo "Pre-warming build cache..."; \
    go build -i std 2>/dev/null || true;

# Copy source code with .dockerignore optimization
COPY . .

# Hyper-optimized build with advanced Go 1.24+ features
RUN --mount=type=cache,target=/tmp/.cache/go-build,sharing=locked \
    --mount=type=cache,target=/go/pkg/mod,sharing=locked,readonly \
    set -ex; \
    \
    echo "=== Starting Hyper-Optimized Build ==="; \
    echo "Service: ${SERVICE}"; \
    echo "Platform: ${TARGETPLATFORM}"; \
    echo "Go version: $(go version)"; \
    echo "Available CPUs: $(nproc)"; \
    echo "Build parallelism: ${BUILD_PARALLEL}"; \
    \
    # Determine correct source path with validation
    case "${SERVICE}" in \
        "planner") \
            CMD_PATH="./planner/cmd/planner/main.go"; \
            ;; \
        "conductor-loop"|"intent-ingest"|"nephio-bridge"|"llm-processor"|"oran-adaptor"|"porch-publisher"|"a1-sim"|"e2-kpm-sim"|"fcaps-sim"|"o1-ves-sim") \
            CMD_PATH="./cmd/${SERVICE}/main.go"; \
            ;; \
        *) \
            echo "ERROR: Unknown service '${SERVICE}'"; \
            echo "Valid services: conductor-loop, intent-ingest, nephio-bridge, llm-processor, oran-adaptor, porch-publisher, planner, a1-sim, e2-kmp-sim, fcaps-sim, o1-ves-sim"; \
            exit 1; \
            ;; \
    esac; \
    \
    echo "Selected source path: ${CMD_PATH}"; \
    \
    # Verify source file exists
    if [ ! -f "${CMD_PATH}" ]; then \
        echo "ERROR: Source file not found: ${CMD_PATH}"; \
        echo "Available files in $(dirname ${CMD_PATH}):"; \
        ls -la "$(dirname ${CMD_PATH})" || true; \
        exit 1; \
    fi; \
    \
    echo "Source file verified: ${CMD_PATH}"; \
    \
    # Generate build metadata
    BUILD_DATE=$(date -Iseconds); \
    GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "container-build"); \
    VERSION=${VERSION:-"v1.0.0-${GIT_COMMIT}"}; \
    \
    echo "Build metadata:"; \
    echo "  Version: ${VERSION}"; \
    echo "  Commit: ${GIT_COMMIT}"; \
    echo "  Date: ${BUILD_DATE}"; \
    \
    # Hyper-optimized LDFLAGS for maximum performance
    LDFLAGS="-s -w -buildid='' \
             -X main.version=${VERSION} \
             -X main.buildDate=${BUILD_DATE} \
             -X main.gitCommit=${GIT_COMMIT} \
             -extldflags '-static'"; \
    \
    # Advanced build flags leveraging Go 1.24+ optimizations
    BUILD_FLAGS="-v \
                 -trimpath \
                 -buildvcs=false \
                 -buildmode=exe \
                 -compiler=gc \
                 -gccgoflags=-O3 \
                 -gcflags=all=-l=4,-B,-dwarf=false \
                 -asmflags=all=-trimpath=/build \
                 -tags=netgo,osusergo,static_build \
                 -installsuffix=netgo \
                 -p=${BUILD_PARALLEL} \
                 -a"; \
    \
    echo "Starting optimized build..."; \
    echo "LDFLAGS: ${LDFLAGS}"; \
    echo "BUILD_FLAGS: ${BUILD_FLAGS}"; \
    \
    # Execute hyper-optimized build with timing
    time go build \
        ${BUILD_FLAGS} \
        -ldflags="${LDFLAGS}" \
        -o /app \
        "${CMD_PATH}"; \
    \
    # Verify build success and analyze binary
    if [ -x "/app" ]; then \
        BINARY_SIZE=$(stat -c%s /app); \
        echo "Build successful!"; \
        echo "Binary size: ${BINARY_SIZE} bytes ($(numfmt --to=iec ${BINARY_SIZE}))"; \
        echo "Binary info: $(file /app)"; \
        \
        # Verify static linking
        if ldd /app 2>/dev/null; then \
            echo "WARNING: Binary has dynamic dependencies"; \
        else \
            echo "SUCCESS: Static binary confirmed"; \
        fi; \
        \
        # Architecture verification
        readelf -h /app | grep -E "(Class|Machine)" || echo "Binary architecture info unavailable"; \
        \
        # Optional UPX compression for large binaries
        if command -v upx >/dev/null 2>&1 && [ "${BINARY_SIZE}" -gt 10485760 ]; then \
            echo "Compressing large binary with UPX..."; \
            upx --best --lzma /app 2>/dev/null || { \
                echo "UPX compression failed or not beneficial"; \
            }; \
            NEW_SIZE=$(stat -c%s /app 2>/dev/null || echo ${BINARY_SIZE}); \
            echo "Post-compression size: ${NEW_SIZE} bytes"; \
        fi; \
    else \
        echo "ERROR: Build failed or binary not executable"; \
        exit 1; \
    fi; \
    \
    echo "=== Build completed successfully ===";

# =============================================================================
# STAGE 3: Optimized Runtime Dependencies
# =============================================================================
FROM alpine:3.22 AS runtime-deps

# Install runtime dependencies with verification
RUN set -eux; \
    echo "Installing runtime dependencies..."; \
    apk add --no-cache \
        ca-certificates \
        tzdata; \
    \
    # Verify critical files are present
    test -f /etc/ssl/certs/ca-certificates.crt || { echo "CA certificates missing"; exit 1; }; \
    test -f /usr/share/zoneinfo/UTC || { echo "Timezone data missing"; exit 1; }; \
    \
    # Set proper permissions
    chmod 644 /etc/ssl/certs/ca-certificates.crt; \
    chmod -R 755 /usr/share/zoneinfo; \
    \
    echo "Runtime dependencies installed successfully";

# =============================================================================
# STAGE 4: Final Distroless Production Image
# =============================================================================
FROM gcr.io/distroless/static-debian12:nonroot AS final

ARG SERVICE
ARG VERSION
ARG BUILD_DATE
ARG VCS_REF

# Copy runtime dependencies
COPY --from=runtime-deps /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=runtime-deps /usr/share/zoneinfo /usr/share/zoneinfo

# Copy optimized binary
COPY --from=builder /app /app

# Security: Use non-root user
USER nonroot:nonroot

# Metadata following OpenContainers specification
LABEL org.opencontainers.image.title="Nephoran ${SERVICE}" \
      org.opencontainers.image.description="Hyper-optimized ${SERVICE} service built with Go 1.24+" \
      org.opencontainers.image.version="${VERSION}" \
      org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.revision="${VCS_REF}" \
      org.opencontainers.image.source="https://github.com/thc1006/nephoran-intent-operator" \
      org.opencontainers.image.licenses="Apache-2.0" \
      org.opencontainers.image.vendor="Nephoran Project" \
      service.name="${SERVICE}" \
      service.type="go-binary" \
      build.optimization="hyper-optimized-2025" \
      build.go-version="1.24.1"

# Optimized health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app", "health"]

# Set timezone
ENV TZ=UTC

# Expose default port (service-specific)
EXPOSE 8080

# Entry point
ENTRYPOINT ["/app"]