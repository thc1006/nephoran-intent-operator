package automation

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"math"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var (

	// Metrics for automated remediation.

	remediationOperations = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "nephoran_remediation_operations_total",

		Help: "Total number of remediation operations performed",
	}, []string{"component", "strategy", "status"})

	remediationDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
		Name: "nephoran_remediation_duration_seconds",

		Help: "Duration of remediation operations",

		Buckets: prometheus.ExponentialBuckets(1, 2, 12),
	}, []string{"component", "strategy"})

	remediationSuccessRate = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "nephoran_remediation_success_rate",

		Help: "Success rate of remediation strategies",
	}, []string{"component", "strategy"})

	activeSessions = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "nephoran_active_remediations",

		Help: "Number of active remediation sessions",
	}, []string{"component"})
)

// AutomatedRemediation handles automated remediation of system issues.

type AutomatedRemediation struct {
	mu sync.RWMutex

	config *SelfHealingConfig

	k8sClient kubernetes.Interface

	ctrlClient client.Client

	logger *slog.Logger

	activeSessions map[string]*RemediationSession

	learningEngine *LearningEngine

	rollbackManager *RollbackManager

	strategies map[string]*RemediationStrategy

	running bool

	stopCh chan struct{}
}

// NewAutomatedRemediation creates a new automated remediation system.

func NewAutomatedRemediation(config *SelfHealingConfig, k8sClient kubernetes.Interface, ctrlClient client.Client, logger *slog.Logger) (*AutomatedRemediation, error) {
	if config == nil {
		return nil, fmt.Errorf("configuration is required")
	}

	ar := &AutomatedRemediation{
		config: config,

		logger: logger,

		k8sClient: k8sClient,

		ctrlClient: ctrlClient,

		activeSessions: make(map[string]*RemediationSession),

		strategies: make(map[string]*RemediationStrategy),

		learningEngine: NewLearningEngine(logger),

		rollbackManager: NewRollbackManager(logger),

		stopCh: make(chan struct{}),
	}

	// Initialize default remediation strategies.

	ar.initializeDefaultStrategies()

	return ar, nil
}

// Start starts the automated remediation system.

func (ar *AutomatedRemediation) Start(ctx context.Context) {
	ar.logger.Info("Starting automated remediation system")

	// Start remediation session monitor.

	go ar.runRemediationMonitor(ctx)

	// Start strategy optimization.

	go ar.runStrategyOptimization(ctx)

	ar.logger.Info("Automated remediation system started successfully")
}

// InitiateRemediation initiates remediation for a component.

func (ar *AutomatedRemediation) InitiateRemediation(ctx context.Context, component, reason string) error {
	ar.mu.Lock()

	defer ar.mu.Unlock()

	// Check if remediation is already active for this component.

	if session, exists := ar.activeSessions[component]; exists {
		if session.Status == "RUNNING" {
			return fmt.Errorf("remediation already active for component %s", component)
		}
	}

	// Check concurrent remediation limit.

	if len(ar.activeSessions) >= ar.config.MaxConcurrentRemediations {
		return fmt.Errorf("maximum concurrent remediations reached (%d)", ar.config.MaxConcurrentRemediations)
	}

	ar.logger.Info("Initiating remediation", "component", component, "reason", reason)

	// Select appropriate strategy.

	strategy := ar.selectBestStrategy(component, reason)

	if strategy == nil {
		return fmt.Errorf("no suitable remediation strategy found for component %s", component)
	}

	// Create remediation session.

	session := &RemediationSession{
		ID: uuid.New().String(),

		Component: component,

		Strategy: strategy.Name,

		Status: "PENDING",

		StartTime: time.Now(),

		Actions: make([]*RemediationAction, 0),

		Results: json.RawMessage(`{}`),
	}

	// Create backup if required.

	if ar.config.BackupBeforeRemediation {

		backupID, err := ar.createBackup(ctx, component)

		if err != nil {

			ar.logger.Error("Failed to create backup before remediation", "component", component, "error", err)

			if ar.config.RollbackOnFailure {
				return fmt.Errorf("backup creation failed: %w", err)
			}

		} else {
			session.BackupID = backupID
		}

	}

	// Create rollback plan.

	if ar.config.RollbackOnFailure {

		rollbackPlan := ar.rollbackManager.CreateRollbackPlan(session)

		session.RollbackPlan = rollbackPlan

	}

	ar.activeSessions[component] = session

	activeSessions.WithLabelValues(component).Inc()

	// Start remediation in background.

	go ar.executeRemediation(ctx, session, strategy)

	return nil
}

// InitiatePreventiveRemediation initiates preventive remediation based on predictions.

func (ar *AutomatedRemediation) InitiatePreventiveRemediation(ctx context.Context, component string, failureProbability float64) error {
	ar.logger.Info("Initiating preventive remediation",

		"component", component,

		"failure_probability", failureProbability)

	// Select preventive strategy based on probability.

	reason := fmt.Sprintf("preventive_action_probability_%.2f", failureProbability)

	// Use lighter remediation strategies for preventive actions.

	return ar.InitiateRemediation(ctx, component, reason)
}

// executeRemediation executes a remediation session.

func (ar *AutomatedRemediation) executeRemediation(ctx context.Context, session *RemediationSession, strategy *RemediationStrategy) {
	start := time.Now()

	defer func() {
		remediationDuration.WithLabelValues(session.Component, strategy.Name).Observe(time.Since(start).Seconds())
	}()

	ar.logger.Info("Executing remediation", "session", session.ID, "component", session.Component, "strategy", strategy.Name)

	session.Status = "RUNNING"

	success := true

	// Execute actions in sequence.

	for i, actionTemplate := range strategy.Actions {

		action := &RemediationAction{
			Type: actionTemplate.Type,

			Target: session.Component,

			Parameters: actionTemplate.Parameters,

			Status: "PENDING",

			StartTime: time.Now(),
		}

		session.Actions = append(session.Actions, action)

		// Execute action with retry policy.

		err := ar.executeActionWithRetry(ctx, action, actionTemplate.RetryPolicy)

		if err != nil {

			action.Status = "FAILED"

			action.Error = err.Error()

			success = false

			ar.logger.Error("Remediation action failed",

				"session", session.ID,

				"action", i+1,

				"type", action.Type,

				"error", err)

			// Check if we should continue or abort.

			if ar.shouldAbortRemediation(session, strategy) {
				break
			}

		} else {

			action.Status = "COMPLETED"

			endTime := time.Now()

			action.EndTime = &endTime

		}

	}

	// Update session status.

	endTime := time.Now()

	session.EndTime = &endTime

	if success {

		session.Status = "COMPLETED"

		strategy.Success++

		remediationOperations.WithLabelValues(session.Component, strategy.Name, "success").Inc()

		ar.logger.Info("Remediation completed successfully", "session", session.ID)

	} else {

		session.Status = "FAILED"

		remediationOperations.WithLabelValues(session.Component, strategy.Name, "failed").Inc()

		ar.logger.Error("Remediation failed", "session", session.ID)

		// Attempt rollback if configured.

		if ar.config.RollbackOnFailure && session.RollbackPlan != nil {
			ar.performRollback(ctx, session)
		}

	}

	strategy.Total++

	if strategy.Total > 0 {

		strategy.SuccessRate = float64(strategy.Success) / float64(strategy.Total)

		remediationSuccessRate.WithLabelValues(session.Component, strategy.Name).Set(strategy.SuccessRate)

	}

	// Learn from this remediation.

	if ar.config.LearningEnabled {
		ar.learningEngine.RecordRemediation(session, strategy, success)
	}

	// Clean up.

	ar.mu.Lock()

	delete(ar.activeSessions, session.Component)

	activeSessions.WithLabelValues(session.Component).Dec()

	ar.mu.Unlock()
}

// executeActionWithRetry executes an action with retry policy.

func (ar *AutomatedRemediation) executeActionWithRetry(ctx context.Context, action *RemediationAction, retryPolicy *RetryPolicy) error {
	var lastError error

	attempts := 1

	if retryPolicy != nil {
		attempts = retryPolicy.MaxAttempts
	}

	delay := 1 * time.Second

	if retryPolicy != nil && retryPolicy.InitialDelay > 0 {
		delay = retryPolicy.InitialDelay
	}

	for attempt := 1; attempt <= attempts; attempt++ {

		err := ar.executeAction(ctx, action)

		if err == nil {
			return nil
		}

		lastError = err

		ar.logger.Warn("Remediation action attempt failed",

			"attempt", attempt,

			"max_attempts", attempts,

			"error", err)

		if attempt < attempts {

			// Wait before retry.

			select {

			case <-ctx.Done():

				return ctx.Err()

			case <-time.After(delay):

			}

			// Increase delay for next attempt.

			if retryPolicy != nil {

				delay = time.Duration(float64(delay) * retryPolicy.BackoffMultiplier)

				if retryPolicy.MaxDelay > 0 && delay > retryPolicy.MaxDelay {
					delay = retryPolicy.MaxDelay
				}

			}

		}

	}

	return fmt.Errorf("action failed after %d attempts: %w", attempts, lastError)
}

// unmarshallParameters converts json.RawMessage to map[string]interface{}.
func (ar *AutomatedRemediation) unmarshallParameters(rawParams json.RawMessage) (map[string]interface{}, error) {
	if len(rawParams) == 0 {
		return map[string]interface{}{}, nil
	}

	var params map[string]interface{}
	if err := json.Unmarshal(rawParams, &params); err != nil {
		return nil, fmt.Errorf("failed to unmarshal parameters: %w", err)
	}
	return params, nil
}

// executeAction executes a single remediation action.

func (ar *AutomatedRemediation) executeAction(ctx context.Context, action *RemediationAction) error {
	ar.logger.Debug("Executing remediation action", "type", action.Type, "target", action.Target)

	switch action.Type {

	case "RESTART":

		return ar.restartComponent(ctx, action.Target)

	case "SCALE":
		params, err := ar.unmarshallParameters(action.Parameters)
		if err != nil {
			return fmt.Errorf("failed to unmarshal scale parameters: %w", err)
		}
		return ar.scaleComponent(ctx, action.Target, params)

	case "REDEPLOY":

		return ar.redeployComponent(ctx, action.Target)

	case "UPDATE_CONFIG":
		params, err := ar.unmarshallParameters(action.Parameters)
		if err != nil {
			return fmt.Errorf("failed to unmarshal config parameters: %w", err)
		}
		return ar.updateConfiguration(ctx, action.Target, params)

	case "CLEAR_CACHE":

		return ar.clearCache(ctx, action.Target)

	case "RESTART_DEPENDENCIES":

		return ar.restartDependencies(ctx, action.Target)

	case "CUSTOM_SCRIPT":
		params, err := ar.unmarshallParameters(action.Parameters)
		if err != nil {
			return fmt.Errorf("failed to unmarshal script parameters: %w", err)
		}
		return ar.executeCustomScript(ctx, action.Target, params)

	default:

		return fmt.Errorf("unknown action type: %s", action.Type)

	}
}

// Remediation action implementations.

func (ar *AutomatedRemediation) restartComponent(ctx context.Context, componentName string) error {
	ar.logger.Info("Restarting component", "component", componentName)

	// Get deployment.

	deployment, err := ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Get(ctx, componentName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get deployment: %w", err)
	}

	// Trigger rolling restart by updating annotation.

	if deployment.Spec.Template.Annotations == nil {
		deployment.Spec.Template.Annotations = make(map[string]string)
	}

	deployment.Spec.Template.Annotations["nephoran.com/restarted-at"] = time.Now().Format(time.RFC3339)

	_, err = ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Update(ctx, deployment, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to restart deployment: %w", err)
	}

	// Wait for rollout to complete.

	return ar.waitForDeploymentReady(ctx, componentName, 5*time.Minute)
}

func (ar *AutomatedRemediation) scaleComponent(ctx context.Context, componentName string, parameters map[string]interface{}) error {
	replicas, ok := parameters["replicas"].(float64)

	if !ok {
		return fmt.Errorf("invalid replicas parameter")
	}

	ar.logger.Info("Scaling component", "component", componentName, "replicas", replicas)

	// Get current deployment.

	deployment, err := ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Get(ctx, componentName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get deployment: %w", err)
	}

	// Update replica count.
	// Security fix (G115): Safe float64 to int32 conversion with bounds checking
	if replicas < 0 || replicas > float64(math.MaxInt32) {
		return fmt.Errorf("invalid replica count %.0f: must be between 0 and %d", replicas, int64(math.MaxInt32))
	}
	// Check if replicas is a whole number
	if replicas != float64(int64(replicas)) {
		return fmt.Errorf("replica count must be a whole number, got %.2f", replicas)
	}
	replicaCount := int32(replicas)

	deployment.Spec.Replicas = &replicaCount

	_, err = ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Update(ctx, deployment, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to scale deployment: %w", err)
	}

	// Wait for scaling to complete.

	return ar.waitForDeploymentReady(ctx, componentName, 3*time.Minute)
}

func (ar *AutomatedRemediation) redeployComponent(ctx context.Context, componentName string) error {
	ar.logger.Info("Redeploying component", "component", componentName)

	// Get current deployment.

	deployment, err := ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Get(ctx, componentName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get deployment: %w", err)
	}

	// Delete deployment.

	err = ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Delete(ctx, componentName, metav1.DeleteOptions{})
	if err != nil {
		return fmt.Errorf("failed to delete deployment: %w", err)
	}

	// Wait for deletion.

	time.Sleep(10 * time.Second)

	// Recreate deployment.

	deployment.ResourceVersion = ""

	deployment.UID = ""

	_, err = ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
		Create(ctx, deployment, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to recreate deployment: %w", err)
	}

	return ar.waitForDeploymentReady(ctx, componentName, 5*time.Minute)
}

func (ar *AutomatedRemediation) updateConfiguration(ctx context.Context, componentName string, parameters map[string]interface{}) error {
	ar.logger.Info("Updating configuration", "component", componentName)

	configMapName := fmt.Sprintf("%s-config", componentName)

	configMap, err := ar.k8sClient.CoreV1().ConfigMaps(ar.config.ComponentConfigs[componentName].Name).
		Get(ctx, configMapName, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get configmap: %w", err)
	}

	// Update configuration data.

	for key, value := range parameters {
		if strValue, ok := value.(string); ok {
			configMap.Data[key] = strValue
		}
	}

	_, err = ar.k8sClient.CoreV1().ConfigMaps(ar.config.ComponentConfigs[componentName].Name).
		Update(ctx, configMap, metav1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("failed to update configmap: %w", err)
	}

	// Restart component to pick up new configuration.

	return ar.restartComponent(ctx, componentName)
}

func (ar *AutomatedRemediation) clearCache(ctx context.Context, componentName string) error {
	ar.logger.Info("Clearing cache", "component", componentName)

	// Implementation depends on cache type.

	// For Redis cache.

	if componentName == "rag-api" {
		// Execute cache clear command.

		return ar.executeCustomScript(ctx, componentName, map[string]interface{}{})
	}

	return nil
}

func (ar *AutomatedRemediation) restartDependencies(ctx context.Context, componentName string) error {
	ar.logger.Info("Restarting dependencies", "component", componentName)

	config := ar.config.ComponentConfigs[componentName]

	if config == nil {
		return fmt.Errorf("component configuration not found")
	}

	// Restart each dependency.

	for _, dependency := range config.DependsOn {

		err := ar.restartComponent(ctx, dependency)
		if err != nil {
			ar.logger.Error("Failed to restart dependency", "dependency", dependency, "error", err)

			// Continue with other dependencies.
		}

	}

	return nil
}

func (ar *AutomatedRemediation) executeCustomScript(ctx context.Context, componentName string, parameters map[string]interface{}) error {
	script, ok := parameters["script"].(string)

	if !ok {
		return fmt.Errorf("invalid script parameter")
	}

	ar.logger.Info("Executing custom script", "component", componentName, "script", script)

	// Create a job to execute the script.

	job := &batchv1.Job{
		ObjectMeta: metav1.ObjectMeta{
			Name: fmt.Sprintf("remediation-script-%s-%d", componentName, time.Now().Unix()),

			Namespace: ar.config.ComponentConfigs[componentName].Name,
		},

		Spec: batchv1.JobSpec{
			Template: corev1.PodTemplateSpec{
				Spec: corev1.PodSpec{
					RestartPolicy: corev1.RestartPolicyNever,

					Containers: []corev1.Container{
						{
							Name: "script-executor",

							Image: "kubectl:latest",

							Command: []string{"/bin/sh", "-c", script},
						},
					},
				},
			},
		},
	}

	_, err := ar.k8sClient.BatchV1().Jobs(ar.config.ComponentConfigs[componentName].Name).
		Create(ctx, job, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create job: %w", err)
	}

	// Wait for job completion (simplified).

	time.Sleep(30 * time.Second)

	return nil
}

// Helper methods.

func (ar *AutomatedRemediation) waitForDeploymentReady(ctx context.Context, componentName string, timeout time.Duration) error {
	deadline := time.Now().Add(timeout)

	for time.Now().Before(deadline) {

		deployment, err := ar.k8sClient.AppsV1().Deployments(ar.config.ComponentConfigs[componentName].Name).
			Get(ctx, componentName, metav1.GetOptions{})
		if err != nil {
			return err
		}

		if deployment.Status.ReadyReplicas == *deployment.Spec.Replicas {
			return nil
		}

		select {

		case <-ctx.Done():

			return ctx.Err()

		case <-time.After(5 * time.Second):

		}

	}

	return fmt.Errorf("timeout waiting for deployment to be ready")
}

func (ar *AutomatedRemediation) selectBestStrategy(component, reason string) *RemediationStrategy {
	// Select strategy based on reason and historical success rates.

	var bestStrategy *RemediationStrategy

	var bestScore float64

	for _, strategy := range ar.strategies {

		score := ar.calculateStrategyScore(strategy, component, reason)

		if score > bestScore {

			bestScore = score

			bestStrategy = strategy

		}

	}

	return bestStrategy
}

// findBestStrategy is an alias for selectBestStrategy for test compatibility.

func (ar *AutomatedRemediation) findBestStrategy(component, reason string) *RemediationStrategy {
	return ar.selectBestStrategy(component, reason)
}

func (ar *AutomatedRemediation) calculateStrategyScore(strategy *RemediationStrategy, component, reason string) float64 {
	// Base score from success rate.

	score := strategy.SuccessRate

	// Adjust based on strategy priority.

	score += float64(strategy.Priority) * 0.1

	// Adjust based on reason matching.

	if ar.reasonMatchesStrategy(reason, strategy) {
		score += 0.2
	}

	return score
}

func (ar *AutomatedRemediation) reasonMatchesStrategy(reason string, strategy *RemediationStrategy) bool {
	// Simple pattern matching for demonstration.

	// In production, would use more sophisticated matching.

	switch reason {

	case "UNHEALTHY", "CRITICAL":

		return strategy.Name == "RestartStrategy" || strategy.Name == "RedeployStrategy"

	case "HIGH_CPU", "HIGH_MEMORY":

		return strategy.Name == "ScaleUpStrategy" || strategy.Name == "RestartStrategy"

	case "HIGH_ERROR_RATE":

		return strategy.Name == "RestartStrategy" || strategy.Name == "ClearCacheStrategy"

	default:

		return strategy.Name == "RestartStrategy" // Default strategy

	}
}

func (ar *AutomatedRemediation) shouldAbortRemediation(session *RemediationSession, strategy *RemediationStrategy) bool {
	// Count failed actions.

	failedActions := 0

	for _, action := range session.Actions {
		if action.Status == "FAILED" {
			failedActions++
		}
	}

	// Abort if more than half the actions failed.

	return float64(failedActions)/float64(len(session.Actions)) > 0.5
}

func (ar *AutomatedRemediation) createBackup(ctx context.Context, component string) (string, error) {
	// Create a backup before remediation.

	backupID := fmt.Sprintf("pre-remediation-%s-%d", component, time.Now().Unix())

	// Implementation would create actual backup.

	ar.logger.Info("Creating backup", "component", component, "backup_id", backupID)

	return backupID, nil
}

func (ar *AutomatedRemediation) performRollback(ctx context.Context, session *RemediationSession) {
	ar.logger.Info("Performing rollback", "session", session.ID, "component", session.Component)

	if session.RollbackPlan == nil {

		ar.logger.Error("No rollback plan available", "session", session.ID)

		return

	}

	err := ar.rollbackManager.ExecuteRollback(session.RollbackPlan.ID)

	if err != nil {
		ar.logger.Error("Rollback failed", "session", session.ID, "error", err)
	} else {
		ar.logger.Info("Rollback completed successfully", "session", session.ID)
	}
}

// GetActiveRemediations returns active remediation sessions.

func (ar *AutomatedRemediation) GetActiveRemediations() map[string]*RemediationSession {
	ar.mu.RLock()

	defer ar.mu.RUnlock()

	sessions := make(map[string]*RemediationSession)

	for k, v := range ar.activeSessions {
		sessions[k] = v
	}

	return sessions
}

// Monitoring and optimization methods.

func (ar *AutomatedRemediation) runRemediationMonitor(ctx context.Context) {
	ticker := time.NewTicker(1 * time.Minute)

	defer ticker.Stop()

	for {
		select {

		case <-ctx.Done():

			return

		case <-ticker.C:

			ar.monitorActiveSessions(ctx)

		}
	}
}

func (ar *AutomatedRemediation) runStrategyOptimization(ctx context.Context) {
	ticker := time.NewTicker(1 * time.Hour)

	defer ticker.Stop()

	for {
		select {

		case <-ctx.Done():

			return

		case <-ticker.C:

			ar.optimizeStrategies()

		}
	}
}

func (ar *AutomatedRemediation) monitorActiveSessions(ctx context.Context) {
	ar.mu.RLock()

	defer ar.mu.RUnlock()

	for component, session := range ar.activeSessions {
		// Check for stuck sessions.

		if session.Status == "RUNNING" && time.Since(session.StartTime) > 30*time.Minute {
			ar.logger.Warn("Remediation session appears stuck",

				"session", session.ID,

				"component", component,

				"duration", time.Since(session.StartTime))
		}
	}
}

func (ar *AutomatedRemediation) optimizeStrategies() {
	ar.logger.Info("Optimizing remediation strategies")

	// Update strategy priorities based on success rates.

	for _, strategy := range ar.strategies {
		if strategy.Total > 10 {
			// Adjust priority based on success rate.

			if strategy.SuccessRate > 0.8 {
				strategy.Priority = minInt(strategy.Priority+1, 10)
			} else if strategy.SuccessRate < 0.5 {
				strategy.Priority = max(strategy.Priority-1, 1)
			}
		}
	}
}

func minInt(a, b int) int {
	if a < b {
		return a
	}

	return b
}

func (ar *AutomatedRemediation) initializeDefaultStrategies() {
	// Restart strategy.

	ar.strategies["RestartStrategy"] = &RemediationStrategy{
		Name: "RestartStrategy",

		Conditions: []*RemediationCondition{
			{Metric: "health_score", Operator: "LT", Threshold: 0.5, Duration: 2 * time.Minute},
		},

		Actions: []*RemediationActionTemplate{
			{
				Type: "RESTART",

				Template: "restart_deployment",

				Timeout: 5 * time.Minute,

				RetryPolicy: &RetryPolicy{
					MaxAttempts: 3,

					InitialDelay: 10 * time.Second,

					MaxDelay: 1 * time.Minute,

					BackoffMultiplier: 2.0,
				},
			},
		},

		Priority: 5,
	}

	// Scale up strategy.

	ar.strategies["ScaleUpStrategy"] = &RemediationStrategy{
		Name: "ScaleUpStrategy",

		Conditions: []*RemediationCondition{
			{Metric: "cpu_usage", Operator: "GT", Threshold: 0.8, Duration: 5 * time.Minute},
		},

		Actions: []*RemediationActionTemplate{
			{
				Type: "SCALE",

				Template: "scale_deployment",

				Parameters: json.RawMessage(`{}`),

				Timeout: 3 * time.Minute,
			},
		},

		Priority: 7,
	}

	// Clear cache strategy.

	ar.strategies["ClearCacheStrategy"] = &RemediationStrategy{
		Name: "ClearCacheStrategy",

		Conditions: []*RemediationCondition{
			{Metric: "cache_hit_rate", Operator: "LT", Threshold: 0.5, Duration: 10 * time.Minute},
		},

		Actions: []*RemediationActionTemplate{
			{
				Type: "CLEAR_CACHE",

				Timeout: 1 * time.Minute,
			},
		},

		Priority: 3,
	}
}

// Supporting types and components - implementations moved to specialized files.
