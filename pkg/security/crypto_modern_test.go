package security

import (
	"bytes"
	"crypto/rand"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCryptoModern_NewCryptoModern(t *testing.T) {
	t.Run("creates crypto modern with default entropy pool", func(t *testing.T) {
		crypto := NewCryptoModern()

		assert.NotNil(t, crypto)
		assert.NotNil(t, crypto.entropyPool)
		assert.NotNil(t, crypto.keyDerivation)
		assert.NotNil(t, crypto.encryptionCache)
	})
}

func TestCryptoModern_GenerateRandomBytes(t *testing.T) {
	crypto := NewCryptoModern()

	tests := []struct {
		name   string
		length int
	}{
		{"16 bytes", 16},
		{"32 bytes", 32},
		{"64 bytes", 64},
		{"128 bytes", 128},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			bytes1, err := crypto.GenerateRandomBytes(tt.length)
			require.NoError(t, err)
			assert.Len(t, bytes1, tt.length)

			// Generate another set to ensure randomness
			bytes2, err := crypto.GenerateRandomBytes(tt.length)
			require.NoError(t, err)
			assert.NotEqual(t, bytes1, bytes2, "Generated bytes should be random")
		})
	}

	t.Run("zero length returns empty slice", func(t *testing.T) {
		result, err := crypto.GenerateRandomBytes(0)
		require.NoError(t, err)
		assert.Empty(t, result)
	})

	t.Run("negative length returns error", func(t *testing.T) {
		_, err := crypto.GenerateRandomBytes(-1)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid length")
	})
}

func TestCryptoModern_DeriveKey(t *testing.T) {
	crypto := NewCryptoModern()
	password := []byte("test-password-123")
	salt := make([]byte, 32)
	rand.Read(salt)

	tests := []struct {
		name    string
		method  string
		keySize int
		wantErr bool
		errMsg  string
	}{
		{"PBKDF2 32 bytes", "pbkdf2", 32, false, ""},
		{"PBKDF2 64 bytes", "pbkdf2", 64, false, ""},
		{"Argon2 32 bytes", "argon2", 32, false, ""},
		{"Argon2 64 bytes", "argon2", 64, false, ""},
		{"Scrypt 32 bytes", "scrypt", 32, false, ""},
		{"Invalid method", "invalid", 32, true, "unsupported key derivation method"},
		{"Zero key size", "pbkdf2", 0, true, "invalid key size"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			key, err := crypto.DeriveKey(password, salt, tt.method, tt.keySize)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				return
			}

			require.NoError(t, err)
			assert.Len(t, key, tt.keySize)

			// Derive again with same params should yield same key
			key2, err := crypto.DeriveKey(password, salt, tt.method, tt.keySize)
			require.NoError(t, err)
			assert.Equal(t, key, key2)
		})
	}
}

func TestCryptoModern_EncryptDecrypt(t *testing.T) {
	crypto := NewCryptoModern()

	tests := []struct {
		name      string
		algorithm string
		data      []byte
		wantErr   bool
	}{
		{
			name:      "AES-GCM small data",
			algorithm: "aes-gcm",
			data:      []byte("Hello, World!"),
			wantErr:   false,
		},
		{
			name:      "AES-GCM large data",
			algorithm: "aes-gcm",
			data:      bytes.Repeat([]byte("A"), 10000),
			wantErr:   false,
		},
		{
			name:      "ChaCha20-Poly1305",
			algorithm: "chacha20-poly1305",
			data:      []byte("Secret message"),
			wantErr:   false,
		},
		{
			name:      "Empty data",
			algorithm: "aes-gcm",
			data:      []byte{},
			wantErr:   false,
		},
		{
			name:      "Invalid algorithm",
			algorithm: "invalid-algo",
			data:      []byte("test"),
			wantErr:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Generate key
			key, err := crypto.GenerateRandomBytes(32)
			require.NoError(t, err)

			// Encrypt
			encrypted, err := crypto.Encrypt(tt.data, key, tt.algorithm)
			if tt.wantErr {
				assert.Error(t, err)
				return
			}
			require.NoError(t, err)

			// Encrypted data should be different from original
			if len(tt.data) > 0 {
				assert.NotEqual(t, tt.data, encrypted)
			}

			// Decrypt
			decrypted, err := crypto.Decrypt(encrypted, key, tt.algorithm)
			require.NoError(t, err)
			assert.Equal(t, tt.data, decrypted)
		})
	}
}

func TestCryptoModern_Hash(t *testing.T) {
	crypto := NewCryptoModern()
	testData := []byte("test data for hashing")

	tests := []struct {
		name       string
		algorithm  string
		expectSize int
		wantErr    bool
	}{
		{"SHA-256", "sha256", 32, false},
		{"SHA-512", "sha512", 64, false},
		{"SHA3-256", "sha3-256", 32, false},
		{"SHA3-512", "sha3-512", 64, false},
		{"BLAKE2b", "blake2b", 64, false},
		{"Invalid algorithm", "invalid", 0, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hash, err := crypto.Hash(testData, tt.algorithm)

			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Len(t, hash, tt.expectSize)

			// Hash should be deterministic
			hash2, err := crypto.Hash(testData, tt.algorithm)
			require.NoError(t, err)
			assert.Equal(t, hash, hash2)
		})
	}

	t.Run("empty data hashing", func(t *testing.T) {
		hash, err := crypto.Hash([]byte{}, "sha256")
		require.NoError(t, err)
		assert.Len(t, hash, 32)
	})
}

func TestCryptoModern_GenerateKeyPair(t *testing.T) {
	crypto := NewCryptoModern()

	tests := []struct {
		name      string
		algorithm string
		wantErr   bool
	}{
		{"Ed25519", "ed25519", false},
		{"ECDSA P-256", "ecdsa-p256", false},
		{"ECDSA P-384", "ecdsa-p384", false},
		{"RSA 2048", "rsa-2048", false},
		{"RSA 3072", "rsa-3072", false},
		{"Invalid algorithm", "invalid", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			privKey, pubKey, err := crypto.GenerateKeyPair(tt.algorithm)

			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.NotNil(t, privKey)
			assert.NotNil(t, pubKey)
		})
	}
}

func TestCryptoModern_SignVerify(t *testing.T) {
	crypto := NewCryptoModern()
	message := []byte("message to sign")

	tests := []struct {
		name      string
		algorithm string
		wantErr   bool
	}{
		{"Ed25519", "ed25519", false},
		{"ECDSA P-256", "ecdsa-p256", false},
		{"PSS RSA", "rsa-pss", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Generate key pair
			privKey, pubKey, err := crypto.GenerateKeyPair(tt.algorithm)
			require.NoError(t, err)

			// Sign message
			signature, err := crypto.Sign(message, privKey, tt.algorithm)
			require.NoError(t, err)
			assert.NotEmpty(t, signature)

			// Verify signature
			valid, err := crypto.Verify(message, signature, pubKey, tt.algorithm)
			require.NoError(t, err)
			assert.True(t, valid)

			// Verify with wrong message should fail
			wrongMsg := []byte("wrong message")
			valid, err = crypto.Verify(wrongMsg, signature, pubKey, tt.algorithm)
			require.NoError(t, err)
			assert.False(t, valid)
		})
	}
}

func TestCryptoModern_SecureCompare(t *testing.T) {
	crypto := NewCryptoModern()

	tests := []struct {
		name     string
		a, b     []byte
		expected bool
	}{
		{"equal slices", []byte("hello"), []byte("hello"), true},
		{"different slices", []byte("hello"), []byte("world"), false},
		{"different lengths", []byte("hello"), []byte("hi"), false},
		{"empty slices", []byte{}, []byte{}, true},
		{"one empty", []byte("test"), []byte{}, false},
		{"nil slices", nil, nil, true},
		{"one nil", []byte("test"), nil, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := crypto.SecureCompare(tt.a, tt.b)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestCryptoModern_Performance(t *testing.T) {
	crypto := NewCryptoModern()

	t.Run("key derivation performance", func(t *testing.T) {
		password := []byte("test-password")
		salt := make([]byte, 32)
		rand.Read(salt)

		start := time.Now()
		_, err := crypto.DeriveKey(password, salt, "pbkdf2", 32)
		duration := time.Since(start)

		require.NoError(t, err)
		assert.Less(t, duration, time.Second, "Key derivation should complete within 1 second")
	})

	t.Run("encryption performance", func(t *testing.T) {
		data := bytes.Repeat([]byte("A"), 1024*1024) // 1MB
		key, _ := crypto.GenerateRandomBytes(32)

		start := time.Now()
		encrypted, err := crypto.Encrypt(data, key, "aes-gcm")
		duration := time.Since(start)

		require.NoError(t, err)
		assert.NotEmpty(t, encrypted)
		assert.Less(t, duration, 100*time.Millisecond, "1MB encryption should be fast")
	})
}

func BenchmarkCryptoModern_Encrypt(b *testing.B) {
	crypto := NewCryptoModern()
	data := bytes.Repeat([]byte("A"), 1024) // 1KB
	key, _ := crypto.GenerateRandomBytes(32)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := crypto.Encrypt(data, key, "aes-gcm")
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCryptoModern_Decrypt(b *testing.B) {
	crypto := NewCryptoModern()
	data := bytes.Repeat([]byte("A"), 1024) // 1KB
	key, _ := crypto.GenerateRandomBytes(32)
	encrypted, _ := crypto.Encrypt(data, key, "aes-gcm")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := crypto.Decrypt(encrypted, key, "aes-gcm")
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCryptoModern_Hash(b *testing.B) {
	crypto := NewCryptoModern()
	data := bytes.Repeat([]byte("A"), 1024) // 1KB

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := crypto.Hash(data, "sha256")
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCryptoModern_DeriveKey(b *testing.B) {
	crypto := NewCryptoModern()
	password := []byte("test-password")
	salt := make([]byte, 32)
	rand.Read(salt)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := crypto.DeriveKey(password, salt, "pbkdf2", 32)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// Fuzz test for encryption/decryption
func FuzzCryptoModern_EncryptDecrypt(f *testing.F) {
	crypto := NewCryptoModern()

	// Add seed corpus
	f.Add([]byte("hello world"))
	f.Add([]byte(""))
	f.Add(bytes.Repeat([]byte("A"), 1000))

	f.Fuzz(func(t *testing.T, data []byte) {
		key, err := crypto.GenerateRandomBytes(32)
		if err != nil {
			t.Skip("Failed to generate key")
		}

		encrypted, err := crypto.Encrypt(data, key, "aes-gcm")
		if err != nil {
			t.Errorf("Encryption failed: %v", err)
			return
		}

		decrypted, err := crypto.Decrypt(encrypted, key, "aes-gcm")
		if err != nil {
			t.Errorf("Decryption failed: %v", err)
			return
		}

		if !bytes.Equal(data, decrypted) {
			t.Error("Decrypted data doesn't match original")
		}
	})
}
