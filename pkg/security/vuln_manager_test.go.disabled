package security

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"log/slog"
	"os"
)

// MockSecurityScanner is a mock implementation for testing
type MockSecurityScanner struct {
	mock.Mock
}

func (m *MockSecurityScanner) ScanContainer(ctx context.Context, image string) (*ScanResult, error) {
	args := m.Called(ctx, image)
	return args.Get(0).(*ScanResult), args.Error(1)
}

func (m *MockSecurityScanner) ScanDependencies(ctx context.Context, path string) (*ScanResult, error) {
	args := m.Called(ctx, path)
	return args.Get(0).(*ScanResult), args.Error(1)
}

// MockVulnDatabase is a mock vulnerability database
type MockVulnDatabase struct {
	mock.Mock
}

func (m *MockVulnDatabase) GetVulnerability(cveID string) (*Vulnerability, error) {
	args := m.Called(cveID)
	return args.Get(0).(*Vulnerability), args.Error(1)
}

func (m *MockVulnDatabase) UpdateDatabase(ctx context.Context) error {
	args := m.Called(ctx)
	return args.Error(0)
}

// MockRemediationEngine is a mock remediation engine
type MockRemediationEngine struct {
	mock.Mock
}

func (m *MockRemediationEngine) RemediateVulnerability(ctx context.Context, vuln *Vulnerability) (*RemediationResult, error) {
	args := m.Called(ctx, vuln)
	return args.Get(0).(*RemediationResult), args.Error(1)
}

func TestVulnerabilityManager_New(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))

	t.Run("creates vulnerability manager with valid config", func(t *testing.T) {
		config := &VulnManagerConfig{
			EnableCVEScanning:     true,
			EnableDependencyCheck: true,
			ScanInterval:          1 * time.Hour,
			MaxConcurrentScans:    5,
			AutoRemediation:       true,
			SeverityThreshold:     "HIGH",
		}

		manager, err := NewVulnerabilityManager(config, logger)
		require.NoError(t, err)
		assert.NotNil(t, manager)
		assert.Equal(t, config, manager.config)
		assert.Equal(t, logger, manager.logger)
	})

	t.Run("returns error with nil config", func(t *testing.T) {
		_, err := NewVulnerabilityManager(nil, logger)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "config cannot be nil")
	})

	t.Run("returns error with nil logger", func(t *testing.T) {
		config := &VulnManagerConfig{
			EnableCVEScanning: true,
		}

		_, err := NewVulnerabilityManager(config, nil)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "logger cannot be nil")
	})

	t.Run("sets default values for missing config", func(t *testing.T) {
		config := &VulnManagerConfig{
			EnableCVEScanning: true,
		}

		manager, err := NewVulnerabilityManager(config, logger)
		require.NoError(t, err)

		// Should set reasonable defaults
		assert.Equal(t, 24*time.Hour, manager.config.ScanInterval)
		assert.Equal(t, 3, manager.config.MaxConcurrentScans)
		assert.Equal(t, "MEDIUM", manager.config.SeverityThreshold)
	})
}

func TestVulnerabilityManager_ScanContainer(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		EnableCVEScanning:  true,
		SeverityThreshold:  "HIGH",
		MaxConcurrentScans: 1,
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(t, err)

	// Mock scanner
	mockScanner := &MockSecurityScanner{}
	manager.scanner = mockScanner

	t.Run("scans container successfully", func(t *testing.T) {
		ctx := context.Background()
		image := "nginx:latest"

		expectedResult := &ScanResult{
			Target: image,
			Vulnerabilities: []*Vulnerability{
				{
					ID:               "CVE-2021-1234",
					Severity:         "HIGH",
					Description:      "Test vulnerability",
					AffectedPackages: []string{"openssl"},
				},
			},
			ScanTime: time.Now(),
		}

		mockScanner.On("ScanContainer", ctx, image).Return(expectedResult, nil)

		result, err := manager.ScanContainer(ctx, image)
		require.NoError(t, err)
		assert.Equal(t, expectedResult, result)

		mockScanner.AssertExpectations(t)
	})

	t.Run("handles scan errors gracefully", func(t *testing.T) {
		ctx := context.Background()
		image := "invalid:image"

		mockScanner.On("ScanContainer", ctx, image).Return((*ScanResult)(nil), assert.AnError)

		result, err := manager.ScanContainer(ctx, image)
		assert.Error(t, err)
		assert.Nil(t, result)

		mockScanner.AssertExpectations(t)
	})

	t.Run("filters vulnerabilities by severity threshold", func(t *testing.T) {
		ctx := context.Background()
		image := "test:latest"

		scanResult := &ScanResult{
			Target: image,
			Vulnerabilities: []*Vulnerability{
				{ID: "CVE-1", Severity: "CRITICAL"},
				{ID: "CVE-2", Severity: "HIGH"},
				{ID: "CVE-3", Severity: "MEDIUM"},
				{ID: "CVE-4", Severity: "LOW"},
			},
		}

		mockScanner.On("ScanContainer", ctx, image).Return(scanResult, nil)

		result, err := manager.ScanContainer(ctx, image)
		require.NoError(t, err)

		// Should only return HIGH and CRITICAL vulnerabilities
		assert.Len(t, result.Vulnerabilities, 2)
		assert.Equal(t, "CVE-1", result.Vulnerabilities[0].ID)
		assert.Equal(t, "CVE-2", result.Vulnerabilities[1].ID)

		mockScanner.AssertExpectations(t)
	})
}

func TestVulnerabilityManager_ScanDependencies(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		EnableDependencyCheck: true,
		SeverityThreshold:     "MEDIUM",
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(t, err)

	mockScanner := &MockSecurityScanner{}
	manager.scanner = mockScanner

	t.Run("scans dependencies successfully", func(t *testing.T) {
		ctx := context.Background()
		path := "/app/go.mod"

		expectedResult := &ScanResult{
			Target: path,
			Vulnerabilities: []*Vulnerability{
				{
					ID:               "GO-2021-1234",
					Severity:         "HIGH",
					Description:      "Vulnerability in Go dependency",
					AffectedPackages: []string{"github.com/example/vulnerable"},
				},
			},
			ScanTime: time.Now(),
		}

		mockScanner.On("ScanDependencies", ctx, path).Return(expectedResult, nil)

		result, err := manager.ScanDependencies(ctx, path)
		require.NoError(t, err)
		assert.Equal(t, expectedResult, result)

		mockScanner.AssertExpectations(t)
	})

	t.Run("skips scan when dependency check disabled", func(t *testing.T) {
		config.EnableDependencyCheck = false
		manager.config = config

		ctx := context.Background()
		path := "/app/go.mod"

		result, err := manager.ScanDependencies(ctx, path)
		require.NoError(t, err)
		assert.Nil(t, result)
	})
}

func TestVulnerabilityManager_RemediateVulnerability(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		AutoRemediation:   true,
		SeverityThreshold: "HIGH",
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(t, err)

	mockRemediation := &MockRemediationEngine{}
	manager.remediation = mockRemediation

	t.Run("remediates vulnerability successfully", func(t *testing.T) {
		ctx := context.Background()
		vuln := &Vulnerability{
			ID:           "CVE-2021-1234",
			Severity:     "HIGH",
			Description:  "Test vulnerability",
			FixAvailable: true,
			FixVersion:   "1.2.3",
		}

		expectedResult := &RemediationResult{
			VulnerabilityID: vuln.ID,
			Success:         true,
			Action:          "Updated package to version 1.2.3",
			Timestamp:       time.Now(),
		}

		mockRemediation.On("RemediateVulnerability", ctx, vuln).Return(expectedResult, nil)

		result, err := manager.RemediateVulnerability(ctx, vuln)
		require.NoError(t, err)
		assert.Equal(t, expectedResult, result)

		mockRemediation.AssertExpectations(t)
	})

	t.Run("skips remediation when auto-remediation disabled", func(t *testing.T) {
		config.AutoRemediation = false
		manager.config = config

		ctx := context.Background()
		vuln := &Vulnerability{ID: "CVE-2021-1234", Severity: "HIGH"}

		result, err := manager.RemediateVulnerability(ctx, vuln)
		require.NoError(t, err)
		assert.Nil(t, result)
	})

	t.Run("skips remediation for low severity vulnerabilities", func(t *testing.T) {
		config.AutoRemediation = true
		config.SeverityThreshold = "HIGH"
		manager.config = config

		ctx := context.Background()
		vuln := &Vulnerability{ID: "CVE-2021-1234", Severity: "MEDIUM"}

		result, err := manager.RemediateVulnerability(ctx, vuln)
		require.NoError(t, err)
		assert.Nil(t, result)
	})
}

func TestVulnerabilityManager_StartPeriodicScanning(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		EnableCVEScanning:  true,
		ScanInterval:       100 * time.Millisecond, // Short interval for testing
		MaxConcurrentScans: 1,
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(t, err)

	mockScanner := &MockSecurityScanner{}
	manager.scanner = mockScanner

	t.Run("starts periodic scanning", func(t *testing.T) {
		// Mock multiple scan calls
		scanResult := &ScanResult{
			Target:          "test-scan",
			Vulnerabilities: []*Vulnerability{},
			ScanTime:        time.Now(),
		}

		mockScanner.On("ScanContainer", mock.Anything, mock.AnythingOfType("string")).
			Return(scanResult, nil).Times(2)

		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		// Start scanning with some targets
		targets := []string{"nginx:latest", "redis:latest"}
		go manager.StartPeriodicScanning(ctx, targets)

		// Wait for at least one scan cycle
		time.Sleep(200 * time.Millisecond)

		// Cancel context to stop scanning
		cancel()

		// Give some time for cleanup
		time.Sleep(50 * time.Millisecond)

		mockScanner.AssertExpectations(t)
	})
}

func TestVulnerabilityManager_GetVulnerabilityReport(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		EnableCVEScanning: true,
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(t, err)

	t.Run("generates vulnerability report", func(t *testing.T) {
		// Add some test vulnerabilities to the manager's internal state
		vulnerabilities := []*Vulnerability{
			{ID: "CVE-1", Severity: "CRITICAL", AffectedPackages: []string{"pkg1"}},
			{ID: "CVE-2", Severity: "HIGH", AffectedPackages: []string{"pkg2"}},
			{ID: "CVE-3", Severity: "MEDIUM", AffectedPackages: []string{"pkg3"}},
		}

		// Simulate adding vulnerabilities to manager state
		manager.mutex.Lock()
		if manager.vulnerabilities == nil {
			manager.vulnerabilities = make(map[string]*Vulnerability)
		}
		for _, vuln := range vulnerabilities {
			manager.vulnerabilities[vuln.ID] = vuln
		}
		manager.mutex.Unlock()

		report := manager.GetVulnerabilityReport()

		assert.NotNil(t, report)
		assert.Len(t, report.Vulnerabilities, 3)
		assert.Equal(t, 1, report.Summary.Critical)
		assert.Equal(t, 1, report.Summary.High)
		assert.Equal(t, 1, report.Summary.Medium)
		assert.Equal(t, 0, report.Summary.Low)
		assert.Equal(t, 3, report.Summary.Total)
	})
}

func TestVulnerabilityManager_SeverityComparison(t *testing.T) {
	tests := []struct {
		severity  string
		threshold string
		expected  bool
	}{
		{"CRITICAL", "HIGH", true},
		{"HIGH", "HIGH", true},
		{"MEDIUM", "HIGH", false},
		{"LOW", "HIGH", false},
		{"CRITICAL", "MEDIUM", true},
		{"HIGH", "MEDIUM", true},
		{"MEDIUM", "MEDIUM", true},
		{"LOW", "MEDIUM", false},
		{"CRITICAL", "LOW", true},
		{"HIGH", "LOW", true},
		{"MEDIUM", "LOW", true},
		{"LOW", "LOW", true},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("%s_vs_%s", tt.severity, tt.threshold), func(t *testing.T) {
			result := isSeverityAboveThreshold(tt.severity, tt.threshold)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestVulnerabilityManager_ConcurrentScanning(t *testing.T) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		EnableCVEScanning:  true,
		MaxConcurrentScans: 2, // Limit concurrency for testing
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(t, err)

	mockScanner := &MockSecurityScanner{}
	manager.scanner = mockScanner

	t.Run("handles concurrent scans within limit", func(t *testing.T) {
		scanResult := &ScanResult{
			Target:          "test",
			Vulnerabilities: []*Vulnerability{},
			ScanTime:        time.Now(),
		}

		// Mock scanner calls with delay to simulate concurrent execution
		mockScanner.On("ScanContainer", mock.Anything, mock.AnythingOfType("string")).
			Return(scanResult, nil).
			Run(func(args mock.Arguments) {
				time.Sleep(100 * time.Millisecond) // Simulate scan time
			})

		ctx := context.Background()
		images := []string{"img1", "img2", "img3", "img4"}

		start := time.Now()
		results := make([]*ScanResult, len(images))

		// Start concurrent scans
		for i, image := range images {
			go func(idx int, img string) {
				result, err := manager.ScanContainer(ctx, img)
				require.NoError(t, err)
				results[idx] = result
			}(i, image)
		}

		// Wait for all scans to complete
		time.Sleep(500 * time.Millisecond)
		duration := time.Since(start)

		// Should complete faster than sequential execution due to concurrency
		assert.Less(t, duration, 400*time.Millisecond)

		// Verify all results
		for _, result := range results {
			assert.NotNil(t, result)
		}

		mockScanner.AssertExpectations(t)
	})
}

func BenchmarkVulnerabilityManager_ScanContainer(b *testing.B) {
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelError}))
	config := &VulnManagerConfig{
		EnableCVEScanning: true,
	}

	manager, err := NewVulnerabilityManager(config, logger)
	require.NoError(b, err)

	mockScanner := &MockSecurityScanner{}
	manager.scanner = mockScanner

	scanResult := &ScanResult{
		Target:          "nginx:latest",
		Vulnerabilities: []*Vulnerability{},
		ScanTime:        time.Now(),
	}

	mockScanner.On("ScanContainer", mock.Anything, mock.AnythingOfType("string")).Return(scanResult, nil)

	ctx := context.Background()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := manager.ScanContainer(ctx, "nginx:latest")
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkVulnerabilityManager_FilterVulnerabilities(b *testing.B) {
	vulnerabilities := make([]*Vulnerability, 1000)
	severities := []string{"CRITICAL", "HIGH", "MEDIUM", "LOW"}

	for i := 0; i < 1000; i++ {
		vulnerabilities[i] = &Vulnerability{
			ID:       fmt.Sprintf("CVE-%d", i),
			Severity: severities[i%4],
		}
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		filtered := filterVulnerabilitiesBySeverity(vulnerabilities, "HIGH")
		if len(filtered) == 0 {
			b.Fatal("No vulnerabilities filtered")
		}
	}
}
