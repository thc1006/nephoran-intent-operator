package security

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"math/big"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap/zaptest"
	"google.golang.org/grpc"
	"google.golang.org/grpc/test/bufconn"
)

// Helper function to generate test certificates
func generateTestCert(t *testing.T, isCA bool, parent *x509.Certificate, parentKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, []byte, []byte) {
	t.Helper()

	key, err := rsa.GenerateKey(rand.Reader, 2048)
	require.NoError(t, err)

	template := &x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			Organization:  []string{"Test Org"},
			Country:       []string{"US"},
			Province:      []string{""},
			Locality:      []string{"Test City"},
			StreetAddress: []string{""},
			PostalCode:    []string{""},
		},
		NotBefore:   time.Now(),
		NotAfter:    time.Now().Add(365 * 24 * time.Hour),
		KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
		IPAddresses: []net.IP{net.IPv4(127, 0, 0, 1)},
		DNSNames:    []string{"localhost", "test.example.com"},
	}

	if isCA {
		template.IsCA = true
		template.KeyUsage |= x509.KeyUsageCertSign
		parent = template
		parentKey = key
	}

	if parent == nil {
		parent = template
		parentKey = key
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, parent, &key.PublicKey, parentKey)
	require.NoError(t, err)

	cert, err := x509.ParseCertificate(certDER)
	require.NoError(t, err)

	certPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certDER,
	})

	keyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(key),
	})

	return cert, key, certPEM, keyPEM
}

func TestTLSManager_New(t *testing.T) {
	logger := zaptest.NewLogger(t)

	t.Run("creates new TLS manager with valid config", func(t *testing.T) {
		config := &TLSManagerConfig{
			CertFile:           "/tmp/cert.pem",
			KeyFile:            "/tmp/key.pem",
			CAFile:             "/tmp/ca.pem",
			MinTLSVersion:      "1.3",
			CertRotationPeriod: 24 * time.Hour,
			WatchCertFiles:     true,
		}

		manager, err := NewTLSManager(config, logger)
		require.NoError(t, err)
		assert.NotNil(t, manager)
		assert.Equal(t, config, manager.config)
		assert.Equal(t, logger, manager.logger)
	})

	t.Run("returns error with nil config", func(t *testing.T) {
		_, err := NewTLSManager(nil, logger)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "config cannot be nil")
	})

	t.Run("returns error with nil logger", func(t *testing.T) {
		config := &TLSManagerConfig{
			CertFile: "/tmp/cert.pem",
			KeyFile:  "/tmp/key.pem",
		}

		_, err := NewTLSManager(config, nil)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "logger cannot be nil")
	})
}

func TestTLSManager_LoadCertificates(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(t, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(t, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(t, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:           certFile,
		KeyFile:            keyFile,
		CAFile:             caFile,
		MinTLSVersion:      "1.3",
		CertRotationPeriod: 24 * time.Hour,
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)

	t.Run("loads certificates successfully", func(t *testing.T) {
		err := manager.LoadCertificates()
		require.NoError(t, err)

		assert.NotNil(t, manager.cert)
		assert.NotNil(t, manager.caCertPool)
	})

	t.Run("returns error for missing cert file", func(t *testing.T) {
		config.CertFile = "/nonexistent/cert.pem"
		manager.config = config

		err := manager.LoadCertificates()
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to load certificate")
	})
}

func TestTLSManager_GetServerTLSConfig(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(t, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(t, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(t, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:           certFile,
		KeyFile:            keyFile,
		CAFile:             caFile,
		MinTLSVersion:      "1.3",
		RequireClientCert:  true,
		CertRotationPeriod: 24 * time.Hour,
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)
	require.NoError(t, manager.LoadCertificates())

	t.Run("returns valid server TLS config", func(t *testing.T) {
		tlsConfig := manager.GetServerTLSConfig()

		assert.NotNil(t, tlsConfig)
		assert.Equal(t, uint16(tls.VersionTLS13), tlsConfig.MinVersion)
		assert.Equal(t, tls.RequireAndVerifyClientCert, tlsConfig.ClientAuth)
		assert.NotNil(t, tlsConfig.ClientCAs)
		assert.NotNil(t, tlsConfig.GetCertificate)
	})

	t.Run("configures client auth based on config", func(t *testing.T) {
		config.RequireClientCert = false
		tlsConfig := manager.GetServerTLSConfig()

		assert.Equal(t, tls.NoClientCert, tlsConfig.ClientAuth)
	})
}

func TestTLSManager_GetClientTLSConfig(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(t, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(t, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(t, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:      certFile,
		KeyFile:       keyFile,
		CAFile:        caFile,
		MinTLSVersion: "1.3",
		ServerName:    "test.example.com",
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)
	require.NoError(t, manager.LoadCertificates())

	t.Run("returns valid client TLS config", func(t *testing.T) {
		tlsConfig := manager.GetClientTLSConfig()

		assert.NotNil(t, tlsConfig)
		assert.Equal(t, uint16(tls.VersionTLS13), tlsConfig.MinVersion)
		assert.Equal(t, "test.example.com", tlsConfig.ServerName)
		assert.NotNil(t, tlsConfig.RootCAs)
		assert.NotEmpty(t, tlsConfig.Certificates)
	})
}

func TestTLSManager_HTTPSServer(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(t, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(t, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(t, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:      certFile,
		KeyFile:       keyFile,
		CAFile:        caFile,
		MinTLSVersion: "1.2", // Use 1.2 for compatibility with test client
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)
	require.NoError(t, manager.LoadCertificates())

	t.Run("creates secure HTTPS server", func(t *testing.T) {
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			w.Write([]byte("Hello, TLS!"))
		})

		server := manager.CreateHTTPSServer(":0", handler)
		assert.NotNil(t, server)
		assert.NotNil(t, server.TLSConfig)
		assert.Equal(t, uint16(tls.VersionTLS12), server.TLSConfig.MinVersion)
	})
}

func TestTLSManager_GRPCServer(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(t, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(t, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(t, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:      certFile,
		KeyFile:       keyFile,
		CAFile:        caFile,
		MinTLSVersion: "1.3",
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)
	require.NoError(t, manager.LoadCertificates())

	t.Run("creates secure gRPC server", func(t *testing.T) {
		creds, err := manager.GetGRPCServerCredentials()
		require.NoError(t, err)
		assert.NotNil(t, creds)

		server := grpc.NewServer(grpc.Creds(creds))
		assert.NotNil(t, server)
	})

	t.Run("creates gRPC client credentials", func(t *testing.T) {
		creds, err := manager.GetGRPCClientCredentials()
		require.NoError(t, err)
		assert.NotNil(t, creds)
	})
}

func TestTLSManager_CertificateRotation(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate initial certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(t, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(t, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(t, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:           certFile,
		KeyFile:            keyFile,
		CAFile:             caFile,
		MinTLSVersion:      "1.3",
		CertRotationPeriod: 100 * time.Millisecond, // Short period for testing
		WatchCertFiles:     true,
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)
	require.NoError(t, manager.LoadCertificates())

	t.Run("rotates certificates automatically", func(t *testing.T) {
		// Start certificate rotation
		go manager.StartCertificateRotation()
		defer manager.StopCertificateRotation()

		// Get initial certificate serial
		initialSerial := manager.cert.Leaf.SerialNumber

		// Generate new certificate and update files
		_, _, newCertPEM, newKeyPEM := generateTestCert(t, false, caCert, caKey)

		// Update certificate files
		require.NoError(t, ioutil.WriteFile(certFile, newCertPEM, 0600))
		require.NoError(t, ioutil.WriteFile(keyFile, newKeyPEM, 0600))

		// Wait for rotation to occur
		time.Sleep(200 * time.Millisecond)

		// Certificate should be updated
		newSerial := manager.cert.Leaf.SerialNumber
		assert.NotEqual(t, initialSerial, newSerial)
	})
}

func TestTLSManager_CertificateExpiry(t *testing.T) {
	logger := zaptest.NewLogger(t)
	tempDir := t.TempDir()

	// Generate certificate that expires soon
	key, err := rsa.GenerateKey(rand.Reader, 2048)
	require.NoError(t, err)

	template := &x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			Organization: []string{"Test Org"},
		},
		NotBefore:   time.Now(),
		NotAfter:    time.Now().Add(1 * time.Hour), // Expires in 1 hour
		KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, template, &key.PublicKey, key)
	require.NoError(t, err)

	certPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certDER,
	})

	keyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(key),
	})

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")

	require.NoError(t, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(t, ioutil.WriteFile(keyFile, keyPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:      certFile,
		KeyFile:       keyFile,
		MinTLSVersion: "1.3",
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(t, err)
	require.NoError(t, manager.LoadCertificates())

	t.Run("detects certificate expiry", func(t *testing.T) {
		expiry := manager.GetCertificateExpiry()
		assert.True(t, expiry.Before(time.Now().Add(2*time.Hour)))
		assert.True(t, expiry.After(time.Now()))
	})

	t.Run("checks if certificate expires soon", func(t *testing.T) {
		// Should expire within 2 hours
		expiresSoon := manager.CertificateExpiresSoon(2 * time.Hour)
		assert.True(t, expiresSoon)

		// Should not expire within 30 minutes
		expiresSoon = manager.CertificateExpiresSoon(30 * time.Minute)
		assert.False(t, expiresSoon)
	})
}

func TestTLSManager_ValidateTLSVersion(t *testing.T) {
	tests := []struct {
		version string
		valid   bool
	}{
		{"1.0", true},
		{"1.1", true},
		{"1.2", true},
		{"1.3", true},
		{"1.4", false},
		{"invalid", false},
		{"", false},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("version_%s", tt.version), func(t *testing.T) {
			_, err := parseTLSVersion(tt.version)
			if tt.valid {
				assert.NoError(t, err)
			} else {
				assert.Error(t, err)
			}
		})
	}
}

func BenchmarkTLSManager_LoadCertificates(b *testing.B) {
	logger := zaptest.NewLogger(b)
	tempDir := b.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(b, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(b, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(b, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(b, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(b, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile: certFile,
		KeyFile:  keyFile,
		CAFile:   caFile,
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(b, err)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err := manager.LoadCertificates()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkTLSManager_GetServerTLSConfig(b *testing.B) {
	logger := zaptest.NewLogger(b)
	tempDir := b.TempDir()

	// Generate test certificates
	caCert, caKey, caCertPEM, _ := generateTestCert(b, true, nil, nil)
	_, _, certPEM, keyPEM := generateTestCert(b, false, caCert, caKey)

	// Write certificates to temp files
	certFile := filepath.Join(tempDir, "cert.pem")
	keyFile := filepath.Join(tempDir, "key.pem")
	caFile := filepath.Join(tempDir, "ca.pem")

	require.NoError(b, ioutil.WriteFile(certFile, certPEM, 0600))
	require.NoError(b, ioutil.WriteFile(keyFile, keyPEM, 0600))
	require.NoError(b, ioutil.WriteFile(caFile, caCertPEM, 0600))

	config := &TLSManagerConfig{
		CertFile:          certFile,
		KeyFile:           keyFile,
		CAFile:            caFile,
		RequireClientCert: true,
	}

	manager, err := NewTLSManager(config, logger)
	require.NoError(b, err)
	require.NoError(b, manager.LoadCertificates())

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		config := manager.GetServerTLSConfig()
		if config == nil {
			b.Fatal("TLS config is nil")
		}
	}
}
